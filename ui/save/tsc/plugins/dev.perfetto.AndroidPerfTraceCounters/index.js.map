{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.AndroidPerfTraceCounters/index.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;AAIjC,uEAAwE;AACxE,oFAAiF;AAEjF,MAAM,gCAAgC,GAAG;;;;;;;CAOxC,CAAC;AAEF;IACE,MAAM,CAAU,EAAE,GAAG,uCAAuC,CAAC;IAC7D,KAAK,CAAC,WAAW,CAAC,GAAU;QAC1B,MAAM,IAAI,GAAG,MAAM,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,gCAAgC,CAAC,CAAC;QACtE,IAAI,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC;YAAE,OAAO;QACjC,GAAG,CAAC,QAAQ,CAAC,eAAe,CAAC;YAC3B,EAAE,EAAE,wDAAwD;YAC5D,IAAI,EAAE,0CAA0C;YAChD,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE;gBACtB,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;oBACtB,GAAG,GAAG,MAAM,CAAC,oBAAoB,EAAE,EAAE,CAAC,CAAC;oBACvC,IAAI,GAAG,KAAK,IAAI;wBAAE,OAAO;gBAC3B,CAAC;gBACD,MAAM,SAAS,GAAG;;;;;;;;;;;;;gEAasC,GAAG;;;;gCAInC,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;SA2B1B,CAAC;gBAEF,MAAM,IAAA,iCAAkB,EAAC;oBACvB,KAAK,EAAE,GAAG;oBACV,IAAI,EAAE;wBACJ,SAAS,EACP,SAAS;4BACT;yEAC2D;qBAC9D;oBACD,KAAK,EAAE,aAAa,GAAG,GAAG;oBAC1B,OAAO,EAAE,EAAC,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAC;oBAC5C,UAAU,EAAE;wBACV,aAAa;wBACb,OAAO;wBACP,mBAAmB;wBACnB,eAAe;qBAChB;iBACF,CAAC,CAAC;gBACH,IAAA,qCAAkB,EAAC,GAAG,EAAE;oBACtB,KAAK,EACH,SAAS;wBACT;;;;;;;;8DAQkD;oBACpD,KAAK,EAAE,6BAA6B;iBACrC,CAAC,CAAC;YACL,CAAC;SACF,CAAC,CAAC;IACL,CAAC;;AA5FH,4BA6FC","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Trace} from '../../public/trace';\nimport {PerfettoPlugin} from '../../public/plugin';\nimport {addDebugSliceTrack} from '../../components/tracks/debug_tracks';\nimport {addQueryResultsTab} from '../../components/query_table/query_result_tab';\n\nconst PERF_TRACE_COUNTERS_PRECONDITION = `\n  SELECT\n    str_value\n  FROM metadata\n  WHERE\n    name = 'trace_config_pbtxt'\n    AND str_value GLOB '*ftrace_events: \"perf_trace_counters/sched_switch_with_ctrs\"*'\n`;\n\nexport default class implements PerfettoPlugin {\n  static readonly id = 'dev.perfetto.AndroidPerfTraceCounters';\n  async onTraceLoad(ctx: Trace): Promise<void> {\n    const resp = await ctx.engine.query(PERF_TRACE_COUNTERS_PRECONDITION);\n    if (resp.numRows() === 0) return;\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidPerfTraceCounters#ThreadRuntimeIPC',\n      name: 'Add a track to show a thread runtime ipc',\n      callback: async (tid) => {\n        if (tid === undefined) {\n          tid = prompt('Enter a thread tid', '');\n          if (tid === null) return;\n        }\n        const sqlPrefix = `\n          WITH\n            sched_switch_ipc AS (\n              SELECT\n                ts,\n                EXTRACT_ARG(arg_set_id, 'prev_pid') AS tid,\n                EXTRACT_ARG(arg_set_id, 'prev_comm') AS thread_name,\n                EXTRACT_ARG(arg_set_id, 'inst') / (EXTRACT_ARG(arg_set_id, 'cyc') * 1.0) AS ipc,\n                EXTRACT_ARG(arg_set_id, 'inst') AS instruction,\n                EXTRACT_ARG(arg_set_id, 'cyc') AS cycle,\n                EXTRACT_ARG(arg_set_id, 'stallbm') AS stall_backend_mem,\n                EXTRACT_ARG(arg_set_id, 'l3dm') AS l3_cache_miss\n              FROM ftrace_event\n              WHERE name = 'sched_switch_with_ctrs' AND tid = ${tid}\n            ),\n            target_thread_sched_slice AS (\n              SELECT s.*, t.tid, t.name FROM sched s LEFT JOIN thread t USING (utid)\n                WHERE t.tid = ${tid}\n            ),\n            target_thread_ipc_slice AS (\n              SELECT\n                (\n                  SELECT\n                    ts\n                  FROM target_thread_sched_slice ts\n                  WHERE ts.tid = ssi.tid AND ts.ts < ssi.ts\n                  ORDER BY ts.ts DESC\n                  LIMIT 1\n                ) AS ts,\n                (\n                  SELECT\n                    dur\n                  FROM target_thread_sched_slice ts\n                  WHERE ts.tid = ssi.tid AND ts.ts < ssi.ts\n                  ORDER BY ts.ts DESC\n                  LIMIT 1\n                ) AS dur,\n                ssi.ipc,\n                ssi.instruction,\n                ssi.cycle,\n                ssi.stall_backend_mem,\n                ssi.l3_cache_miss\n              FROM sched_switch_ipc ssi\n            )\n        `;\n\n        await addDebugSliceTrack({\n          trace: ctx,\n          data: {\n            sqlSource:\n              sqlPrefix +\n              `\n              SELECT * FROM target_thread_ipc_slice WHERE ts IS NOT NULL`,\n          },\n          title: 'Rutime IPC:' + tid,\n          columns: {ts: 'ts', dur: 'dur', name: 'ipc'},\n          argColumns: [\n            'instruction',\n            'cycle',\n            'stall_backend_mem',\n            'l3_cache_miss',\n          ],\n        });\n        addQueryResultsTab(ctx, {\n          query:\n            sqlPrefix +\n            `\n            SELECT\n              (sum(instruction) * 1.0 / sum(cycle)*1.0) AS avg_ipc,\n              sum(dur)/1e6 as total_runtime_ms,\n              sum(instruction) AS total_instructions,\n              sum(cycle) AS total_cycles,\n              sum(stall_backend_mem) as total_stall_backend_mem,\n              sum(l3_cache_miss) as total_l3_cache_miss\n            FROM target_thread_ipc_slice WHERE ts IS NOT NULL`,\n          title: 'target thread ipc statistic',\n        });\n      },\n    });\n  }\n}\n"]}