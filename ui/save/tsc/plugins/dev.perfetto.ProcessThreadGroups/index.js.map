{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.ProcessThreadGroups/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Trace} from '../../public/trace';\nimport {PerfettoPlugin} from '../../public/plugin';\nimport {TrackNode} from '../../public/workspace';\nimport {NUM, STR, STR_NULL} from '../../trace_processor/query_result';\n\nfunction stripPathFromExecutable(path: string) {\n  if (path[0] === '/') {\n    return path.split('/').slice(-1)[0];\n  } else {\n    return path;\n  }\n}\n\nfunction getThreadDisplayName(threadName: string | undefined, tid: number) {\n  if (threadName) {\n    return `${stripPathFromExecutable(threadName)} ${tid}`;\n  } else {\n    return `Thread ${tid}`;\n  }\n}\n\n// This plugin is responsible for organizing all process and thread groups\n// including the kernel groups, sorting, and adding summary tracks.\nexport default class implements PerfettoPlugin {\n  static readonly id = 'dev.perfetto.ProcessThreadGroups';\n\n  private readonly processGroups = new Map<number, TrackNode>();\n  private readonly threadGroups = new Map<number, TrackNode>();\n\n  constructor(private readonly ctx: Trace) {}\n\n  getGroupForProcess(upid: number): TrackNode | undefined {\n    return this.processGroups.get(upid);\n  }\n\n  getGroupForThread(utid: number): TrackNode | undefined {\n    return this.threadGroups.get(utid);\n  }\n\n  async onTraceLoad(ctx: Trace): Promise<void> {\n    // Pre-group all kernel \"threads\" (actually processes) if this is a linux\n    // system trace. Below, addProcessTrackGroups will skip them due to an\n    // existing group uuid, and addThreadStateTracks will fill in the\n    // per-thread tracks. Quirk: since all threads will appear to be\n    // TrackKindPriority.MAIN_THREAD, any process-level tracks will end up\n    // pushed to the bottom of the group in the UI.\n    await this.addKernelThreadGrouping();\n\n    // Create the per-process track groups. Note that this won't necessarily\n    // create a track per process. If a process has been completely idle and has\n    // no sched events, no track group will be emitted.\n    // Will populate this.addTrackGroupActions\n    await this.addProcessGroups();\n    await this.addThreadGroups();\n\n    ctx.onTraceReady.addListener(() => {\n      // If, by the time the trace has finished loading, some of the process or\n      // thread group tracks nodes have no children, just remove them.\n      const removeIfEmpty = (g: TrackNode) => {\n        if (!g.hasChildren) {\n          g.remove();\n        }\n      };\n      this.processGroups.forEach(removeIfEmpty);\n      this.threadGroups.forEach(removeIfEmpty);\n    });\n  }\n\n  private async addKernelThreadGrouping(): Promise<void> {\n    // Identify kernel threads if this is a linux system trace, and sufficient\n    // process information is available. Kernel threads are identified by being\n    // children of kthreadd (always pid 2).\n    // The query will return the kthreadd process row first, which must exist\n    // for any other kthreads to be returned by the query.\n    // TODO(rsavitski): figure out how to handle the idle process (swapper),\n    // which has pid 0 but appears as a distinct process (with its own comm) on\n    // each cpu. It'd make sense to exclude its thread state track, but still\n    // put process-scoped tracks in this group.\n    const result = await this.ctx.engine.query(`\n      select\n        t.utid, p.upid, (case p.pid when 2 then 1 else 0 end) isKthreadd\n      from\n        thread t\n        join process p using (upid)\n        left join process parent on (p.parent_upid = parent.upid)\n        join\n          (select true from metadata m\n             where (m.name = 'system_name' and m.str_value = 'Linux')\n           union\n           select 1 from (select true from sched limit 1))\n      where\n        p.pid = 2 or parent.pid = 2\n      order by isKthreadd desc\n    `);\n\n    const it = result.iter({\n      utid: NUM,\n      upid: NUM,\n    });\n\n    // Not applying kernel thread grouping.\n    if (!it.valid()) {\n      return;\n    }\n\n    // Create the track group. Use kthreadd's PROCESS_SUMMARY_TRACK for the\n    // main track. It doesn't summarise the kernel threads within the group,\n    // but creating a dedicated track type is out of scope at the time of\n    // writing.\n    const kernelThreadsGroup = new TrackNode({\n      title: 'Kernel threads',\n      uri: '/kernel',\n      sortOrder: 50,\n      isSummary: true,\n    });\n    this.ctx.workspace.addChildInOrder(kernelThreadsGroup);\n\n    // Set the group for all kernel threads (including kthreadd itself).\n    for (; it.valid(); it.next()) {\n      const {utid} = it;\n\n      const threadGroup = new TrackNode({\n        uri: `thread${utid}`,\n        title: `Thread ${utid}`,\n        isSummary: true,\n        headless: true,\n      });\n      kernelThreadsGroup.addChildInOrder(threadGroup);\n      this.threadGroups.set(utid, threadGroup);\n    }\n  }\n\n  // Adds top level groups for processes and thread that don't belong to a\n  // process.\n  private async addProcessGroups(): Promise<void> {\n    const result = await this.ctx.engine.query(`\n      with processGroups as (\n        select\n          upid,\n          process.pid as pid,\n          process.name as processName,\n          sum_running_dur as sumRunningDur,\n          thread_slice_count + process_slice_count as sliceCount,\n          perf_sample_count as perfSampleCount,\n          allocation_count as heapProfileAllocationCount,\n          graph_object_count as heapGraphObjectCount,\n          (\n            select group_concat(string_value)\n            from args\n            where\n              process.arg_set_id is not null and\n              arg_set_id = process.arg_set_id and\n              flat_key = 'chrome.process_label'\n          ) chromeProcessLabels,\n          case process.name\n            when 'Browser' then 3\n            when 'Gpu' then 2\n            when 'Renderer' then 1\n            else 0\n          end as chromeProcessRank\n        from _process_available_info_summary\n        join process using(upid)\n      ),\n      threadGroups as (\n        select\n          utid,\n          tid,\n          thread.name as threadName,\n          sum_running_dur as sumRunningDur,\n          slice_count as sliceCount,\n          perf_sample_count as perfSampleCount\n        from _thread_available_info_summary\n        join thread using (utid)\n        where upid is null\n      )\n      select *\n      from (\n        select\n          'process' as kind,\n          upid as uid,\n          pid as id,\n          processName as name\n        from processGroups\n        order by\n          chromeProcessRank desc,\n          heapProfileAllocationCount desc,\n          heapGraphObjectCount desc,\n          perfSampleCount desc,\n          sumRunningDur desc,\n          sliceCount desc,\n          processName asc,\n          upid asc\n      )\n      union all\n      select *\n      from (\n        select\n          'thread' as kind,\n          utid as uid,\n          tid as id,\n          threadName as name\n        from threadGroups\n        order by\n          perfSampleCount desc,\n          sumRunningDur desc,\n          sliceCount desc,\n          threadName asc,\n          utid asc\n      )\n  `);\n\n    const it = result.iter({\n      kind: STR,\n      uid: NUM,\n      id: NUM,\n      name: STR_NULL,\n    });\n    for (; it.valid(); it.next()) {\n      const {kind, uid, id, name} = it;\n\n      if (kind === 'process') {\n        // Ignore kernel process groups\n        if (this.processGroups.has(uid)) {\n          continue;\n        }\n\n        function getProcessDisplayName(\n          processName: string | undefined,\n          pid: number,\n        ) {\n          if (processName) {\n            return `${stripPathFromExecutable(processName)} ${pid}`;\n          } else {\n            return `Process ${pid}`;\n          }\n        }\n\n        const displayName = getProcessDisplayName(name ?? undefined, id);\n        const group = new TrackNode({\n          uri: `/process_${uid}`,\n          title: displayName,\n          isSummary: true,\n          sortOrder: 50,\n        });\n\n        // Re-insert the child node to sort it\n        this.ctx.workspace.addChildInOrder(group);\n        this.processGroups.set(uid, group);\n      } else {\n        // Ignore kernel process groups\n        if (this.threadGroups.has(uid)) {\n          continue;\n        }\n\n        const displayName = getThreadDisplayName(name ?? undefined, id);\n        const group = new TrackNode({\n          uri: `/thread_${uid}`,\n          title: displayName,\n          isSummary: true,\n          sortOrder: 50,\n        });\n\n        // Re-insert the child node to sort it\n        this.ctx.workspace.addChildInOrder(group);\n        this.threadGroups.set(uid, group);\n      }\n    }\n  }\n\n  // Create all the nested & headless thread groups that live inside existing\n  // process groups.\n  private async addThreadGroups(): Promise<void> {\n    const result = await this.ctx.engine.query(`\n      with threadGroups as (\n        select\n          utid,\n          upid,\n          tid,\n          thread.name as threadName,\n          CASE\n            WHEN thread.is_main_thread = 1 THEN 10\n            WHEN thread.name = 'CrBrowserMain' THEN 10\n            WHEN thread.name = 'CrRendererMain' THEN 10\n            WHEN thread.name = 'CrGpuMain' THEN 10\n            WHEN thread.name glob '*RenderThread*' THEN 9\n            WHEN thread.name glob '*GPU completion*' THEN 8\n            WHEN thread.name = 'Chrome_ChildIOThread' THEN 7\n            WHEN thread.name = 'Chrome_IOThread' THEN 7\n            WHEN thread.name = 'Compositor' THEN 6\n            WHEN thread.name = 'VizCompositorThread' THEN 6\n            ELSE 5\n          END as priority\n        from _thread_available_info_summary\n        join thread using (utid)\n        where upid is not null\n      )\n      select *\n      from (\n        select\n          utid,\n          upid,\n          tid,\n          threadName\n        from threadGroups\n        order by\n          priority desc,\n          tid asc\n      )\n  `);\n\n    const it = result.iter({\n      utid: NUM,\n      tid: NUM,\n      upid: NUM,\n      threadName: STR_NULL,\n    });\n    for (; it.valid(); it.next()) {\n      const {utid, tid, upid, threadName} = it;\n\n      // Ignore kernel thread groups\n      if (this.threadGroups.has(utid)) {\n        continue;\n      }\n\n      const group = new TrackNode({\n        uri: `/thread_${utid}`,\n        title: getThreadDisplayName(threadName ?? undefined, tid),\n        isSummary: true,\n        headless: true,\n      });\n      this.threadGroups.set(utid, group);\n      this.processGroups.get(upid)?.addChildInOrder(group);\n    }\n  }\n}\n"]}