{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.AndroidCujs/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {addDebugSliceTrack} from '../../components/tracks/debug_tracks';\nimport {Trace} from '../../public/trace';\nimport {PerfettoPlugin} from '../../public/plugin';\nimport {addQueryResultsTab} from '../../components/query_table/query_result_tab';\n\n/**\n * Adds the Debug Slice Track for given Jank CUJ name\n *\n * @param {Trace} ctx For properties and methods of trace viewer\n * @param {string} trackName Display Name of the track\n * @param {string | string[]} cujNames List of Jank CUJs to pin\n */\nexport function addJankCUJDebugTrack(\n  ctx: Trace,\n  trackName: string,\n  cujNames?: string | string[],\n) {\n  const jankCujTrackConfig = generateJankCujTrackConfig(cujNames);\n  addDebugSliceTrack({trace: ctx, title: trackName, ...jankCujTrackConfig});\n}\n\nconst JANK_CUJ_QUERY_PRECONDITIONS = `\n  SELECT RUN_METRIC('android/android_jank_cuj.sql');\n  INCLUDE PERFETTO MODULE android.critical_blocking_calls;\n`;\n\n/**\n * Generate the Track config for a multiple Jank CUJ slices\n *\n * @param {string | string[]} cujNames List of Jank CUJs to pin, default empty\n * @returns Returns the track config for given CUJs\n */\nfunction generateJankCujTrackConfig(cujNames: string | string[] = []) {\n  // This method expects the caller to have run JANK_CUJ_QUERY_PRECONDITIONS\n  // Not running the precondition query here to save time in case already run\n  const jankCujQuery = JANK_CUJ_QUERY;\n  const jankCujColumns = JANK_COLUMNS;\n  const cujNamesList = typeof cujNames === 'string' ? [cujNames] : cujNames;\n  const filterCuj =\n    cujNamesList?.length > 0\n      ? ` AND cuj.name IN (${cujNamesList\n          .map((name) => `'J<${name}>'`)\n          .join(',')})`\n      : '';\n\n  return {\n    data: {\n      sqlSource: `${jankCujQuery}${filterCuj}`,\n      columns: jankCujColumns,\n    },\n    argColumns: jankCujColumns,\n  };\n}\n\nconst JANK_CUJ_QUERY = `\n    SELECT\n      CASE\n        WHEN\n          EXISTS(\n              SELECT 1\n              FROM slice AS cuj_state_marker\n                     JOIN track marker_track\n                          ON marker_track.id = cuj_state_marker.track_id\n              WHERE\n                cuj_state_marker.ts >= cuj.ts\n                AND cuj_state_marker.ts + cuj_state_marker.dur <= cuj.ts + cuj.dur\n                AND\n                ( /* e.g. J<CUJ_NAME>#FT#cancel#0 this for backward compatibility */\n                      cuj_state_marker.name GLOB(cuj.name || '#FT#cancel*')\n                    OR (marker_track.name = cuj.name AND cuj_state_marker.name GLOB 'FT#cancel*')\n                  )\n            )\n          THEN ' ❌ '\n        WHEN\n          EXISTS(\n              SELECT 1\n              FROM slice AS cuj_state_marker\n                     JOIN track marker_track\n                          ON marker_track.id = cuj_state_marker.track_id\n              WHERE\n                cuj_state_marker.ts >= cuj.ts\n                AND cuj_state_marker.ts + cuj_state_marker.dur <= cuj.ts + cuj.dur\n                AND\n                ( /* e.g. J<CUJ_NAME>#FT#end#0 this for backward compatibility */\n                      cuj_state_marker.name GLOB(cuj.name || '#FT#end*')\n                    OR (marker_track.name = cuj.name AND cuj_state_marker.name GLOB 'FT#end*')\n                  )\n            )\n          THEN ' ✅ '\n        ELSE ' ❓ '\n        END || cuj.name AS name,\n      total_frames,\n      missed_app_frames,\n      missed_sf_frames,\n      sf_callback_missed_frames,\n      hwui_callback_missed_frames,\n      cuj_layer.layer_name,\n      /* Boundaries table doesn't contain ts and dur when a CUJ didn't complete successfully.\n        In that case we still want to show that it was canceled, so let's take the slice timestamps. */\n      CASE WHEN boundaries.ts IS NOT NULL THEN boundaries.ts ELSE cuj.ts END AS ts,\n      CASE WHEN boundaries.dur IS NOT NULL THEN boundaries.dur ELSE cuj.dur END AS dur,\n      cuj.track_id,\n      cuj.slice_id\n    FROM slice AS cuj\n           JOIN process_track AS pt ON cuj.track_id = pt.id\n           LEFT JOIN android_jank_cuj jc\n                     ON pt.upid = jc.upid AND cuj.name = jc.cuj_slice_name AND cuj.ts = jc.ts\n           LEFT JOIN android_jank_cuj_main_thread_cuj_boundary boundaries using (cuj_id)\n           LEFT JOIN android_jank_cuj_layer_name cuj_layer USING (cuj_id)\n           LEFT JOIN android_jank_cuj_counter_metrics USING (cuj_id)\n    WHERE cuj.name GLOB 'J<*>'\n      AND cuj.dur > 0\n`;\n\nconst JANK_COLUMNS = [\n  'name',\n  'total_frames',\n  'missed_app_frames',\n  'missed_sf_frames',\n  'sf_callback_missed_frames',\n  'hwui_callback_missed_frames',\n  'layer_name',\n  'ts',\n  'dur',\n  'track_id',\n  'slice_id',\n];\n\nconst LATENCY_CUJ_QUERY = `\n    SELECT\n      CASE\n        WHEN\n          EXISTS(\n              SELECT 1\n              FROM slice AS cuj_state_marker\n                     JOIN track marker_track\n                          ON marker_track.id = cuj_state_marker.track_id\n              WHERE\n                cuj_state_marker.ts >= cuj.ts\n                AND cuj_state_marker.ts + cuj_state_marker.dur <= cuj.ts + cuj.dur\n                AND marker_track.name = cuj.name AND (\n                    cuj_state_marker.name GLOB 'cancel'\n                    OR cuj_state_marker.name GLOB 'timeout')\n            )\n          THEN ' ❌ '\n        ELSE ' ✅ '\n        END || cuj.name AS name,\n      cuj.dur / 1e6 as dur_ms,\n      cuj.ts,\n      cuj.dur,\n      cuj.track_id,\n      cuj.slice_id\n    FROM slice AS cuj\n           JOIN process_track AS pt\n                ON cuj.track_id = pt.id\n    WHERE cuj.name GLOB 'L<*>'\n      AND cuj.dur > 0\n`;\n\nconst LATENCY_COLUMNS = ['name', 'dur_ms', 'ts', 'dur', 'track_id', 'slice_id'];\n\nconst BLOCKING_CALLS_DURING_CUJS_QUERY = `\n    SELECT\n      s.id AS slice_id,\n      s.name,\n      max(s.ts, cuj.ts) AS ts,\n      min(s.ts + s.dur, cuj.ts_end) as ts_end,\n      min(s.ts + s.dur, cuj.ts_end) - max(s.ts, cuj.ts) AS dur,\n      cuj.cuj_id,\n      cuj.cuj_name,\n      s.process_name,\n      s.upid,\n      s.utid,\n      'slice' AS table_name\n    FROM _android_critical_blocking_calls s\n      JOIN  android_jank_cuj cuj\n      -- only when there is an overlap\n      ON s.ts + s.dur > cuj.ts AND s.ts < cuj.ts_end\n          -- and are from the same process\n          AND s.upid = cuj.upid\n`;\n\nconst BLOCKING_CALLS_DURING_CUJS_COLUMNS = [\n  'slice_id',\n  'name',\n  'ts',\n  'cuj_ts',\n  'dur',\n  'cuj_id',\n  'cuj_name',\n  'process_name',\n  'upid',\n  'utid',\n  'table_name',\n];\n\nexport default class implements PerfettoPlugin {\n  static readonly id = 'dev.perfetto.AndroidCujs';\n  async onTraceLoad(ctx: Trace): Promise<void> {\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidCujs#PinJankCUJs',\n      name: 'Add track: Android jank CUJs',\n      callback: () => {\n        ctx.engine.query(JANK_CUJ_QUERY_PRECONDITIONS).then(() => {\n          addJankCUJDebugTrack(ctx, 'Jank CUJs');\n        });\n      },\n    });\n\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidCujs#ListJankCUJs',\n      name: 'Run query: Android jank CUJs',\n      callback: () => {\n        ctx.engine.query(JANK_CUJ_QUERY_PRECONDITIONS).then(() =>\n          addQueryResultsTab(ctx, {\n            query: JANK_CUJ_QUERY,\n            title: 'Android Jank CUJs',\n          }),\n        );\n      },\n    });\n\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidCujs#PinLatencyCUJs',\n      name: 'Add track: Android latency CUJs',\n      callback: () => {\n        addDebugSliceTrack({\n          trace: ctx,\n          data: {\n            sqlSource: LATENCY_CUJ_QUERY,\n            columns: LATENCY_COLUMNS,\n          },\n          title: 'Latency CUJs',\n        });\n      },\n    });\n\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidCujs#ListLatencyCUJs',\n      name: 'Run query: Android Latency CUJs',\n      callback: () =>\n        addQueryResultsTab(ctx, {\n          query: LATENCY_CUJ_QUERY,\n          title: 'Android Latency CUJs',\n        }),\n    });\n\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidCujs#PinBlockingCalls',\n      name: 'Add track: Android Blocking calls during CUJs',\n      callback: () => {\n        ctx.engine.query(JANK_CUJ_QUERY_PRECONDITIONS).then(() =>\n          addDebugSliceTrack({\n            trace: ctx,\n            data: {\n              sqlSource: BLOCKING_CALLS_DURING_CUJS_QUERY,\n              columns: BLOCKING_CALLS_DURING_CUJS_COLUMNS,\n            },\n            title: 'Blocking calls during CUJs',\n            argColumns: BLOCKING_CALLS_DURING_CUJS_COLUMNS,\n          }),\n        );\n      },\n    });\n  }\n}\n"]}