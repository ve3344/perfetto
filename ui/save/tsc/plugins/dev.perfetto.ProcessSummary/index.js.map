{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.ProcessSummary/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Trace} from '../../public/trace';\nimport {PerfettoPlugin} from '../../public/plugin';\nimport {getThreadOrProcUri} from '../../public/utils';\nimport {NUM, NUM_NULL, STR} from '../../trace_processor/query_result';\nimport {\n  Config as ProcessSchedulingTrackConfig,\n  PROCESS_SCHEDULING_TRACK_KIND,\n  ProcessSchedulingTrack,\n} from './process_scheduling_track';\nimport {\n  Config as ProcessSummaryTrackConfig,\n  PROCESS_SUMMARY_TRACK,\n  ProcessSummaryTrack,\n} from './process_summary_track';\nimport ThreadPlugin from '../dev.perfetto.Thread';\n\n// This plugin is responsible for adding summary tracks for process and thread\n// groups.\nexport default class implements PerfettoPlugin {\n  static readonly id = 'dev.perfetto.ProcessSummary';\n  static readonly dependencies = [ThreadPlugin];\n\n  async onTraceLoad(ctx: Trace): Promise<void> {\n    await this.addProcessTrackGroups(ctx);\n    await this.addKernelThreadSummary(ctx);\n  }\n\n  private async addProcessTrackGroups(ctx: Trace): Promise<void> {\n    const threads = ctx.plugins.getPlugin(ThreadPlugin).getThreadMap();\n\n    const cpuCount = Math.max(...ctx.traceInfo.cpus, -1) + 1;\n\n    const result = await ctx.engine.query(`\n      INCLUDE PERFETTO MODULE android.process_metadata;\n\n      select *\n      from (\n        select\n          _process_available_info_summary.upid,\n          null as utid,\n          process.pid,\n          null as tid,\n          process.name as processName,\n          null as threadName,\n          sum_running_dur > 0 as hasSched,\n          android_process_metadata.debuggable as isDebuggable,\n          ifnull((\n            select group_concat(string_value)\n            from args\n            where\n              process.arg_set_id is not null and\n              arg_set_id = process.arg_set_id and\n              flat_key = 'chrome.process_label'\n          ), '') as chromeProcessLabels\n        from _process_available_info_summary\n        join process using(upid)\n        left join android_process_metadata using(upid)\n      )\n      union all\n      select *\n      from (\n        select\n          null,\n          utid,\n          null as pid,\n          tid,\n          null as processName,\n          thread.name threadName,\n          sum_running_dur > 0 as hasSched,\n          0 as isDebuggable,\n          '' as chromeProcessLabels\n        from _thread_available_info_summary\n        join thread using (utid)\n        where upid is null\n      )\n  `);\n\n    const it = result.iter({\n      upid: NUM_NULL,\n      utid: NUM_NULL,\n      pid: NUM_NULL,\n      tid: NUM_NULL,\n      hasSched: NUM_NULL,\n      isDebuggable: NUM_NULL,\n      chromeProcessLabels: STR,\n    });\n    for (; it.valid(); it.next()) {\n      const upid = it.upid;\n      const utid = it.utid;\n      const pid = it.pid;\n      const tid = it.tid;\n      const hasSched = Boolean(it.hasSched);\n      const isDebuggable = Boolean(it.isDebuggable);\n      const subtitle = it.chromeProcessLabels;\n\n      // Group by upid if present else by utid.\n      const pidForColor = pid ?? tid ?? upid ?? utid ?? 0;\n      const uri = getThreadOrProcUri(upid, utid);\n\n      const chips: string[] = [];\n      isDebuggable && chips.push('debuggable');\n\n      if (hasSched) {\n        const config: ProcessSchedulingTrackConfig = {\n          pidForColor,\n          upid,\n          utid,\n        };\n\n        ctx.tracks.registerTrack({\n          uri,\n          title: `${upid === null ? tid : pid} schedule`,\n          tags: {\n            kind: PROCESS_SCHEDULING_TRACK_KIND,\n          },\n          chips,\n          track: new ProcessSchedulingTrack(ctx, config, cpuCount, threads),\n          subtitle,\n        });\n      } else {\n        const config: ProcessSummaryTrackConfig = {\n          pidForColor,\n          upid,\n          utid,\n        };\n\n        ctx.tracks.registerTrack({\n          uri,\n          title: `${upid === null ? tid : pid} summary`,\n          tags: {\n            kind: PROCESS_SUMMARY_TRACK,\n          },\n          chips,\n          track: new ProcessSummaryTrack(ctx.engine, config),\n          subtitle,\n        });\n      }\n    }\n  }\n\n  private async addKernelThreadSummary(ctx: Trace): Promise<void> {\n    const {engine} = ctx;\n\n    // Identify kernel threads if this is a linux system trace, and sufficient\n    // process information is available. Kernel threads are identified by being\n    // children of kthreadd (always pid 2).\n    // The query will return the kthreadd process row first, which must exist\n    // for any other kthreads to be returned by the query.\n    // TODO(rsavitski): figure out how to handle the idle process (swapper),\n    // which has pid 0 but appears as a distinct process (with its own comm) on\n    // each cpu. It'd make sense to exclude its thread state track, but still\n    // put process-scoped tracks in this group.\n    const result = await engine.query(`\n      select\n        t.utid, p.upid, (case p.pid when 2 then 1 else 0 end) isKthreadd\n      from\n        thread t\n        join process p using (upid)\n        left join process parent on (p.parent_upid = parent.upid)\n        join\n          (select true from metadata m\n             where (m.name = 'system_name' and m.str_value = 'Linux')\n           union\n           select 1 from (select true from sched limit 1))\n      where\n        p.pid = 2 or parent.pid = 2\n      order by isKthreadd desc\n    `);\n\n    const it = result.iter({\n      utid: NUM,\n      upid: NUM,\n    });\n\n    // Not applying kernel thread grouping.\n    if (!it.valid()) {\n      return;\n    }\n\n    const config: ProcessSummaryTrackConfig = {\n      pidForColor: 2,\n      upid: it.upid,\n      utid: it.utid,\n    };\n\n    ctx.tracks.registerTrack({\n      uri: '/kernel',\n      title: `Kernel thread summary`,\n      tags: {\n        kind: PROCESS_SUMMARY_TRACK,\n      },\n      track: new ProcessSummaryTrack(ctx.engine, config),\n    });\n  }\n}\n"]}