{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.AndroidClientServer/index.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;AAEjC,qEAA4D;AAG5D,uEAAwE;AAExE;IACE,MAAM,CAAU,EAAE,GAAG,kCAAkC,CAAC;IACxD,KAAK,CAAC,WAAW,CAAC,GAAU;QAC1B,GAAG,CAAC,QAAQ,CAAC,eAAe,CAAC;YAC3B,EAAE,EAAE,mDAAmD;YACvD,IAAI,EAAE,0CAA0C;YAChD,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,EAAE;gBAC1B,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;oBAC1B,OAAO,GAAG,MAAM,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAAC;oBACzC,IAAI,OAAO,KAAK,IAAI;wBAAE,OAAO;gBAC/B,CAAC;gBACD,MAAM,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;;;;gEAIiC,OAAO;;;;+BAIxC,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAuE7B,CAAC,CAAC;gBACH,MAAM,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;;;yEAG0C,OAAO;;;;;;;;;;;;;;;;;;;;;;0CAsBtC,OAAO;;;;;;;;;;;8CAWH,OAAO;;;;;;;;;;sCAUf,OAAO;;;;;;;;;;;;;;;;;;;;SAoBpC,CAAC,CAAC;gBAEH,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;;oCAEP,OAAO;;;;SAIlC,CAAC,CAAC;gBACH,MAAM,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC;oBAClB,EAAE,EAAE,kBAAG;oBACP,IAAI,EAAE,kBAAG;iBACV,CAAC,CAAC;gBACH,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC;oBAC7B,MAAM,IAAA,iCAAkB,EAAC;wBACvB,KAAK,EAAE,GAAG;wBACV,IAAI,EAAE;4BACJ,SAAS,EAAE;;mDAE0B,OAAO;oCACtB,EAAE,CAAC,EAAE;eAC1B;yBACF;wBACD,KAAK,EAAE,EAAE,CAAC,IAAI;qBACf,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;SACF,CAAC,CAAC;IACL,CAAC;;AAzLH,4BA0LC","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {NUM, STR} from '../../trace_processor/query_result';\nimport {Trace} from '../../public/trace';\nimport {PerfettoPlugin} from '../../public/plugin';\nimport {addDebugSliceTrack} from '../../components/tracks/debug_tracks';\n\nexport default class implements PerfettoPlugin {\n  static readonly id = 'dev.perfetto.AndroidClientServer';\n  async onTraceLoad(ctx: Trace): Promise<void> {\n    ctx.commands.registerCommand({\n      id: 'dev.perfetto.AndroidClientServer#ThreadRuntimeIPC',\n      name: 'Show dependencies in client server model',\n      callback: async (sliceId) => {\n        if (sliceId === undefined) {\n          sliceId = prompt('Enter a slice id', '');\n          if (sliceId === null) return;\n        }\n        await ctx.engine.query(`\n          include perfetto module android.binder;\n          include perfetto module graphs.search;\n\n          create or replace perfetto table __binder_for_slice_${sliceId} as\n          with s as materialized (\n            select slice.id, ts, ts + dur as ts_end, dur, upid\n            from thread_slice slice\n            where slice.id = ${sliceId}\n          ),\n          child_binder_txns_for_slice as materialized (\n            select\n              (select id from s) as source_node_id,\n              binder_txn_id as dest_node_id\n            from descendant_slice((select id from s)) as desc\n            join android_binder_txns txns on desc.id = txns.binder_txn_id\n          ),\n          binder_txns_in_slice_intervals as materialized (\n            select\n              binder_txn_id as source_node_id,\n              binder_reply_id as dest_node_id\n            from android_binder_txns\n            where client_ts > (select ts from s)\n              and client_ts < (select ts + dur from s)\n          ),\n          nested_binder_txns_in_slice_interval as materialized (\n            select\n              parent.binder_reply_id as source_node_id,\n              child.binder_txn_id as dest_node_id\n            from android_binder_txns parent\n            join descendant_slice(parent.binder_reply_id) desc\n            join android_binder_txns child on desc.id = child.binder_txn_id\n            where parent.server_ts > (select ts from s)\n              and parent.server_ts < (select ts + dur from s)\n          ),\n          all_binder_txns_considered as materialized (\n            select * from child_binder_txns_for_slice\n            union\n            select * from binder_txns_in_slice_intervals\n            union\n            select * from nested_binder_txns_in_slice_interval\n          )\n          select\n            dfs.node_id as id,\n            coalesce(client.client_ts, server.client_ts, slice.ts) as ts,\n            coalesce(client.client_dur, server.client_dur, slice.dur) as dur,\n            coalesce(\n              client.aidl_name,\n              server.aidl_name,\n              iif(\n                server.binder_reply_id is not null,\n                coalesce(\n                  server.server_process,\n                  server.server_thread,\n                  'Unknown server'\n                ),\n                slice.name\n              )\n            ) name,\n            coalesce(\n              client.client_utid,\n              server.server_utid,\n              thread_track.utid\n            ) as utid,\n            case\n              when client.binder_txn_id is not null then 'client'\n              when server.binder_reply_id is not null then 'server'\n              else 'slice'\n            end as slice_type,\n            coalesce(client.is_sync, server.is_sync, true) as is_sync\n          from graph_reachable_dfs!(\n            all_binder_txns_considered,\n            (select id as node_id from s)\n          ) dfs\n          join slice on dfs.node_id = slice.id\n          join thread_track on slice.track_id = thread_track.id\n          left join android_binder_txns client on dfs.node_id = client.binder_txn_id\n          left join android_binder_txns server on dfs.node_id = server.binder_reply_id\n          order by ts;\n        `);\n        await ctx.engine.query(`\n          include perfetto module intervals.intersect;\n\n          create or replace perfetto table __enhanced_binder_for_slice_${sliceId} as\n          with foo as (\n            select\n              bfs.id as binder_id,\n              bfs.name as binder_name,\n              ii.ts,\n              ii.dur,\n              tstate.utid,\n              thread.upid,\n              tstate.cpu,\n              tstate.state,\n              tstate.io_wait,\n              (\n                select name\n                from thread_slice tslice\n                where tslice.utid = tstate.utid and tslice.ts < ii.ts\n                order by ts desc\n                limit 1\n              ) as enclosing_slice_name\n            from _interval_intersect!(\n              (\n                select id, ts, dur\n                from __binder_for_slice_${sliceId}\n                where slice_type IN ('slice', 'server')\n                  and is_sync\n                  and dur > 0\n              ),\n              (\n                select id, ts, dur\n                from thread_state tstate\n                where\n                  tstate.utid in (\n                    select distinct utid\n                    from __binder_for_slice_${sliceId}\n                    where\n                      slice_type IN ('slice', 'server')\n                      and is_sync\n                      and dur > 0\n                  )\n                  and dur > 0\n              ),\n              ()\n            ) ii\n            join __binder_for_slice_${sliceId} bfs on ii.id_0 = bfs.id\n            join thread_state tstate on ii.id_1 = tstate.id\n            join thread using (utid)\n            where bfs.utid = tstate.utid\n          )\n          select\n            *,\n            case\n              when state = 'S' and enclosing_slice_name = 'binder transaction' then 'Waiting for server'\n              when state = 'S' and enclosing_slice_name GLOB 'Lock*' then 'Waiting for lock'\n              when state = 'S' and enclosing_slice_name GLOB 'Monitor*' then 'Waiting for contention'\n              when state = 'S' then 'Sleeping'\n              when state = 'R' then 'Waiting for CPU'\n              when state = 'Running' then 'Running on CPU ' || foo.cpu\n              when state GLOB 'R*' then 'Runnable'\n              when state GLOB 'D*' and io_wait then 'IO'\n              when state GLOB 'D*' and not io_wait then 'Unint-sleep'\n            end as name\n          from foo\n          order by binder_id;\n        `);\n\n        const res = await ctx.engine.query(`\n          select id, name\n          from __binder_for_slice_${sliceId} bfs\n          where slice_type IN ('slice', 'server')\n            and dur > 0\n          order by ts\n        `);\n        const it = res.iter({\n          id: NUM,\n          name: STR,\n        });\n        for (; it.valid(); it.next()) {\n          await addDebugSliceTrack({\n            trace: ctx,\n            data: {\n              sqlSource: `\n                SELECT ts, dur, name\n                FROM __enhanced_binder_for_slice_${sliceId}\n                WHERE binder_id = ${it.id}\n              `,\n            },\n            title: it.name,\n          });\n        }\n      },\n    });\n  }\n}\n"]}