{"version":3,"file":"thread_aggregator.js","sourceRoot":"","sources":["../../../../src/plugins/org.kernel.Wattson/thread_aggregator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {exists} from '../../base/utils';\nimport {ColumnDef, Sorting} from '../../public/aggregation';\nimport {AreaSelection} from '../../public/selection';\nimport {Engine} from '../../trace_processor/engine';\nimport {CPU_SLICE_TRACK_KIND} from '../../public/track_kinds';\nimport {AreaSelectionAggregator} from '../../public/selection';\n\nexport class WattsonThreadSelectionAggregator\n  implements AreaSelectionAggregator\n{\n  readonly id = 'wattson_thread_aggregation';\n\n  async createAggregateView(engine: Engine, area: AreaSelection) {\n    await engine.query(`drop view if exists ${this.id};`);\n\n    const selectedCpus: number[] = [];\n    for (const trackInfo of area.tracks) {\n      if (trackInfo?.tags?.kind === CPU_SLICE_TRACK_KIND) {\n        exists(trackInfo.tags.cpu) && selectedCpus.push(trackInfo.tags.cpu);\n      }\n    }\n    if (selectedCpus.length === 0) return false;\n\n    const duration = area.end - area.start;\n    const cpusCsv = `(` + selectedCpus.join() + `)`;\n    engine.query(`\n      INCLUDE PERFETTO MODULE viz.summary.threads_w_processes;\n      INCLUDE PERFETTO MODULE wattson.curves.idle_attribution;\n      INCLUDE PERFETTO MODULE wattson.curves.estimates;\n\n      CREATE OR REPLACE PERFETTO TABLE _ui_selection_window AS\n      SELECT\n        ${area.start} as ts,\n        ${duration} as dur;\n\n      -- Processes filtered by CPU within the UI defined time window\n      DROP TABLE IF EXISTS _windowed_summary;\n      CREATE VIRTUAL TABLE _windowed_summary\n      USING\n        SPAN_JOIN(_ui_selection_window, _sched_w_thread_process_package_summary);\n\n      -- Only get idle attribution in user defined window and filter by selected\n      -- CPUs and GROUP BY thread\n      CREATE OR REPLACE PERFETTO TABLE _per_thread_idle_attribution AS\n      SELECT\n        ROUND(SUM(idle_cost_mws), 2) as idle_cost_mws,\n        utid\n      FROM _filter_idle_attribution(${area.start}, ${duration})\n      WHERE cpu in ${cpusCsv}\n      GROUP BY utid;\n    `);\n    this.runEstimateThreadsQuery(engine, selectedCpus, duration);\n\n    return true;\n  }\n\n  // This function returns a query that gets the average and estimate from\n  // Wattson for the selection in the UI window based on thread. The grouping by\n  // thread needs to 'remove' 2 dimensions; the threads need to be grouped over\n  // time and the threads need to be grouped over CPUs.\n  // 1. Window and associate thread with proper Wattson estimate slice\n  // 2. Group all threads over time on a per CPU basis\n  // 3. Group all threads over all CPUs\n  runEstimateThreadsQuery(\n    engine: Engine,\n    selectedCpu: number[],\n    duration: bigint,\n  ) {\n    // Estimate and total per UTID per CPU\n    selectedCpu.forEach((cpu) => {\n      engine.query(`\n        -- Packages filtered by CPU\n        CREATE OR REPLACE PERFETTO VIEW _windowed_summary_per_cpu${cpu} AS\n        SELECT *\n        FROM _windowed_summary WHERE cpu = ${cpu};\n\n        -- CPU specific track with slices for curves\n        CREATE OR REPLACE PERFETTO VIEW _per_cpu${cpu}_curve AS\n        SELECT ts, dur, cpu${cpu}_curve\n        FROM _system_state_curves;\n\n        -- Filter out track when threads are available\n        DROP TABLE IF EXISTS _windowed_thread_curve${cpu};\n        CREATE VIRTUAL TABLE _windowed_thread_curve${cpu}\n        USING\n          SPAN_JOIN(_per_cpu${cpu}_curve, _windowed_summary_per_cpu${cpu});\n\n        -- Total estimate per UTID per CPU\n        CREATE OR REPLACE PERFETTO VIEW _total_per_cpu${cpu} AS\n        SELECT\n          SUM(cpu${cpu}_curve * dur) as total_pws,\n          SUM(dur) as dur,\n          tid,\n          pid,\n          uid,\n          utid,\n          upid,\n          thread_name,\n          process_name,\n          package_name\n        FROM _windowed_thread_curve${cpu}\n        GROUP BY utid;\n      `);\n    });\n\n    // Estimate and total per UTID, removing CPU dimension\n    let query = `CREATE OR REPLACE PERFETTO TABLE _unioned_per_cpu_total AS `;\n    selectedCpu.forEach((cpu, i) => {\n      query += i != 0 ? `UNION ALL\\n` : ``;\n      query += `SELECT * from _total_per_cpu${cpu}\\n`;\n    });\n    query += `\n      ;\n\n      -- Grouped again by UTID, but this time to make it CPU agnostic\n      CREATE VIEW ${this.id} AS\n      SELECT\n        ROUND(SUM(total_pws) / ${duration}, 2) as active_mw,\n        ROUND(SUM(total_pws) / 1000000000, 2) as active_mws,\n        COALESCE(idle_cost_mws, 0) as idle_cost_mws,\n        ROUND(\n          COALESCE(idle_cost_mws, 0) + SUM(total_pws) / 1000000000,\n          2\n        ) as total_mws,\n        thread_name,\n        utid,\n        tid,\n        pid\n      FROM _unioned_per_cpu_total\n      LEFT JOIN _per_thread_idle_attribution USING (utid)\n      GROUP BY utid;\n    `;\n\n    engine.query(query);\n\n    return;\n  }\n\n  getColumnDefinitions(): ColumnDef[] {\n    return [\n      {\n        title: 'Thread Name',\n        kind: 'STRING',\n        columnConstructor: Uint16Array,\n        columnId: 'thread_name',\n      },\n      {\n        title: 'TID',\n        kind: 'NUMBER',\n        columnConstructor: Uint16Array,\n        columnId: 'tid',\n      },\n      {\n        title: 'PID',\n        kind: 'NUMBER',\n        columnConstructor: Uint16Array,\n        columnId: 'pid',\n      },\n      {\n        title: 'Active power (estimated mW)',\n        kind: 'NUMBER',\n        columnConstructor: Float64Array,\n        columnId: 'active_mw',\n        sum: true,\n      },\n      {\n        title: 'Active energy (estimated mWs)',\n        kind: 'NUMBER',\n        columnConstructor: Float64Array,\n        columnId: 'active_mws',\n        sum: true,\n      },\n      {\n        title: 'Idle transitions overhead (estimated mWs)',\n        kind: 'NUMBER',\n        columnConstructor: Float64Array,\n        columnId: 'idle_cost_mws',\n        sum: true,\n      },\n      {\n        title: 'Total energy (estimated mWs)',\n        kind: 'NUMBER',\n        columnConstructor: Float64Array,\n        columnId: 'total_mws',\n        sum: true,\n      },\n    ];\n  }\n\n  async getExtra() {}\n\n  getTabName() {\n    return 'Wattson by thread';\n  }\n\n  getDefaultSorting(): Sorting {\n    return {column: 'active_mws', direction: 'DESC'};\n  }\n}\n"]}