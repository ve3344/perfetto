{"version":3,"file":"scroll_timeline_track.js","sourceRoot":"","sources":["../../../../src/plugins/org.chromium.ChromeScrollJank/scroll_timeline_track.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {createPerfettoTable} from '../../trace_processor/sql_utils';\nimport {generateSqlWithInternalLayout} from '../../components/sql_utils/layout';\nimport {\n  NAMED_ROW,\n  NamedRow,\n  NamedSliceTrack,\n} from '../../components/tracks/named_slice_track';\nimport {Slice} from '../../public/track';\nimport {sqlNameSafe} from '../../base/string_utils';\nimport {SqlTableSliceTrackDetailsPanel} from '../../components/tracks/sql_table_slice_track_details_tab';\nimport {Trace} from '../../public/trace';\nimport {TrackEventDetailsPanel} from '../../public/details_panel';\nimport {TrackEventSelection} from '../../public/selection';\n\ninterface StepTemplate {\n  step_name: string;\n  ts_column_name: string;\n  dur_column_name: string;\n}\n\n// TODO: b/383547343 - Migrate STEP_TEMPLATES to a Chrome tracing stdlib table\n// once it's stable.\nconst STEP_TEMPLATES: readonly StepTemplate[] = [\n  {\n    step_name: 'GenerationToBrowserMain',\n    ts_column_name: 'generation_ts',\n    dur_column_name: 'generation_to_browser_main_dur',\n  },\n  {\n    step_name: 'TouchMoveProcessing',\n    ts_column_name: 'touch_move_received_ts',\n    dur_column_name: 'touch_move_processing_dur',\n  },\n  {\n    step_name: 'ScrollUpdateProcessing',\n    ts_column_name: 'scroll_update_created_ts',\n    dur_column_name: 'scroll_update_processing_dur',\n  },\n  {\n    step_name: 'BrowserMainToRendererCompositor',\n    ts_column_name: 'scroll_update_created_end_ts',\n    dur_column_name: 'browser_to_compositor_delay_dur',\n  },\n  {\n    step_name: 'RendererCompositorDispatch',\n    ts_column_name: 'compositor_dispatch_ts',\n    dur_column_name: 'compositor_dispatch_dur',\n  },\n  {\n    step_name: 'RendererCompositorDispatchToOnBeginFrame',\n    ts_column_name: 'compositor_dispatch_end_ts',\n    dur_column_name: 'compositor_dispatch_to_on_begin_frame_delay_dur',\n  },\n  {\n    step_name: 'RendererCompositorBeginFrame',\n    ts_column_name: 'compositor_on_begin_frame_ts',\n    dur_column_name: 'compositor_on_begin_frame_dur',\n  },\n  {\n    step_name: 'RendererCompositorBeginToGenerateFrame',\n    ts_column_name: 'compositor_on_begin_frame_end_ts',\n    dur_column_name: 'compositor_on_begin_frame_to_generation_delay_dur',\n  },\n  {\n    step_name: 'RendererCompositorGenerateToSubmitFrame',\n    ts_column_name: 'compositor_generate_compositor_frame_ts',\n    dur_column_name: 'compositor_generate_frame_to_submit_frame_dur',\n  },\n  {\n    step_name: 'RendererCompositorSubmitFrame',\n    ts_column_name: 'compositor_submit_compositor_frame_ts',\n    dur_column_name: 'compositor_submit_frame_dur',\n  },\n  {\n    step_name: 'RendererCompositorToViz',\n    ts_column_name: 'compositor_submit_compositor_frame_end_ts',\n    dur_column_name: 'compositor_to_viz_delay_dur',\n  },\n  {\n    step_name: 'VizReceiveFrame',\n    ts_column_name: 'viz_receive_compositor_frame_ts',\n    dur_column_name: 'viz_receive_compositor_frame_dur',\n  },\n  {\n    step_name: 'VizReceiveToDrawFrame',\n    ts_column_name: 'viz_receive_compositor_frame_end_ts',\n    dur_column_name: 'viz_wait_for_draw_dur',\n  },\n  {\n    step_name: 'VizDrawToSwapFrame',\n    ts_column_name: 'viz_draw_and_swap_ts',\n    dur_column_name: 'viz_draw_and_swap_dur',\n  },\n  {\n    step_name: 'VizToGpu',\n    ts_column_name: 'viz_send_buffer_swap_end_ts',\n    dur_column_name: 'viz_to_gpu_delay_dur',\n  },\n  {\n    step_name: 'VizSwapBuffers',\n    ts_column_name: 'viz_swap_buffers_ts',\n    dur_column_name: 'viz_swap_buffers_dur',\n  },\n  {\n    step_name: 'VizSwapBuffersToLatch',\n    ts_column_name: 'viz_swap_buffers_end_ts',\n    dur_column_name: 'viz_swap_buffers_to_latch_dur',\n  },\n  {\n    step_name: 'VizLatchToSwapEnd',\n    ts_column_name: 'latch_timestamp',\n    dur_column_name: 'viz_latch_to_swap_end_dur',\n  },\n  {\n    step_name: 'VizSwapEndToPresentation',\n    ts_column_name: 'swap_end_timestamp',\n    dur_column_name: 'swap_end_to_presentation_dur',\n  },\n  {\n    // An artificial step to ensure that presentation_timestamp is included in\n    // the calculation of scroll_update_bounds. It's filtered out in\n    // unordered_slices due to NULL duration.\n    step_name: '',\n    ts_column_name: 'presentation_timestamp',\n    dur_column_name: 'NULL',\n  },\n];\n\nexport class ScrollTimelineTrack extends NamedSliceTrack<Slice, NamedRow> {\n  private readonly tableName;\n\n  constructor(trace: Trace, uri: string) {\n    super(trace, uri);\n    this.tableName = `scrolltimelinetrack_${sqlNameSafe(uri)}`;\n  }\n  override async onInit(): Promise<AsyncDisposable> {\n    await super.onInit();\n    await this.engine.query(`INCLUDE PERFETTO MODULE chrome.chrome_scrolls;`);\n    // TODO: b/383549233 - Set ts+dur of each scroll update directly based on\n    // our knowledge of the scrolling pipeline (as opposed to aggregating over\n    // scroll_steps).\n    return await createPerfettoTable(\n      this.engine,\n      this.tableName,\n      `WITH\n        -- Unpivot all ts+dur columns into rows. Each row corresponds to a step\n        -- of a particular scroll update. Some of the rows might have null\n        -- ts/dur values, which will be filtered out in unordered_slices.\n        -- |scroll_steps| = |chrome_scroll_update_info| * |STEP_TEMPLATES|\n        scroll_steps AS (${STEP_TEMPLATES.map(\n          (step) => `\n          SELECT\n            id AS scroll_id,\n            ${step.ts_column_name} AS ts,\n            ${step.dur_column_name} AS dur,\n            '${step.step_name}' AS name\n          FROM chrome_scroll_update_info`,\n        ).join(' UNION ALL ')}),\n        -- For each scroll update, find its ts+dur by aggregating over all steps\n        -- within the scroll update. We're basically trying to find MIN(COL1_ts,\n        -- COL2_ts, ..., COLn_ts) and MAX(COL1_ts, COL2_ts, ..., COLn_ts) from\n        -- all the various ts columns in chrome_scroll_update_info. The\n        -- difficulty is that some of those columns might be null, which is\n        -- better handled by the aggregate MIN/MAX functions (which ignore null\n        -- values) than the scalar MIN/MAX functions (which return null if any\n        -- argument is null). That's why we do it in such a roundabout way by\n        -- joining the top-level table with the individual steps.\n        scroll_update_bounds AS (\n          SELECT\n            scroll_update.id AS scroll_id,\n            MIN(scroll_steps.ts) AS ts,\n            MAX(scroll_steps.ts) - MIN(scroll_steps.ts) AS dur\n          FROM\n            chrome_scroll_update_info AS scroll_update\n            JOIN scroll_steps ON scroll_steps.scroll_id = scroll_update.id\n          GROUP BY scroll_update.id\n        ),\n        -- Now that we know the ts+dur of all scroll updates, we can lay them\n        -- out efficiently (i.e. assign depths to them to avoid overlaps).\n        scroll_update_layouts AS (\n          ${generateSqlWithInternalLayout({\n            columns: ['scroll_id', 'ts', 'dur'],\n            sourceTable: 'scroll_update_bounds',\n            ts: 'ts',\n            dur: 'dur',\n          })}\n        ),\n        -- We interleave the top-level scroll update slices (at even depths) and\n        -- their constituent step slices (at odd depths).\n        unordered_slices AS (\n          SELECT\n            ts,\n            dur,\n            2 * depth AS depth,\n            'Scroll Update' AS name\n          FROM scroll_update_layouts\n          UNION ALL\n          SELECT\n            scroll_steps.ts,\n            MAX(scroll_steps.dur, 0) AS dur,\n            2 * scroll_update_layouts.depth + 1 AS depth,\n            scroll_steps.name\n          FROM scroll_steps\n          JOIN scroll_update_layouts USING(scroll_id)\n          WHERE scroll_steps.ts IS NOT NULL AND scroll_steps.dur IS NOT NULL\n        )\n      -- Finally, we sort all slices chronologically and assign them\n      -- monotonically increasing IDs. Note that we cannot reuse\n      -- chrome_scroll_update_info.id (not even for the top-level scroll update\n      -- slices) because Perfetto slice IDs must be 32-bit unsigned integers.\n      SELECT\n        ROW_NUMBER() OVER (ORDER BY ts ASC) AS id,\n        *\n      FROM unordered_slices\n      ORDER BY ts ASC`,\n    );\n  }\n\n  override getSqlSource(): string {\n    return `SELECT * FROM ${this.tableName}`;\n  }\n\n  override getRowSpec(): NamedRow {\n    return NAMED_ROW;\n  }\n\n  override rowToSlice(row: NamedRow): Slice {\n    return super.rowToSliceBase(row);\n  }\n\n  override detailsPanel(sel: TrackEventSelection): TrackEventDetailsPanel {\n    return new SqlTableSliceTrackDetailsPanel(\n      this.trace,\n      this.tableName,\n      sel.eventId,\n    );\n  }\n}\n"]}