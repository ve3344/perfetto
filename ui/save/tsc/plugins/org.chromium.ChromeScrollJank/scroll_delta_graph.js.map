{"version":3,"file":"scroll_delta_graph.js","sourceRoot":"","sources":["../../../../src/plugins/org.chromium.ChromeScrollJank/scroll_delta_graph.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\nimport {duration, Time, time} from '../../base/time';\nimport {Engine} from '../../trace_processor/engine';\nimport {LONG, NUM} from '../../trace_processor/query_result';\nimport {VegaView} from '../../components/widgets/vega_view';\n\nconst INPUT_CATEGORY = 'Input';\nconst PRESENTED_CATEGORY = 'Presented';\nconst PRESENTED_JANKY_CATEGORY = 'Presented with Predictor Jank';\n\ninterface ScrollDeltaPlotDatum {\n  // What type of data this is - input scroll or presented scroll. This is used\n  // to denote the color of the data point.\n  category: string;\n  offset: number;\n  scrollUpdateId: number;\n  ts: number;\n  delta: number;\n  predictorJank: string;\n}\n\nexport interface ScrollDeltaDetails {\n  ts: time;\n  scrollUpdateId: number;\n  scrollDelta: number;\n  scrollOffset: number;\n  predictorJank: number;\n}\n\nexport interface JankIntervalPlotDetails {\n  start_ts: number;\n  end_ts: number;\n}\n\nexport async function getInputScrollDeltas(\n  engine: Engine,\n  scrollId: number,\n): Promise<ScrollDeltaDetails[]> {\n  const queryResult = await engine.query(`\n    INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_offsets;\n\n    SELECT\n      ts,\n      IFNULL(scroll_update_id, 0) AS scrollUpdateId,\n      delta_y AS deltaY,\n      relative_offset_y AS offsetY\n    FROM chrome_scroll_input_offsets\n    WHERE scroll_id = ${scrollId};\n  `);\n\n  const it = queryResult.iter({\n    ts: LONG,\n    scrollUpdateId: NUM,\n    deltaY: NUM,\n    offsetY: NUM,\n  });\n  const deltas: ScrollDeltaDetails[] = [];\n\n  for (; it.valid(); it.next()) {\n    deltas.push({\n      ts: Time.fromRaw(it.ts),\n      scrollUpdateId: it.scrollUpdateId,\n      scrollOffset: it.offsetY,\n      scrollDelta: it.deltaY,\n      predictorJank: 0,\n    });\n  }\n\n  return deltas;\n}\n\nexport async function getPresentedScrollDeltas(\n  engine: Engine,\n  scrollId: number,\n): Promise<ScrollDeltaDetails[]> {\n  const queryResult = await engine.query(`\n    INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_offsets;\n\n    SELECT\n      ts,\n      IFNULL(scroll_update_id, 0) AS scrollUpdateId,\n      delta_y AS deltaY,\n      relative_offset_y AS offsetY\n    FROM chrome_presented_scroll_offsets\n    WHERE scroll_id = ${scrollId}\n      AND delta_y IS NOT NULL;\n  `);\n\n  const it = queryResult.iter({\n    ts: LONG,\n    scrollUpdateId: NUM,\n    deltaY: NUM,\n    offsetY: NUM,\n  });\n  const deltas: ScrollDeltaDetails[] = [];\n  let offset = 0;\n\n  for (; it.valid(); it.next()) {\n    offset = it.offsetY;\n\n    deltas.push({\n      ts: Time.fromRaw(it.ts),\n      scrollUpdateId: it.scrollUpdateId,\n      scrollOffset: offset,\n      scrollDelta: it.deltaY,\n      predictorJank: 0,\n    });\n  }\n\n  return deltas;\n}\n\nexport async function getPredictorJankDeltas(\n  engine: Engine,\n  scrollId: number,\n): Promise<ScrollDeltaDetails[]> {\n  const queryResult = await engine.query(`\n    INCLUDE PERFETTO MODULE chrome.scroll_jank.predictor_error;\n\n    SELECT\n      present_ts AS ts,\n      IFNULL(scroll_update_id, 0) AS scrollUpdateId,\n      delta_y AS deltaY,\n      relative_offset_y AS offsetY,\n      predictor_jank AS predictorJank\n    FROM chrome_predictor_error\n    WHERE scroll_id = ${scrollId}\n      AND predictor_jank != 0 AND predictor_jank IS NOT NULL;\n  `);\n\n  const it = queryResult.iter({\n    ts: LONG,\n    scrollUpdateId: NUM,\n    deltaY: NUM,\n    offsetY: NUM,\n    predictorJank: NUM,\n  });\n  const deltas: ScrollDeltaDetails[] = [];\n  let offset = 0;\n\n  for (; it.valid(); it.next()) {\n    offset = it.offsetY;\n\n    deltas.push({\n      ts: Time.fromRaw(it.ts),\n      scrollUpdateId: it.scrollUpdateId,\n      scrollOffset: offset,\n      scrollDelta: it.deltaY,\n      predictorJank: it.predictorJank,\n    });\n  }\n\n  return deltas;\n}\n\nexport async function getJankIntervals(\n  engine: Engine,\n  startTs: time,\n  dur: duration,\n): Promise<JankIntervalPlotDetails[]> {\n  const queryResult = await engine.query(`\n    INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_intervals;\n\n    SELECT\n      ts,\n      dur\n    FROM chrome_janky_frame_presentation_intervals\n    WHERE ts >= ${startTs} AND ts <= ${startTs + dur};\n  `);\n\n  const it = queryResult.iter({\n    ts: LONG,\n    dur: LONG,\n  });\n\n  const details: JankIntervalPlotDetails[] = [];\n\n  for (; it.valid(); it.next()) {\n    details.push({\n      start_ts: Number(it.ts),\n      end_ts: Number(it.ts + it.dur),\n    });\n  }\n\n  return details;\n}\n\n// TODO(b/352038635): Show the error margin on the graph - what the pixel offset\n// should have been if there were no predictor jank.\nexport function buildScrollOffsetsGraph(\n  inputDeltas: ScrollDeltaDetails[],\n  presentedDeltas: ScrollDeltaDetails[],\n  predictorDeltas: ScrollDeltaDetails[],\n  jankIntervals: JankIntervalPlotDetails[],\n): m.Child {\n  const inputData = buildOffsetData(inputDeltas, INPUT_CATEGORY);\n  // Filter out the predictor deltas from the presented deltas, as these will be\n  // rendered in a new layer, with new tooltip/color/etc.\n  const filteredPresentedDeltas = presentedDeltas.filter((item) => {\n    for (let i = 0; i < predictorDeltas.length; i++) {\n      const predictorDelta: ScrollDeltaDetails = predictorDeltas[i];\n      if (\n        predictorDelta.ts == item.ts &&\n        predictorDelta.scrollUpdateId == item.scrollUpdateId\n      ) {\n        return false;\n      }\n    }\n    return true;\n  });\n\n  const presentedData = buildOffsetData(\n    filteredPresentedDeltas,\n    PRESENTED_CATEGORY,\n  );\n  const predictorData = buildOffsetData(\n    predictorDeltas,\n    PRESENTED_JANKY_CATEGORY,\n  );\n  const jankData = buildJankLayerData(jankIntervals);\n\n  return m(VegaView, {\n    spec: `\n{\n  \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.json\",\n  \"description\": \"Scatter plot showcasing the pixel offset deltas between input frames and presented frames.\",\n  \"width\": \"container\",\n  \"height\": 200,\n  \"padding\": 5,\n\n  \"data\": {\n    \"name\": \"table\"\n  },\n\n  \"layer\": [\n    {\n      \"mark\": \"rect\",\n      \"data\": {\n        \"values\": [\n          ${jankData}\n        ]\n      },\n      \"encoding\": {\n        \"x\": {\n          \"field\": \"start\",\n          \"type\": \"quantitative\"\n        },\n        \"x2\": {\n          \"field\": \"end\",\n          \"type\": \"quantitative\"\n        },\n        \"color\": {\n          \"value\": \"#D3D3D3\"\n        }\n      }\n    },\n    {\n      \"mark\": {\n        \"type\": \"point\",\n        \"filled\": true\n      },\n\n      \"encoding\": {\n        \"x\": {\n          \"field\": \"ts\",\n          \"type\": \"quantitative\",\n          \"title\": \"Raw Timestamp\",\n          \"axis\" : {\n            \"labels\": true\n          },\n          \"scale\": {\"zero\":false}\n        },\n        \"y\": {\n          \"field\": \"offset\",\n          \"type\": \"quantitative\",\n          \"title\": \"Offset (pixels)\",\n          \"scale\": {\"zero\":false}\n        },\n        \"color\": {\n          \"field\": \"category\",\n          \"type\": \"nominal\",\n          \"scale\": {\n            \"domain\": [\n              \"${INPUT_CATEGORY}\",\n              \"${PRESENTED_CATEGORY}\",\n              \"${PRESENTED_JANKY_CATEGORY}\"\n            ],\n            \"range\": [\"blue\", \"red\", \"orange\"]\n          },\n          \"legend\": {\n            \"title\":null\n          }\n        },\n        \"tooltip\": [\n          {\n            \"field\": \"delta\",\n            \"type\": \"quantitative\",\n            \"title\": \"Delta\",\n            \"format\": \".2f\"\n          },\n          {\n            \"field\": \"scrollUpdateId\",\n            \"type\": \"quantititive\",\n            \"title\": \"Trace Id\"\n          },\n          {\n            \"field\": \"predictorJank\",\n            \"type\": \"nominal\",\n            \"title\": \"Predictor Jank\"\n          }\n        ]\n      }\n    }\n  ]\n}\n`,\n    data: {table: inputData.concat(presentedData).concat(predictorData)},\n  });\n}\n\nfunction buildOffsetData(\n  deltas: ScrollDeltaDetails[],\n  category: string,\n): ScrollDeltaPlotDatum[] {\n  const plotData: ScrollDeltaPlotDatum[] = [];\n  for (const delta of deltas) {\n    let predictorJank = 'N/A';\n    if (delta.predictorJank > 0) {\n      predictorJank = parseFloat(delta.predictorJank.toString()).toFixed(2);\n      predictorJank +=\n        \" (times delta compared to the next/previous frame's delta)\";\n    }\n    plotData.push({\n      category: category,\n      ts: Number(delta.ts) / 10e8,\n      scrollUpdateId: delta.scrollUpdateId,\n      offset: delta.scrollOffset,\n      delta: delta.scrollDelta,\n      predictorJank: predictorJank,\n    });\n  }\n\n  return plotData;\n}\n\nfunction buildJankLayerData(janks: JankIntervalPlotDetails[]): string {\n  let dataJsonString = '';\n  for (let i = 0; i < janks.length; i++) {\n    if (i != 0) {\n      dataJsonString += ',';\n    }\n    const jank = janks[i];\n    dataJsonString += `\n    {\n      \"start\": ${jank.start_ts / 10e8},\n      \"end\": ${jank.end_ts / 10e8}\n    }\n    `;\n  }\n  return dataJsonString;\n}\n"]}