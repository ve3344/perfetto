{"version":3,"file":"adb_base_controller.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.RecordTrace/adb_base_controller.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2019 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {exists} from '../../base/utils';\nimport {RecordingState, RecordingTarget, isAdbTarget} from './state';\nimport {\n  extractDurationFromTraceConfig,\n  extractTraceConfig,\n} from './trace_config_utils';\nimport {Adb} from './adb_interfaces';\nimport {ReadBuffersResponse} from './consumer_port_types';\nimport {Consumer, RpcConsumerPort} from './record_controller_interfaces';\n\nexport enum AdbConnectionState {\n  READY_TO_CONNECT,\n  AUTH_IN_PROGRESS,\n  CONNECTED,\n  CLOSED,\n}\n\ninterface Command {\n  method: string;\n  params: Uint8Array;\n}\n\nexport abstract class AdbBaseConsumerPort extends RpcConsumerPort {\n  // Contains the commands sent while the authentication is in progress. They\n  // will all be executed afterwards. If the device disconnects, they are\n  // removed.\n  private commandQueue: Command[] = [];\n\n  protected adb: Adb;\n  protected state = AdbConnectionState.READY_TO_CONNECT;\n  protected device?: USBDevice;\n  protected recState: RecordingState;\n\n  protected constructor(\n    adb: Adb,\n    consumer: Consumer,\n    recState: RecordingState,\n  ) {\n    super(consumer);\n    this.adb = adb;\n    this.recState = recState;\n  }\n\n  async handleCommand(method: string, params: Uint8Array) {\n    try {\n      if (method === 'FreeBuffers') {\n        // When we finish tracing, we disconnect the adb device interface.\n        // Otherwise, we will keep holding the device interface and won't allow\n        // adb to access it. https://wicg.github.io/webusb/#abusing-a-device\n        // \"Lastly, since USB devices are unable to distinguish requests from\n        // multiple sources, operating systems only allow a USB interface to\n        // have a single owning user-space or kernel-space driver.\"\n        this.state = AdbConnectionState.CLOSED;\n        await this.adb.disconnect();\n      } else if (method === 'EnableTracing') {\n        this.state = AdbConnectionState.READY_TO_CONNECT;\n      }\n\n      if (this.state === AdbConnectionState.CLOSED) return;\n\n      this.commandQueue.push({method, params});\n\n      if (\n        this.state === AdbConnectionState.READY_TO_CONNECT ||\n        this.deviceDisconnected()\n      ) {\n        this.state = AdbConnectionState.AUTH_IN_PROGRESS;\n        this.device = await this.findDevice(this.recState.recordingTarget);\n        if (!this.device) {\n          this.state = AdbConnectionState.READY_TO_CONNECT;\n          const target = this.recState.recordingTarget;\n          throw Error(\n            `Device with serial ${\n              isAdbTarget(target) ? target.serial : 'n/a'\n            } not found.`,\n          );\n        }\n\n        this.sendStatus(`Please allow USB debugging on device.\n          If you press cancel, reload the page.`);\n\n        await this.adb.connect(this.device);\n\n        // During the authentication the device may have been disconnected.\n        if (!this.recState.recordingInProgress || this.deviceDisconnected()) {\n          throw Error('Recording not in progress after adb authorization.');\n        }\n\n        this.state = AdbConnectionState.CONNECTED;\n        this.sendStatus('Device connected.');\n      }\n\n      if (this.state === AdbConnectionState.AUTH_IN_PROGRESS) return;\n\n      console.assert(this.state === AdbConnectionState.CONNECTED);\n\n      for (const cmd of this.commandQueue) this.invoke(cmd.method, cmd.params);\n\n      this.commandQueue = [];\n    } catch (e) {\n      this.commandQueue = [];\n      this.state = AdbConnectionState.READY_TO_CONNECT;\n      this.sendErrorMessage(e.message);\n    }\n  }\n\n  private deviceDisconnected() {\n    return !this.device || !this.device.opened;\n  }\n\n  setDurationStatus(enableTracingProto: Uint8Array) {\n    const traceConfigProto = extractTraceConfig(enableTracingProto);\n    if (!traceConfigProto) return;\n    const duration = extractDurationFromTraceConfig(traceConfigProto);\n    this.sendStatus(\n      `Recording in progress${\n        exists(duration) ? ' for ' + duration.toString() + ' ms' : ''\n      }...`,\n    );\n  }\n\n  abstract invoke(method: string, argsProto: Uint8Array): void;\n\n  generateChunkReadResponse(\n    data: Uint8Array,\n    last = false,\n  ): ReadBuffersResponse {\n    return {\n      type: 'ReadBuffersResponse',\n      slices: [{data, lastSliceForPacket: last}],\n    };\n  }\n\n  async findDevice(\n    connectedDevice: RecordingTarget,\n  ): Promise<USBDevice | undefined> {\n    if (!('usb' in navigator)) return undefined;\n    if (!isAdbTarget(connectedDevice)) return undefined;\n    const devices = await navigator.usb.getDevices();\n    return devices.find((d) => d.serialNumber === connectedDevice.serial);\n  }\n}\n"]}