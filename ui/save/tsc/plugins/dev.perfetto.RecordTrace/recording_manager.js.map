{"version":3,"file":"recording_manager.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.RecordTrace/recording_manager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {createEmptyState} from './empty_state';\nimport {\n  AdbRecordingTarget,\n  LoadedConfig,\n  RecordingState,\n  RecordingTarget,\n  getDefaultRecordingTargets,\n  isAdbTarget,\n} from './state';\nimport {AdbOverWebUsb} from './adb';\nimport {isGetCategoriesResponse} from './chrome_proxy_record_controller';\nimport {RecordConfig, createEmptyRecordConfig} from './record_config_types';\nimport {RecordController} from './record_controller';\nimport {scheduleFullRedraw} from '../../widgets/raf';\nimport {App} from '../../public/app';\nimport {targetFactoryRegistry} from './recordingV2/target_factory_registry';\nimport {AndroidWebsocketTargetFactory} from './recordingV2/target_factories/android_websocket_target_factory';\nimport {AndroidWebusbTargetFactory} from './recordingV2/target_factories/android_webusb_target_factory';\nimport {exists} from '../../base/utils';\n\nconst EXTENSION_ID = 'lfmkphfpdbjijhpomgecfikhfohaoine';\n\n// TODO(primiano): this class and RecordController should be merged. I'm keeping\n// them separate for now to reduce scope of refactorings.\nexport class RecordingManager {\n  readonly app: App;\n  private _state: RecordingState = createEmptyState();\n  private recCtl: RecordController;\n\n  constructor(app: App, useRecordingV2: boolean) {\n    this.app = app;\n    const extensionLocalChannel = new MessageChannel();\n    this.recCtl = new RecordController(app, this, extensionLocalChannel.port1);\n    this.setupExtentionPort(extensionLocalChannel);\n\n    if (useRecordingV2) {\n      targetFactoryRegistry.register(new AndroidWebsocketTargetFactory());\n      if (exists(navigator.usb)) {\n        targetFactoryRegistry.register(\n          new AndroidWebusbTargetFactory(navigator.usb),\n        );\n      }\n    } else {\n      this.updateAvailableAdbDevices();\n      try {\n        navigator.usb.addEventListener('connect', () =>\n          this.updateAvailableAdbDevices(),\n        );\n        navigator.usb.addEventListener('disconnect', () =>\n          this.updateAvailableAdbDevices(),\n        );\n      } catch (e) {\n        console.error('WebUSB API not supported');\n      }\n    }\n  }\n\n  clearRecordConfig(): void {\n    this._state.recordConfig = createEmptyRecordConfig();\n    this._state.lastLoadedConfig = {type: 'NONE'};\n    this.recCtl.refreshOnStateChange();\n  }\n\n  setRecordConfig(config: RecordConfig, configType?: LoadedConfig): void {\n    this._state.recordConfig = config;\n    this._state.lastLoadedConfig = configType || {type: 'NONE'};\n    this.recCtl.refreshOnStateChange();\n  }\n\n  startRecording(): void {\n    this._state.recordingInProgress = true;\n    this._state.lastRecordingError = undefined;\n    this._state.recordingCancelled = false;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  stopRecording(): void {\n    this._state.recordingInProgress = false;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  cancelRecording(): void {\n    this._state.recordingInProgress = false;\n    this._state.recordingCancelled = true;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  setRecordingTarget(target: RecordingTarget): void {\n    this._state.recordingTarget = target;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  setFetchChromeCategories(fetch: boolean): void {\n    this._state.fetchChromeCategories = fetch;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  setAvailableAdbDevices(devices: AdbRecordingTarget[]): void {\n    this._state.availableAdbDevices = devices;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  setLastRecordingError(error?: string): void {\n    this._state.lastRecordingError = error;\n    this._state.recordingStatus = undefined;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  setRecordingStatus(status?: string): void {\n    this._state.recordingStatus = status;\n    this._state.lastRecordingError = undefined;\n    this.recCtl.refreshOnStateChange();\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  private setupExtentionPort(extensionLocalChannel: MessageChannel) {\n    // We proxy messages between the extension and the controller because the\n    // controller's worker can't access chrome.runtime.\n    const extensionPort =\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      window.chrome && chrome.runtime\n        ? chrome.runtime.connect(EXTENSION_ID)\n        : undefined;\n\n    this._state.extensionInstalled = extensionPort !== undefined;\n\n    if (extensionPort) {\n      // Send messages to keep-alive the extension port.\n      const interval = setInterval(() => {\n        extensionPort.postMessage({\n          method: 'ExtensionVersion',\n        });\n      }, 25000);\n      extensionPort.onDisconnect.addListener((_) => {\n        this._state.extensionInstalled = false;\n        clearInterval(interval);\n        void chrome.runtime.lastError; // Needed to not receive an error log.\n      });\n      // This forwards the messages from the extension to the controller.\n      extensionPort.onMessage.addListener(\n        (message: object, _port: chrome.runtime.Port) => {\n          if (isGetCategoriesResponse(message)) {\n            this._state.chromeCategories = message.categories;\n            scheduleFullRedraw();\n            return;\n          }\n          extensionLocalChannel.port2.postMessage(message);\n        },\n      );\n    }\n\n    // This forwards the messages from the controller to the extension\n    extensionLocalChannel.port2.onmessage = ({data}) => {\n      if (extensionPort) extensionPort.postMessage(data);\n    };\n  }\n\n  async updateAvailableAdbDevices(preferredDeviceSerial?: string) {\n    const devices = await new AdbOverWebUsb().getPairedDevices();\n\n    let recordingTarget: AdbRecordingTarget | undefined = undefined;\n\n    const availableAdbDevices: AdbRecordingTarget[] = [];\n    devices.forEach((d) => {\n      if (d.productName && d.serialNumber) {\n        availableAdbDevices.push({\n          name: d.productName,\n          serial: d.serialNumber,\n          os: 'S',\n        });\n        if (preferredDeviceSerial && preferredDeviceSerial === d.serialNumber) {\n          recordingTarget = availableAdbDevices[availableAdbDevices.length - 1];\n        }\n      }\n    });\n\n    this.setAvailableAdbDevices(availableAdbDevices);\n    this.selectAndroidDeviceIfAvailable(availableAdbDevices, recordingTarget);\n    scheduleFullRedraw();\n    return availableAdbDevices;\n  }\n\n  private selectAndroidDeviceIfAvailable(\n    availableAdbDevices: AdbRecordingTarget[],\n    recordingTarget?: RecordingTarget,\n  ) {\n    if (!recordingTarget) {\n      recordingTarget = this.state.recordingTarget;\n    }\n    const deviceConnected = isAdbTarget(recordingTarget);\n    const connectedDeviceDisconnected =\n      deviceConnected &&\n      availableAdbDevices.find(\n        (e) => e.serial === (recordingTarget as AdbRecordingTarget).serial,\n      ) === undefined;\n\n    if (availableAdbDevices.length) {\n      // If there's an Android device available and the current selection isn't\n      // one, select the Android device by default. If the current device isn't\n      // available anymore, but another Android device is, select the other\n      // Android device instead.\n      if (!deviceConnected || connectedDeviceDisconnected) {\n        recordingTarget = availableAdbDevices[0];\n      }\n\n      this.setRecordingTarget(recordingTarget);\n      return;\n    }\n\n    // If the currently selected device was disconnected, reset the recording\n    // target to the default one.\n    if (connectedDeviceDisconnected) {\n      this.setRecordingTarget(getDefaultRecordingTargets()[0]);\n    }\n  }\n}\n"]}