{"version":3,"file":"adb_connection_impl.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/adb_connection_impl.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AAEjC,qDAA6C;AAC7C,6EAAsE;AACtE,yDAAkD;AAOlD,6DAAsD;AAEtD,MAAsB,iBAAiB;IACrC,yEAAyE;IACzE,2EAA2E;IAC3E,0CAA0C;IAC1C,QAAQ,GAAsB,GAAG,EAAE,GAAE,CAAC,CAAC;IACvC,YAAY,GAAyB,CAAC,CAAC,EAAE,EAAE,GAAE,CAAC,CAAC;IAE/C,0EAA0E;IAC1E,aAAa;IACb,KAAK,CAAC,sBAAsB,CAAC,GAAW;QACtC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACxC,MAAM,gBAAgB,GAAG,IAAA,gBAAK,GAAQ,CAAC;QAEvC,mEAAmE;QACnE,oDAAoD;QACpD,SAAS,CAAC,wBAAwB,CAAC,GAAG,EAAE;YACtC,gBAAgB,CAAC,OAAO,EAAE,CAAC;QAC7B,CAAC,CAAC,CAAC;QACH,OAAO,gBAAgB,CAAC;IAC1B,CAAC;IAED,wEAAwE;IACxE,YAAY;IACZ,KAAK,CAAC,iBAAiB,CAAC,GAAW;QACjC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACxC,MAAM,aAAa,GAAG,IAAI,yCAAkB,EAAE,CAAC;QAC/C,MAAM,gBAAgB,GAAG,IAAA,gBAAK,GAAU,CAAC;QAEzC,SAAS,CAAC,uBAAuB,CAAC,CAAC,IAAgB,EAAE,EAAE;YACrD,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;QACH,SAAS,CAAC,wBAAwB,CAAC,GAAG,EAAE;YACtC,gBAAgB,CAAC,OAAO,CAAC,IAAA,yBAAU,EAAC,aAAa,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;QACtE,CAAC,CAAC,CAAC;QACH,OAAO,gBAAgB,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,MAAkB,EAAE,IAAY;QACzC,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAClD,MAAM,IAAI,iCAAc,CAAC,UAAU,CAAC,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC9D,2EAA2E;QAC3E,kBAAkB;QAClB,2EAA2E;QAC3E,0EAA0E;QAC1E,cAAc;QACd,MAAM,UAAU,CAAC,uBAAuB,EAAE,CAAC;IAC7C,CAAC;CAWF;AAzDD,8CAyDC","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer} from '../../../base/deferred';\nimport {ArrayBufferBuilder} from '../../../base/array_buffer_builder';\nimport {AdbFileHandler} from './adb_file_handler';\nimport {\n  AdbConnection,\n  ByteStream,\n  OnDisconnectCallback,\n  OnMessageCallback,\n} from './recording_interfaces_v2';\nimport {utf8Decode} from '../../../base/string_utils';\n\nexport abstract class AdbConnectionImpl implements AdbConnection {\n  // onStatus and onDisconnect are set to callbacks passed from the caller.\n  // This happens for instance in the AndroidWebusbTarget, which instantiates\n  // them with callbacks passed from the UI.\n  onStatus: OnMessageCallback = () => {};\n  onDisconnect: OnDisconnectCallback = (_) => {};\n\n  // Starts a shell command, and returns a promise resolved when the command\n  // completes.\n  async shellAndWaitCompletion(cmd: string): Promise<void> {\n    const adbStream = await this.shell(cmd);\n    const onStreamingEnded = defer<void>();\n\n    // We wait for the stream to be closed by the device, which happens\n    // after the shell command is successfully received.\n    adbStream.addOnStreamCloseCallback(() => {\n      onStreamingEnded.resolve();\n    });\n    return onStreamingEnded;\n  }\n\n  // Starts a shell command, then gathers all its output and returns it as\n  // a string.\n  async shellAndGetOutput(cmd: string): Promise<string> {\n    const adbStream = await this.shell(cmd);\n    const commandOutput = new ArrayBufferBuilder();\n    const onStreamingEnded = defer<string>();\n\n    adbStream.addOnStreamDataCallback((data: Uint8Array) => {\n      commandOutput.append(data);\n    });\n    adbStream.addOnStreamCloseCallback(() => {\n      onStreamingEnded.resolve(utf8Decode(commandOutput.toArrayBuffer()));\n    });\n    return onStreamingEnded;\n  }\n\n  async push(binary: Uint8Array, path: string): Promise<void> {\n    const byteStream = await this.openStream('sync:');\n    await new AdbFileHandler(byteStream).pushBinary(binary, path);\n    // We need to wait until the bytestream is closed. Otherwise, we can have a\n    // race condition:\n    // If this is the last stream, it will try to disconnect the device. In the\n    // meantime, the caller might create another stream which will try to open\n    // the device.\n    await byteStream.closeAndWaitForTeardown();\n  }\n\n  abstract shell(cmd: string): Promise<ByteStream>;\n\n  abstract canConnectWithoutContention(): Promise<boolean>;\n\n  abstract connectSocket(path: string): Promise<ByteStream>;\n\n  abstract disconnect(disconnectMessage?: string): Promise<void>;\n\n  protected abstract openStream(destination: string): Promise<ByteStream>;\n}\n"]}