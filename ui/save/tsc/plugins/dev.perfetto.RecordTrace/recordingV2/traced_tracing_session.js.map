{"version":3,"file":"traced_tracing_session.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/traced_tracing_session.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport protobuf from 'protobufjs/minimal';\nimport {defer, Deferred} from '../../../base/deferred';\nimport {assertExists, assertFalse, assertTrue} from '../../../base/logging';\nimport {\n  DisableTracingRequest,\n  DisableTracingResponse,\n  EnableTracingRequest,\n  EnableTracingResponse,\n  FreeBuffersRequest,\n  FreeBuffersResponse,\n  GetTraceStatsRequest,\n  GetTraceStatsResponse,\n  IBufferStats,\n  IMethodInfo,\n  IPCFrame,\n  ISlice,\n  QueryServiceStateRequest,\n  QueryServiceStateResponse,\n  ReadBuffersRequest,\n  ReadBuffersResponse,\n  TraceConfig,\n} from '../protos';\nimport {RecordingError} from './recording_error_handling';\nimport {\n  ByteStream,\n  DataSource,\n  TracingSession,\n  TracingSessionListener,\n} from './recording_interfaces_v2';\nimport {\n  BUFFER_USAGE_INCORRECT_FORMAT,\n  BUFFER_USAGE_NOT_ACCESSIBLE,\n  PARSING_UNABLE_TO_DECODE_METHOD,\n  PARSING_UNKNWON_REQUEST_ID,\n  PARSING_UNRECOGNIZED_MESSAGE,\n  PARSING_UNRECOGNIZED_PORT,\n  RECORDING_IN_PROGRESS,\n} from './recording_utils';\nimport {exists} from '../../../base/utils';\n\n// See wire_protocol.proto for more details.\nconst WIRE_PROTOCOL_HEADER_SIZE = 4;\n// See basic_types.h (kIPCBufferSize) for more details.\nconst MAX_IPC_BUFFER_SIZE = 128 * 1024;\n\nconst PROTO_LEN_DELIMITED_WIRE_TYPE = 2;\nconst TRACE_PACKET_PROTO_ID = 1;\nconst TRACE_PACKET_PROTO_TAG =\n  (TRACE_PACKET_PROTO_ID << 3) | PROTO_LEN_DELIMITED_WIRE_TYPE;\n\nfunction parseMessageSize(buffer: Uint8Array) {\n  const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.length);\n  return dv.getUint32(0, true);\n}\n\n// This class implements the protocol described in\n// https://perfetto.dev/docs/design-docs/api-and-abi#tracing-protocol-abi\nexport class TracedTracingSession implements TracingSession {\n  // Buffers received wire protocol data.\n  private incomingBuffer = new Uint8Array(MAX_IPC_BUFFER_SIZE);\n  private bufferedPartLength = 0;\n  private currentFrameLength?: number;\n\n  private availableMethods: IMethodInfo[] = [];\n  private serviceId = -1;\n\n  private resolveBindingPromise!: Deferred<void>;\n  private requestMethods = new Map<number, string>();\n\n  // Needed for ReadBufferResponse: all the trace packets are split into\n  // several slices. |partialPacket| is the buffer for them. Once we receive a\n  // slice with the flag |lastSliceForPacket|, a new packet is created.\n  private partialPacket: ISlice[] = [];\n  // Accumulates trace packets into a proto trace file..\n  private traceProtoWriter = protobuf.Writer.create();\n\n  // Accumulates DataSource objects from QueryServiceStateResponse,\n  // which can have >1 replies for each query\n  // go/codesearch/android/external/perfetto/protos/\n  // perfetto/ipc/consumer_port.proto;l=243-246\n  private pendingDataSources: DataSource[] = [];\n\n  // For concurrent calls to 'QueryServiceState', we return the same value.\n  private pendingQssMessage?: Deferred<DataSource[]>;\n\n  // Wire protocol request ID. After each request it is increased. It is needed\n  // to keep track of the type of request, and parse the response correctly.\n  private requestId = 1;\n\n  private pendingStatsMessages = new Array<Deferred<IBufferStats[]>>();\n\n  // The bytestream is obtained when creating a connection with a target.\n  // For instance, the AdbStream is obtained from a connection with an Adb\n  // device.\n  constructor(\n    private byteStream: ByteStream,\n    private tracingSessionListener: TracingSessionListener,\n  ) {\n    this.byteStream.addOnStreamDataCallback((data) =>\n      this.handleReceivedData(data),\n    );\n    this.byteStream.addOnStreamCloseCallback(() => this.clearState());\n  }\n\n  queryServiceState(): Promise<DataSource[]> {\n    if (this.pendingQssMessage) {\n      return this.pendingQssMessage;\n    }\n\n    const requestProto = QueryServiceStateRequest.encode(\n      new QueryServiceStateRequest(),\n    ).finish();\n    this.rpcInvoke('QueryServiceState', requestProto);\n\n    return (this.pendingQssMessage = defer<DataSource[]>());\n  }\n\n  start(config: TraceConfig): void {\n    const duration = config.durationMs;\n    this.tracingSessionListener.onStatus(\n      `${RECORDING_IN_PROGRESS}${\n        duration ? ' for ' + duration.toString() + ' ms' : ''\n      }...`,\n    );\n\n    const enableTracingRequest = new EnableTracingRequest();\n    enableTracingRequest.traceConfig = config;\n    const enableTracingRequestProto =\n      EnableTracingRequest.encode(enableTracingRequest).finish();\n    this.rpcInvoke('EnableTracing', enableTracingRequestProto);\n  }\n\n  cancel(): void {\n    this.terminateConnection();\n  }\n\n  stop(): void {\n    const requestProto = DisableTracingRequest.encode(\n      new DisableTracingRequest(),\n    ).finish();\n    this.rpcInvoke('DisableTracing', requestProto);\n  }\n\n  async getTraceBufferUsage(): Promise<number> {\n    if (!this.byteStream.isConnected()) {\n      // TODO(octaviant): make this more in line with the other trace buffer\n      //  error cases.\n      return 0;\n    }\n    const bufferStats = await this.getBufferStats();\n    let percentageUsed = -1;\n    for (const buffer of bufferStats) {\n      if (\n        !Number.isFinite(buffer.bytesWritten) ||\n        !Number.isFinite(buffer.bufferSize)\n      ) {\n        continue;\n      }\n      const used = assertExists(buffer.bytesWritten);\n      const total = assertExists(buffer.bufferSize);\n      if (total >= 0) {\n        percentageUsed = Math.max(percentageUsed, used / total);\n      }\n    }\n\n    if (percentageUsed === -1) {\n      return Promise.reject(new RecordingError(BUFFER_USAGE_INCORRECT_FORMAT));\n    }\n    return percentageUsed;\n  }\n\n  initConnection(): Promise<void> {\n    // bind IPC methods\n    const requestId = this.requestId++;\n    const frame = new IPCFrame({\n      requestId,\n      msgBindService: new IPCFrame.BindService({serviceName: 'ConsumerPort'}),\n    });\n    this.writeFrame(frame);\n\n    // We shouldn't bind multiple times to the service in the same tracing\n    // session.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    assertFalse(!!this.resolveBindingPromise);\n    this.resolveBindingPromise = defer<void>();\n    return this.resolveBindingPromise;\n  }\n\n  private getBufferStats(): Promise<IBufferStats[]> {\n    const getTraceStatsRequestProto = GetTraceStatsRequest.encode(\n      new GetTraceStatsRequest(),\n    ).finish();\n    try {\n      this.rpcInvoke('GetTraceStats', getTraceStatsRequestProto);\n    } catch (e) {\n      // GetTraceStats was introduced only on Android 10.\n      this.raiseError(e);\n    }\n\n    const statsMessage = defer<IBufferStats[]>();\n    this.pendingStatsMessages.push(statsMessage);\n    return statsMessage;\n  }\n\n  private terminateConnection(): void {\n    this.clearState();\n    const requestProto = FreeBuffersRequest.encode(\n      new FreeBuffersRequest(),\n    ).finish();\n    this.rpcInvoke('FreeBuffers', requestProto);\n    this.byteStream.close();\n  }\n\n  private clearState() {\n    for (const statsMessage of this.pendingStatsMessages) {\n      statsMessage.reject(new RecordingError(BUFFER_USAGE_NOT_ACCESSIBLE));\n    }\n    this.pendingStatsMessages = [];\n    this.pendingDataSources = [];\n    this.pendingQssMessage = undefined;\n  }\n\n  private rpcInvoke(methodName: string, argsProto: Uint8Array): void {\n    if (!this.byteStream.isConnected()) {\n      return;\n    }\n    const method = this.availableMethods.find((m) => m.name === methodName);\n    if (!exists(method) || !exists(method.id)) {\n      throw new RecordingError(\n        `Method ${methodName} not supported by the target`,\n      );\n    }\n    const requestId = this.requestId++;\n    const frame = new IPCFrame({\n      requestId,\n      msgInvokeMethod: new IPCFrame.InvokeMethod({\n        serviceId: this.serviceId,\n        methodId: method.id,\n        argsProto,\n      }),\n    });\n    this.requestMethods.set(requestId, methodName);\n    this.writeFrame(frame);\n  }\n\n  private writeFrame(frame: IPCFrame): void {\n    const frameProto: Uint8Array = IPCFrame.encode(frame).finish();\n    const frameLen = frameProto.length;\n    const buf = new Uint8Array(WIRE_PROTOCOL_HEADER_SIZE + frameLen);\n    const dv = new DataView(buf.buffer);\n    dv.setUint32(0, frameProto.length, /* littleEndian */ true);\n    for (let i = 0; i < frameLen; i++) {\n      dv.setUint8(WIRE_PROTOCOL_HEADER_SIZE + i, frameProto[i]);\n    }\n    this.byteStream.write(buf);\n  }\n\n  private handleReceivedData(rawData: Uint8Array): void {\n    // we parse the length of the next frame if it's available\n    if (\n      this.currentFrameLength === undefined &&\n      this.canCompleteLengthHeader(rawData)\n    ) {\n      const remainingFrameBytes =\n        WIRE_PROTOCOL_HEADER_SIZE - this.bufferedPartLength;\n      this.appendToIncomingBuffer(rawData.subarray(0, remainingFrameBytes));\n      rawData = rawData.subarray(remainingFrameBytes);\n\n      this.currentFrameLength = parseMessageSize(this.incomingBuffer);\n      this.bufferedPartLength = 0;\n    }\n\n    // Parse all complete frames.\n    while (\n      this.currentFrameLength !== undefined &&\n      this.bufferedPartLength + rawData.length >= this.currentFrameLength\n    ) {\n      // Read the remaining part of this message.\n      const bytesToCompleteMessage =\n        this.currentFrameLength - this.bufferedPartLength;\n      this.appendToIncomingBuffer(rawData.subarray(0, bytesToCompleteMessage));\n      this.parseFrame(this.incomingBuffer.subarray(0, this.currentFrameLength));\n      this.bufferedPartLength = 0;\n      // Remove the data just parsed.\n      rawData = rawData.subarray(bytesToCompleteMessage);\n\n      if (!this.canCompleteLengthHeader(rawData)) {\n        this.currentFrameLength = undefined;\n        break;\n      }\n      this.currentFrameLength = parseMessageSize(rawData);\n      rawData = rawData.subarray(WIRE_PROTOCOL_HEADER_SIZE);\n    }\n\n    // Buffer the remaining data (part of the next message).\n    this.appendToIncomingBuffer(rawData);\n  }\n\n  private canCompleteLengthHeader(newData: Uint8Array): boolean {\n    return newData.length + this.bufferedPartLength > WIRE_PROTOCOL_HEADER_SIZE;\n  }\n\n  private appendToIncomingBuffer(array: Uint8Array): void {\n    this.incomingBuffer.set(array, this.bufferedPartLength);\n    this.bufferedPartLength += array.length;\n  }\n\n  private parseFrame(frameBuffer: Uint8Array): void {\n    // Get a copy of the ArrayBuffer to avoid the original being overriden.\n    // See 170256902#comment21\n    const frame = IPCFrame.decode(frameBuffer.slice());\n    if (frame.msg === 'msgBindServiceReply') {\n      const msgBindServiceReply = frame.msgBindServiceReply;\n      if (\n        exists(msgBindServiceReply) &&\n        exists(msgBindServiceReply.methods) &&\n        exists(msgBindServiceReply.serviceId)\n      ) {\n        assertTrue(msgBindServiceReply.success === true);\n        this.availableMethods = msgBindServiceReply.methods;\n        this.serviceId = msgBindServiceReply.serviceId;\n        this.resolveBindingPromise.resolve();\n      }\n    } else if (frame.msg === 'msgInvokeMethodReply') {\n      const msgInvokeMethodReply = frame.msgInvokeMethodReply;\n      // We process messages without a `replyProto` field (for instance\n      // `FreeBuffers` does not have `replyProto`). However, we ignore messages\n      // without a valid 'success' field.\n      if (msgInvokeMethodReply?.success !== true) {\n        return;\n      }\n\n      const method = this.requestMethods.get(frame.requestId);\n      if (!method) {\n        this.raiseError(`${PARSING_UNKNWON_REQUEST_ID}: ${frame.requestId}`);\n        return;\n      }\n      const decoder = decoders.get(method);\n      if (decoder === undefined) {\n        this.raiseError(`${PARSING_UNABLE_TO_DECODE_METHOD}: ${method}`);\n        return;\n      }\n      const data = {...decoder(msgInvokeMethodReply.replyProto)};\n\n      if (method === 'ReadBuffers') {\n        for (const slice of data.slices ?? []) {\n          this.partialPacket.push(slice);\n          if (slice.lastSliceForPacket === true) {\n            let bufferSize = 0;\n            for (const slice of this.partialPacket) {\n              bufferSize += slice.data!.length;\n            }\n            const tracePacket = new Uint8Array(bufferSize);\n            let written = 0;\n            for (const slice of this.partialPacket) {\n              const data = slice.data!;\n              tracePacket.set(data, written);\n              written += data.length;\n            }\n            this.traceProtoWriter.uint32(TRACE_PACKET_PROTO_TAG);\n            this.traceProtoWriter.bytes(tracePacket);\n            this.partialPacket = [];\n          }\n        }\n        if (msgInvokeMethodReply.hasMore === false) {\n          this.tracingSessionListener.onTraceData(\n            this.traceProtoWriter.finish(),\n          );\n          this.terminateConnection();\n        }\n      } else if (method === 'EnableTracing') {\n        const readBuffersRequestProto = ReadBuffersRequest.encode(\n          new ReadBuffersRequest(),\n        ).finish();\n        this.rpcInvoke('ReadBuffers', readBuffersRequestProto);\n      } else if (method === 'GetTraceStats') {\n        const maybePendingStatsMessage = this.pendingStatsMessages.shift();\n        if (maybePendingStatsMessage) {\n          maybePendingStatsMessage.resolve(data?.traceStats?.bufferStats ?? []);\n        }\n      } else if (method === 'FreeBuffers') {\n        // No action required. If we successfully read a whole trace,\n        // we close the connection. Alternatively, if the tracing finishes\n        // with an exception or if the user cancels it, we also close the\n        // connection.\n      } else if (method === 'DisableTracing') {\n        // No action required. Same reasoning as for FreeBuffers.\n      } else if (method === 'QueryServiceState') {\n        const dataSources =\n          (data as QueryServiceStateResponse)?.serviceState?.dataSources || [];\n        for (const dataSource of dataSources) {\n          const name = dataSource?.dsDescriptor?.name;\n          if (name) {\n            this.pendingDataSources.push({\n              name,\n              descriptor: dataSource.dsDescriptor,\n            });\n          }\n        }\n        if (msgInvokeMethodReply.hasMore === false) {\n          assertExists(this.pendingQssMessage).resolve(this.pendingDataSources);\n          this.pendingDataSources = [];\n          this.pendingQssMessage = undefined;\n        }\n      } else {\n        this.raiseError(`${PARSING_UNRECOGNIZED_PORT}: ${method}`);\n      }\n    } else {\n      this.raiseError(`${PARSING_UNRECOGNIZED_MESSAGE}: ${frame.msg}`);\n    }\n  }\n\n  private raiseError(message: string): void {\n    this.terminateConnection();\n    this.tracingSessionListener.onError(message);\n  }\n}\n\nconst decoders = new Map<string, Function>()\n  .set('EnableTracing', EnableTracingResponse.decode)\n  .set('FreeBuffers', FreeBuffersResponse.decode)\n  .set('ReadBuffers', ReadBuffersResponse.decode)\n  .set('DisableTracing', DisableTracingResponse.decode)\n  .set('GetTraceStats', GetTraceStatsResponse.decode)\n  .set('QueryServiceState', QueryServiceStateResponse.decode);\n"]}