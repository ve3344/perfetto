{"version":3,"file":"android_target.js","sourceRoot":"","sources":["../../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/targets/android_target.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {fetchWithTimeout} from '../../../../base/http_utils';\nimport {exists} from '../../../../base/utils';\nimport {VERSION} from '../../../../gen/perfetto_version';\nimport {AdbConnectionImpl} from '../adb_connection_impl';\nimport {\n  DataSource,\n  OnTargetChangeCallback,\n  RecordingTargetV2,\n  TargetInfo,\n  TracingSession,\n  TracingSessionListener,\n} from '../recording_interfaces_v2';\nimport {\n  CUSTOM_TRACED_CONSUMER_SOCKET_PATH,\n  DEFAULT_TRACED_CONSUMER_SOCKET_PATH,\n  TRACEBOX_DEVICE_PATH,\n  TRACEBOX_FETCH_TIMEOUT,\n} from '../recording_utils';\nimport {TracedTracingSession} from '../traced_tracing_session';\n\nexport abstract class AndroidTarget implements RecordingTargetV2 {\n  private consumerSocketPath = DEFAULT_TRACED_CONSUMER_SOCKET_PATH;\n  protected androidApiLevel?: number;\n  protected dataSources?: DataSource[];\n\n  protected constructor(\n    private adbConnection: AdbConnectionImpl,\n    private onTargetChange: OnTargetChangeCallback,\n  ) {}\n\n  abstract getInfo(): TargetInfo;\n\n  // This is called when a usb USBConnectionEvent of type 'disconnect' event is\n  // emitted. This event is emitted when the USB connection is lost (example:\n  // when the user unplugged the connecting cable).\n  async disconnect(disconnectMessage?: string): Promise<void> {\n    await this.adbConnection.disconnect(disconnectMessage);\n  }\n\n  // Starts a tracing session in order to fetch information such as apiLevel\n  // and dataSources from the device. Then, it cancels the session.\n  async fetchTargetInfo(listener: TracingSessionListener): Promise<void> {\n    const tracingSession = await this.createTracingSession(listener);\n    tracingSession.cancel();\n  }\n\n  // We do not support long tracing on Android.\n  canCreateTracingSession(recordingMode: string): boolean {\n    return recordingMode !== 'LONG_TRACE';\n  }\n\n  async createTracingSession(\n    tracingSessionListener: TracingSessionListener,\n  ): Promise<TracingSession> {\n    this.adbConnection.onStatus = tracingSessionListener.onStatus;\n    this.adbConnection.onDisconnect = tracingSessionListener.onDisconnect;\n\n    if (!exists(this.androidApiLevel)) {\n      // 1. Fetch the API version from the device.\n      const version = await this.adbConnection.shellAndGetOutput(\n        'getprop ro.build.version.sdk',\n      );\n      this.androidApiLevel = Number(version);\n\n      this.onTargetChange();\n\n      // 2. For older OS versions we push the tracebox binary.\n      if (this.androidApiLevel < 29) {\n        await this.pushTracebox();\n        this.consumerSocketPath = CUSTOM_TRACED_CONSUMER_SOCKET_PATH;\n\n        await this.adbConnection.shellAndWaitCompletion(\n          this.composeTraceboxCommand('traced'),\n        );\n        await this.adbConnection.shellAndWaitCompletion(\n          this.composeTraceboxCommand('traced_probes'),\n        );\n      }\n    }\n\n    const adbStream = await this.adbConnection.connectSocket(\n      this.consumerSocketPath,\n    );\n\n    // 3. Start a tracing session.\n    const tracingSession = new TracedTracingSession(\n      adbStream,\n      tracingSessionListener,\n    );\n    await tracingSession.initConnection();\n\n    if (!this.dataSources) {\n      // 4. Fetch dataSources from QueryServiceState.\n      this.dataSources = await tracingSession.queryServiceState();\n\n      this.onTargetChange();\n    }\n    return tracingSession;\n  }\n\n  async pushTracebox() {\n    const arch = await this.fetchArchitecture();\n    const shortVersion = VERSION.split('-')[0];\n    const requestUrl = `https://commondatastorage.googleapis.com/perfetto-luci-artifacts/${shortVersion}/${arch}/tracebox`;\n    const fetchResponse = await fetchWithTimeout(\n      requestUrl,\n      {method: 'get'},\n      TRACEBOX_FETCH_TIMEOUT,\n    );\n    const traceboxBin = await fetchResponse.arrayBuffer();\n    await this.adbConnection.push(\n      new Uint8Array(traceboxBin),\n      TRACEBOX_DEVICE_PATH,\n    );\n\n    // We explicitly set the tracebox permissions because adb does not reliably\n    // set permissions when uploading the binary.\n    await this.adbConnection.shellAndWaitCompletion(\n      `chmod 755 ${TRACEBOX_DEVICE_PATH}`,\n    );\n  }\n\n  async fetchArchitecture() {\n    const abiList = await this.adbConnection.shellAndGetOutput(\n      'getprop ro.vendor.product.cpu.abilist',\n    );\n    // If multiple ABIs are allowed, the 64bit ones should have higher priority.\n    if (abiList.includes('arm64-v8a')) {\n      return 'android-arm64';\n    } else if (abiList.includes('x86')) {\n      return 'android-x86';\n    } else if (abiList.includes('armeabi-v7a') || abiList.includes('armeabi')) {\n      return 'android-arm';\n    } else if (abiList.includes('x86_64')) {\n      return 'android-x64';\n    }\n    // Most devices have arm64 architectures, so we should return this if\n    // nothing else is found.\n    return 'android-arm64';\n  }\n\n  canConnectWithoutContention(): Promise<boolean> {\n    return this.adbConnection.canConnectWithoutContention();\n  }\n\n  composeTraceboxCommand(applet: string) {\n    // 1. Set the consumer socket.\n    return (\n      'PERFETTO_CONSUMER_SOCK_NAME=@traced_consumer ' +\n      // 2. Set the producer socket.\n      'PERFETTO_PRODUCER_SOCK_NAME=@traced_producer ' +\n      // 3. Start the applet in the background.\n      `/data/local/tmp/tracebox ${applet} --background`\n    );\n  }\n}\n"]}