{"version":3,"file":"recording_interfaces_v2.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/recording_interfaces_v2.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {TraceConfig} from '../protos';\n\n// TargetFactory connects, disconnects and keeps track of targets.\n// There is one factory for AndroidWebusb, AndroidWebsocket, Chrome etc.\n// For instance, the AndroidWebusb factory returns a RecordingTargetV2 for each\n// device.\nexport interface TargetFactory {\n  // Store the kind explicitly as a string as opposed to using class.kind in\n  // case we ever minify our code.\n  readonly kind: string;\n\n  // Setter for OnTargetChange, which is executed when a target is\n  // added/removed or when its information is updated.\n  setOnTargetChange(onTargetChange: OnTargetChangeCallback): void;\n\n  getName(): string;\n\n  listTargets(): RecordingTargetV2[];\n  // Returns recording problems that we encounter when not directly using the\n  // target. For instance we connect webusb devices when Perfetto is loaded. If\n  // there is an issue with connecting a webusb device, we do not want to crash\n  // all of Perfetto, as the user may not want to use the recording\n  // functionality at all.\n  listRecordingProblems(): string[];\n\n  connectNewTarget(): Promise<RecordingTargetV2>;\n}\n\nexport interface DataSource {\n  name: string;\n\n  // Contains information that is opaque to the recording code. The caller can\n  // use the DataSource name to type cast the DataSource descriptor.\n  // For targets calling QueryServiceState, 'descriptor' will hold the\n  // datasource descriptor:\n  // https://source.corp.google.com/android/external/perfetto/protos/perfetto/\n  // common/data_source_descriptor.proto;l=28-60\n  // For Chrome, 'descriptor' will contain the answer received from\n  // 'GetCategories':\n  // https://source.corp.google.com/android/external/perfetto/ui/src/\n  // chrome_extension/chrome_tracing_controller.ts;l=220\n  descriptor: unknown;\n}\n\n// Common fields for all types of targetInfo: Chrome, Android, Linux etc.\ninterface TargetInfoBase {\n  name: string;\n\n  // The dataSources exposed by a target. They are fetched from the target\n  // (ex: using QSS for Android or GetCategories for Chrome).\n  dataSources: DataSource[];\n}\n\nexport interface AndroidTargetInfo extends TargetInfoBase {\n  targetType: 'ANDROID';\n\n  // This is the Android API level. For instance, it can be 32, 31, 30 etc.\n  // It is the \"API level\" column here:\n  // https://source.android.com/setup/start/build-numbers\n  androidApiLevel?: number;\n}\n\nexport interface ChromeTargetInfo extends TargetInfoBase {\n  targetType: 'CHROME' | 'CHROME_OS' | 'WINDOWS';\n}\n\nexport interface HostOsTargetInfo extends TargetInfoBase {\n  targetType: 'LINUX' | 'MACOS';\n}\n\n// Holds information about a target. It's used by the UI and the logic which\n// generates a config.\nexport type TargetInfo =\n  | AndroidTargetInfo\n  | ChromeTargetInfo\n  | HostOsTargetInfo;\n\n// RecordingTargetV2 is subclassed by Android devices and the Chrome browser/OS.\n// It creates tracing sessions which are used by the UI. For Android, it manages\n// the connection with the device.\nexport interface RecordingTargetV2 {\n  // Allows targets to surface target specific information such as\n  // well known key/value pairs: OS, targetType('ANDROID', 'CHROME', etc.)\n  getInfo(): TargetInfo;\n\n  // Disconnects the target.\n  disconnect(disconnectMessage?: string): Promise<void>;\n\n  // Returns true if we are able to connect to the target without interfering\n  // with other processes. For example, for adb devices connected over WebUSB,\n  // this will be false when we can not claim the interface (Which most likely\n  // means that 'adb server' is running locally.). After querrying this method,\n  // the caller can decide if they want to connect to the target and as a side\n  // effect take the connection away from other processes.\n  canConnectWithoutContention(): Promise<boolean>;\n\n  // Whether the recording target can be used in a tracing session. For example,\n  // virtual targets do not support a tracing session.\n  canCreateTracingSession(recordingMode?: string): boolean;\n\n  // Some target information can only be obtained after connecting to the\n  // target. This will establish a connection and retrieve data such as\n  // dataSources and apiLevel for Android.\n  fetchTargetInfo(\n    tracingSessionListener: TracingSessionListener,\n  ): Promise<void>;\n\n  createTracingSession(\n    tracingSessionListener: TracingSessionListener,\n  ): Promise<TracingSession>;\n}\n\n// TracingSession is used by the UI to record a trace. Depending on user\n// actions, the UI can start/stop/cancel a session. During the recording, it\n// provides updates about buffer usage. It is subclassed by\n// TracedTracingSession, which manages the communication with traced and has\n// logic for encoding/decoding Perfetto client requests/replies.\nexport interface TracingSession {\n  // Starts the tracing session.\n  start(config: TraceConfig): void;\n\n  // Will stop the tracing session and NOT return any trace.\n  cancel(): void;\n\n  // Will stop the tracing session. The implementing class may also return\n  // the trace using a callback.\n  stop(): void;\n\n  // Returns the percentage of the trace buffer that is currently being\n  // occupied.\n  getTraceBufferUsage(): Promise<number>;\n}\n\n// Connection with an Adb device. Implementations will have logic specific to\n// the connection protocol used(Ex: WebSocket, WebUsb).\nexport interface AdbConnection {\n  // Will push a binary to a given path.\n  push(binary: ArrayBuffer, path: string): Promise<void>;\n\n  // Will issue a shell command to the device.\n  shell(cmd: string): Promise<ByteStream>;\n\n  // Will establish a connection(a ByteStream) with the device.\n  connectSocket(path: string): Promise<ByteStream>;\n\n  // Returns true if we are able to connect without interfering\n  // with other processes. For example, for adb devices connected over WebUSB,\n  // this will be false when we can not claim the interface (Which most likely\n  // means that 'adb server' is running locally.).\n  canConnectWithoutContention(): Promise<boolean>;\n\n  // Ends the connection.\n  disconnect(disconnectMessage?: string): Promise<void>;\n}\n\n// A stream for a connection between a target and a tracing session.\nexport interface ByteStream {\n  // The caller can add callbacks, to be executed when the stream receives new\n  // data or when it finished closing itself.\n  addOnStreamDataCallback(onStreamData: OnStreamDataCallback): void;\n  addOnStreamCloseCallback(onStreamClose: OnStreamCloseCallback): void;\n\n  isConnected(): boolean;\n  write(data: string | Uint8Array): void;\n\n  close(): void;\n  closeAndWaitForTeardown(): Promise<void>;\n}\n\n// Handles binary messages received over the ByteStream.\nexport interface OnStreamDataCallback {\n  (data: Uint8Array): void;\n}\n\n// Called when the ByteStream is closed.\nexport interface OnStreamCloseCallback {\n  (): void;\n}\n\n// OnTraceDataCallback will return the entire trace when it has been fully\n// assembled. This will be changed in the following CL aosp/2057640.\nexport interface OnTraceDataCallback {\n  (trace: Uint8Array): void;\n}\n\n// Handles messages that are useful in the UI and that occur at any layer of the\n// recording (trace, connection). The messages includes both status messages and\n// error messages.\nexport interface OnMessageCallback {\n  (message: string): void;\n}\n\n// Handles the loss of the connection at the connection layer (used by the\n// AdbConnection).\nexport interface OnDisconnectCallback {\n  (errorMessage?: string): void;\n}\n\n// Called when there is a change of targets or within a target.\n// For instance, it's used when an Adb device becomes connected/disconnected.\n// It's also executed by a target when the information it stores gets updated.\nexport interface OnTargetChangeCallback {\n  (): void;\n}\n\n// A collection of callbacks that is passed to RecordingTargetV2 and\n// subsequently to TracingSession. The callbacks are decided by the UI, so the\n// recording code is not coupled with the rendering logic.\nexport interface TracingSessionListener {\n  onTraceData: OnTraceDataCallback;\n  onStatus: OnMessageCallback;\n  onDisconnect: OnDisconnectCallback;\n  onError: OnMessageCallback;\n}\n"]}