{"version":3,"file":"adb_connection_over_websocket.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/adb_connection_over_websocket.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer, Deferred} from '../../../base/deferred';\nimport {utf8Decode} from '../../../base/string_utils';\nimport {AdbConnectionImpl} from './adb_connection_impl';\nimport {RecordingError} from './recording_error_handling';\nimport {\n  ByteStream,\n  OnDisconnectCallback,\n  OnStreamCloseCallback,\n  OnStreamDataCallback,\n} from './recording_interfaces_v2';\nimport {\n  ALLOW_USB_DEBUGGING,\n  buildAbdWebsocketCommand,\n  WEBSOCKET_UNABLE_TO_CONNECT,\n} from './recording_utils';\n\nexport class AdbConnectionOverWebsocket extends AdbConnectionImpl {\n  private streams = new Set<AdbOverWebsocketStream>();\n\n  onDisconnect: OnDisconnectCallback = (_) => {};\n\n  constructor(\n    private deviceSerialNumber: string,\n    private websocketUrl: string,\n  ) {\n    super();\n  }\n\n  shell(cmd: string): Promise<AdbOverWebsocketStream> {\n    return this.openStream('shell:' + cmd);\n  }\n\n  connectSocket(path: string): Promise<AdbOverWebsocketStream> {\n    return this.openStream(path);\n  }\n\n  protected async openStream(\n    destination: string,\n  ): Promise<AdbOverWebsocketStream> {\n    return AdbOverWebsocketStream.create(\n      this.websocketUrl,\n      destination,\n      this.deviceSerialNumber,\n      this.closeStream.bind(this),\n    );\n  }\n\n  // The disconnection for AdbConnectionOverWebsocket is synchronous, but this\n  // method is async to have a common interface with other types of connections\n  // which are async.\n  async disconnect(disconnectMessage?: string): Promise<void> {\n    for (const stream of this.streams) {\n      stream.close();\n    }\n    this.onDisconnect(disconnectMessage);\n  }\n\n  closeStream(stream: AdbOverWebsocketStream): void {\n    if (this.streams.has(stream)) {\n      this.streams.delete(stream);\n    }\n  }\n\n  // There will be no contention for the websocket connection, because it will\n  // communicate with the 'adb server' running on the computer which opened\n  // Perfetto.\n  canConnectWithoutContention(): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n}\n\n// An AdbOverWebsocketStream instantiates a websocket connection to the device.\n// It exposes an API to write commands to this websocket and read its output.\nexport class AdbOverWebsocketStream implements ByteStream {\n  private websocket: WebSocket;\n\n  // commandSentSignal gets resolved if we successfully connect to the device\n  // and send the command this socket wraps. commandSentSignal gets rejected if\n  // we fail to connect to the device.\n  private commandSentSignal = defer<AdbOverWebsocketStream>();\n\n  // We store a promise for each messge while the message is processed.\n  // This way, if the websocket server closes the connection, we first process\n  // all previously received messages and only afterwards disconnect.\n  // An application is when the stream wraps a shell command. The websocket\n  // server will reply and then immediately disconnect.\n  private messageProcessedSignals: Set<Deferred<void>> = new Set();\n\n  private _isConnected = false;\n  private onStreamDataCallbacks: OnStreamDataCallback[] = [];\n  private onStreamCloseCallbacks: OnStreamCloseCallback[] = [];\n\n  private constructor(\n    websocketUrl: string,\n    destination: string,\n    deviceSerialNumber: string,\n    private removeFromConnection: (stream: AdbOverWebsocketStream) => void,\n  ) {\n    this.websocket = new WebSocket(websocketUrl);\n\n    this.websocket.onopen = this.onOpen.bind(this, deviceSerialNumber);\n    this.websocket.onmessage = this.onMessage.bind(this, destination);\n    // The websocket may be closed by the websocket server. This happens\n    // for instance when we get the full result of a shell command.\n    this.websocket.onclose = this.onClose.bind(this);\n  }\n\n  addOnStreamDataCallback(onStreamData: OnStreamDataCallback) {\n    this.onStreamDataCallbacks.push(onStreamData);\n  }\n\n  addOnStreamCloseCallback(onStreamClose: OnStreamCloseCallback) {\n    this.onStreamCloseCallbacks.push(onStreamClose);\n  }\n\n  // Used by the connection object to signal newly received data, not exposed\n  // in the interface.\n  signalStreamData(data: Uint8Array): void {\n    for (const onStreamData of this.onStreamDataCallbacks) {\n      onStreamData(data);\n    }\n  }\n\n  // Used by the connection object to signal the stream is closed, not exposed\n  // in the interface.\n  signalStreamClosed(): void {\n    for (const onStreamClose of this.onStreamCloseCallbacks) {\n      onStreamClose();\n    }\n    this.onStreamDataCallbacks = [];\n    this.onStreamCloseCallbacks = [];\n  }\n\n  // We close the websocket and notify the AdbConnection to remove this stream.\n  close(): void {\n    // If the websocket connection is still open (ie. the close did not\n    // originate from the server), we close the websocket connection.\n    if (this.websocket.readyState === this.websocket.OPEN) {\n      this.websocket.close();\n      // We remove the 'onclose' callback so the 'close' method doesn't get\n      // executed twice.\n      this.websocket.onclose = null;\n    }\n    this._isConnected = false;\n    this.removeFromConnection(this);\n    this.signalStreamClosed();\n  }\n\n  // For websocket, the teardown happens synchronously.\n  async closeAndWaitForTeardown(): Promise<void> {\n    this.close();\n  }\n\n  write(msg: string | Uint8Array): void {\n    this.websocket.send(msg);\n  }\n\n  isConnected(): boolean {\n    return this._isConnected;\n  }\n\n  private async onOpen(deviceSerialNumber: string): Promise<void> {\n    this.websocket.send(\n      buildAbdWebsocketCommand(`host:transport:${deviceSerialNumber}`),\n    );\n  }\n\n  private async onMessage(\n    destination: string,\n    evt: MessageEvent,\n  ): Promise<void> {\n    const messageProcessed = defer<void>();\n    this.messageProcessedSignals.add(messageProcessed);\n    try {\n      if (!this._isConnected) {\n        const txt = (await evt.data.text()) as string;\n        const prefix = txt.substring(0, 4);\n        if (prefix === 'OKAY') {\n          this._isConnected = true;\n          this.websocket.send(buildAbdWebsocketCommand(destination));\n          this.commandSentSignal.resolve(this);\n        } else if (prefix === 'FAIL' && txt.includes('device unauthorized')) {\n          this.commandSentSignal.reject(\n            new RecordingError(ALLOW_USB_DEBUGGING),\n          );\n          this.close();\n        } else {\n          this.commandSentSignal.reject(\n            new RecordingError(WEBSOCKET_UNABLE_TO_CONNECT),\n          );\n          this.close();\n        }\n      } else {\n        // Upon a successful connection we first receive an 'OKAY' message.\n        // After that, we receive messages with traced binary payloads.\n        const arrayBufferResponse = await evt.data.arrayBuffer();\n        if (utf8Decode(arrayBufferResponse) !== 'OKAY') {\n          this.signalStreamData(new Uint8Array(arrayBufferResponse));\n        }\n      }\n      messageProcessed.resolve();\n    } finally {\n      this.messageProcessedSignals.delete(messageProcessed);\n    }\n  }\n\n  private async onClose(): Promise<void> {\n    // Wait for all messages to be processed before closing the connection.\n    await Promise.allSettled(this.messageProcessedSignals);\n    this.close();\n  }\n\n  static create(\n    websocketUrl: string,\n    destination: string,\n    deviceSerialNumber: string,\n    removeFromConnection: (stream: AdbOverWebsocketStream) => void,\n  ): Promise<AdbOverWebsocketStream> {\n    return new AdbOverWebsocketStream(\n      websocketUrl,\n      destination,\n      deviceSerialNumber,\n      removeFromConnection,\n    ).commandSentSignal;\n  }\n}\n"]}