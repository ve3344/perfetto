{"version":3,"file":"recording_page_controller.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/recording_page_controller.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assertExists, assertTrue} from '../../../base/logging';\nimport {currentDateHourAndMinute} from '../../../base/time';\nimport {RecordingManager} from '../recording_manager';\nimport {autosaveConfigStore} from '../record_config';\nimport {\n  DEFAULT_ADB_WEBSOCKET_URL,\n  DEFAULT_TRACED_WEBSOCKET_URL,\n} from '../recording_ui_utils';\nimport {couldNotClaimInterface} from '../reset_interface_modal';\nimport {TraceConfig} from '../protos';\nimport {TRACE_SUFFIX} from '../../../public/trace';\nimport {genTraceConfig} from './recording_config_utils';\nimport {RecordingError, showRecordingModal} from './recording_error_handling';\nimport {\n  RecordingTargetV2,\n  TargetInfo,\n  TracingSession,\n  TracingSessionListener,\n} from './recording_interfaces_v2';\nimport {\n  BUFFER_USAGE_NOT_ACCESSIBLE,\n  RECORDING_IN_PROGRESS,\n} from './recording_utils';\nimport {\n  ANDROID_WEBSOCKET_TARGET_FACTORY,\n  AndroidWebsocketTargetFactory,\n} from './target_factories/android_websocket_target_factory';\nimport {ANDROID_WEBUSB_TARGET_FACTORY} from './target_factories/android_webusb_target_factory';\nimport {\n  HOST_OS_TARGET_FACTORY,\n  HostOsTargetFactory,\n} from './target_factories/host_os_target_factory';\nimport {targetFactoryRegistry} from './target_factory_registry';\nimport {scheduleFullRedraw} from '../../../widgets/raf';\nimport {App} from '../../../public/app';\n\n// The recording page can be in any of these states. It can transition between\n// states:\n// a) because of a user actions - pressing a UI button ('Start', 'Stop',\n//    'Cancel', 'Force reset' of the target), selecting a different target in\n//    the UI, authorizing authentication on an Android device,\n//    pulling the cable which connects an Android device.\n// b) automatically - if there is no need to reset the device or if the user\n//    has previously authorised the device to be debugged via USB.\n//\n// Recording state machine: https://screenshot.googleplex.com/BaX5EGqQMajgV7G\nexport enum RecordingState {\n  NO_TARGET = 0,\n  TARGET_SELECTED = 1,\n  // P1 stands for 'Part 1', where we first connect to the device in order to\n  // obtain target information.\n  ASK_TO_FORCE_P1 = 2,\n  AUTH_P1 = 3,\n  TARGET_INFO_DISPLAYED = 4,\n  // P2 stands for 'Part 2', where we connect to device for the 2nd+ times, to\n  // record a tracing session.\n  ASK_TO_FORCE_P2 = 5,\n  AUTH_P2 = 6,\n  RECORDING = 7,\n  WAITING_FOR_TRACE_DISPLAY = 8,\n}\n\n// Wraps a tracing session promise while the promise is being resolved (e.g.\n// while we are awaiting for ADB auth).\nclass TracingSessionWrapper {\n  private tracingSession?: TracingSession = undefined;\n  private isCancelled = false;\n  // We only execute the logic in the callbacks if this TracingSessionWrapper\n  // is the one referenced by the controller. Otherwise this can hold a\n  // tracing session which the user has already cancelled, so it shouldn't\n  // influence the UI.\n  private tracingSessionListener: TracingSessionListener = {\n    onTraceData: (trace: Uint8Array) =>\n      this.controller.maybeOnTraceData(this, trace),\n    onStatus: (message) => this.controller.maybeOnStatus(this, message),\n    onDisconnect: (errorMessage?: string) =>\n      this.controller.maybeOnDisconnect(this, errorMessage),\n    onError: (errorMessage: string) =>\n      this.controller.maybeOnError(this, errorMessage),\n  };\n\n  private target: RecordingTargetV2;\n  private controller: RecordingPageController;\n\n  constructor(target: RecordingTargetV2, controller: RecordingPageController) {\n    this.target = target;\n    this.controller = controller;\n  }\n\n  async start(traceConfig: TraceConfig) {\n    let stateGeneratioNr = this.controller.getStateGeneration();\n    const createSession = async () => {\n      try {\n        this.controller.maybeSetState(\n          this,\n          RecordingState.AUTH_P2,\n          stateGeneratioNr,\n        );\n        stateGeneratioNr += 1;\n\n        const session = await this.target.createTracingSession(\n          this.tracingSessionListener,\n        );\n\n        // We check the `isCancelled` to see if the user has cancelled the\n        // tracing session before it becomes available in TracingSessionWrapper.\n        if (this.isCancelled) {\n          session.cancel();\n          return;\n        }\n\n        this.tracingSession = session;\n        this.controller.maybeSetState(\n          this,\n          RecordingState.RECORDING,\n          stateGeneratioNr,\n        );\n        // When the session is resolved, the traceConfig has been instantiated.\n        this.tracingSession.start(assertExists(traceConfig));\n      } catch (e) {\n        this.tracingSessionListener.onError(e.message);\n      }\n    };\n\n    if (await this.target.canConnectWithoutContention()) {\n      await createSession();\n    } else {\n      // If we need to reset the connection to be able to connect, we ask\n      // the user if they want to reset the connection.\n      this.controller.maybeSetState(\n        this,\n        RecordingState.ASK_TO_FORCE_P2,\n        stateGeneratioNr,\n      );\n      stateGeneratioNr += 1;\n      couldNotClaimInterface(createSession, () =>\n        this.controller.maybeClearRecordingState(this),\n      );\n    }\n  }\n\n  async fetchTargetInfo() {\n    let stateGeneratioNr = this.controller.getStateGeneration();\n    const createSession = async () => {\n      try {\n        this.controller.maybeSetState(\n          this,\n          RecordingState.AUTH_P1,\n          stateGeneratioNr,\n        );\n        stateGeneratioNr += 1;\n        await this.target.fetchTargetInfo(this.tracingSessionListener);\n        this.controller.maybeSetState(\n          this,\n          RecordingState.TARGET_INFO_DISPLAYED,\n          stateGeneratioNr,\n        );\n      } catch (e) {\n        this.tracingSessionListener.onError(e.message);\n      }\n    };\n\n    if (await this.target.canConnectWithoutContention()) {\n      await createSession();\n    } else {\n      // If we need to reset the connection to be able to connect, we ask\n      // the user if they want to reset the connection.\n      this.controller.maybeSetState(\n        this,\n        RecordingState.ASK_TO_FORCE_P1,\n        stateGeneratioNr,\n      );\n      stateGeneratioNr += 1;\n      couldNotClaimInterface(createSession, () =>\n        this.controller.maybeSetState(\n          this,\n          RecordingState.TARGET_SELECTED,\n          stateGeneratioNr,\n        ),\n      );\n    }\n  }\n\n  cancel() {\n    if (this.tracingSession) {\n      this.tracingSession.cancel();\n    } else {\n      // In some cases, the tracingSession may not be available to the\n      // TracingSessionWrapper when the user cancels it.\n      // For instance:\n      //  1. The user clicked 'Start'.\n      //  2. They clicked 'Stop' without authorizing on the device.\n      //  3. They clicked 'Start'.\n      //  4. They authorized on the device.\n      // In these cases, we want to cancel the tracing session as soon as it\n      // becomes available. Therefore, we keep the `isCancelled` boolean and\n      // check it when we receive the tracing session.\n      this.isCancelled = true;\n    }\n    this.controller.maybeClearRecordingState(this);\n  }\n\n  stop() {\n    const stateGeneratioNr = this.controller.getStateGeneration();\n    if (this.tracingSession) {\n      this.tracingSession.stop();\n      this.controller.maybeSetState(\n        this,\n        RecordingState.WAITING_FOR_TRACE_DISPLAY,\n        stateGeneratioNr,\n      );\n    } else {\n      // In some cases, the tracingSession may not be available to the\n      // TracingSessionWrapper when the user stops it.\n      // For instance:\n      //  1. The user clicked 'Start'.\n      //  2. They clicked 'Stop' without authorizing on the device.\n      //  3. They clicked 'Start'.\n      //  4. They authorized on the device.\n      // In these cases, we want to cancel the tracing session as soon as it\n      // becomes available. Therefore, we keep the `isCancelled` boolean and\n      // check it when we receive the tracing session.\n      this.isCancelled = true;\n      this.controller.maybeClearRecordingState(this);\n    }\n  }\n\n  getTraceBufferUsage(): Promise<number> {\n    if (!this.tracingSession) {\n      throw new RecordingError(BUFFER_USAGE_NOT_ACCESSIBLE);\n    }\n    return this.tracingSession.getTraceBufferUsage();\n  }\n}\n\n// Keeps track of the state the Ui is in. Has methods which are executed on\n// user actions such as starting/stopping/cancelling a tracing session.\nexport class RecordingPageController {\n  private app: App;\n  private recMgr: RecordingManager;\n\n  // State of the recording page. This is set by user actions and/or automatic\n  // transitions. This is queried by the UI in order to\n  private state: RecordingState = RecordingState.NO_TARGET;\n  // Currently selected target.\n  private target?: RecordingTargetV2 = undefined;\n  // We wrap the tracing session in an object, because for some targets\n  // (Ex: Android) it is only created after we have succesfully authenticated\n  // with the target.\n  private tracingSessionWrapper?: TracingSessionWrapper = undefined;\n  // How much of the buffer is used for the current tracing session.\n  private bufferUsagePercentage: number = 0;\n  // A counter for state modifications. We use this to ensure that state\n  // transitions don't override one another in async functions.\n  private stateGeneration = 0;\n\n  constructor(app: App, recMgr: RecordingManager) {\n    this.app = app;\n    this.recMgr = recMgr;\n  }\n\n  getBufferUsagePercentage(): number {\n    return this.bufferUsagePercentage;\n  }\n\n  getState(): RecordingState {\n    return this.state;\n  }\n\n  getStateGeneration(): number {\n    return this.stateGeneration;\n  }\n\n  maybeSetState(\n    tracingSessionWrapper: TracingSessionWrapper,\n    state: RecordingState,\n    stateGeneration: number,\n  ): void {\n    if (this.tracingSessionWrapper !== tracingSessionWrapper) {\n      return;\n    }\n    if (stateGeneration !== this.stateGeneration) {\n      throw new RecordingError('Recording page state transition out of order.');\n    }\n    this.setState(state);\n    this.recMgr.setRecordingStatus(undefined);\n    scheduleFullRedraw();\n  }\n\n  maybeClearRecordingState(tracingSessionWrapper: TracingSessionWrapper): void {\n    if (this.tracingSessionWrapper === tracingSessionWrapper) {\n      this.clearRecordingState();\n    }\n  }\n\n  maybeOnTraceData(\n    tracingSessionWrapper: TracingSessionWrapper,\n    trace: Uint8Array,\n  ) {\n    if (this.tracingSessionWrapper !== tracingSessionWrapper) {\n      return;\n    }\n    this.app.openTraceFromBuffer({\n      title: 'Recorded trace',\n      buffer: trace.buffer,\n      fileName: `trace_${currentDateHourAndMinute()}${TRACE_SUFFIX}`,\n    });\n    this.clearRecordingState();\n  }\n\n  maybeOnStatus(tracingSessionWrapper: TracingSessionWrapper, message: string) {\n    if (this.tracingSessionWrapper !== tracingSessionWrapper) {\n      return;\n    }\n    // For the 'Recording in progress for 7000ms we don't show a\n    // modal.'\n    if (message.startsWith(RECORDING_IN_PROGRESS)) {\n      this.recMgr.setRecordingStatus(message);\n    } else {\n      // For messages such as 'Please allow USB debugging on your\n      // device, which require a user action, we show a modal.\n      showRecordingModal(message);\n    }\n  }\n\n  maybeOnDisconnect(\n    tracingSessionWrapper: TracingSessionWrapper,\n    errorMessage?: string,\n  ) {\n    if (this.tracingSessionWrapper !== tracingSessionWrapper) {\n      return;\n    }\n    if (errorMessage) {\n      showRecordingModal(errorMessage);\n    }\n    this.clearRecordingState();\n    this.onTargetChange();\n  }\n\n  maybeOnError(\n    tracingSessionWrapper: TracingSessionWrapper,\n    errorMessage: string,\n  ) {\n    if (this.tracingSessionWrapper !== tracingSessionWrapper) {\n      return;\n    }\n    showRecordingModal(errorMessage);\n    this.clearRecordingState();\n  }\n\n  getTargetInfo(): TargetInfo | undefined {\n    if (!this.target) {\n      return undefined;\n    }\n    return this.target.getInfo();\n  }\n\n  canCreateTracingSession() {\n    if (!this.target) {\n      return false;\n    }\n    return this.target.canCreateTracingSession();\n  }\n\n  selectTarget(selectedTarget?: RecordingTargetV2) {\n    assertTrue(\n      RecordingState.NO_TARGET <= this.state &&\n        this.state < RecordingState.RECORDING,\n    );\n    // If the selected target exists and is the same as the previous one, we\n    // don't need to do anything.\n    if (selectedTarget && selectedTarget === this.target) {\n      return;\n    }\n\n    // We assign the new target and redraw the page.\n    this.target = selectedTarget;\n\n    if (!this.target) {\n      this.setState(RecordingState.NO_TARGET);\n      scheduleFullRedraw();\n      return;\n    }\n    this.setState(RecordingState.TARGET_SELECTED);\n    scheduleFullRedraw();\n\n    this.tracingSessionWrapper = this.createTracingSessionWrapper(this.target);\n    this.tracingSessionWrapper.fetchTargetInfo();\n  }\n\n  async addAndroidDevice(): Promise<void> {\n    try {\n      const target = await targetFactoryRegistry\n        .get(ANDROID_WEBUSB_TARGET_FACTORY)\n        .connectNewTarget();\n      this.selectTarget(target);\n    } catch (e) {\n      if (e instanceof RecordingError) {\n        showRecordingModal(e.message);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  onTargetSelection(targetName: string): void {\n    assertTrue(\n      RecordingState.NO_TARGET <= this.state &&\n        this.state < RecordingState.RECORDING,\n    );\n    const allTargets = targetFactoryRegistry.listTargets();\n    this.selectTarget(allTargets.find((t) => t.getInfo().name === targetName));\n  }\n\n  onStartRecordingPressed(): void {\n    assertTrue(RecordingState.TARGET_INFO_DISPLAYED === this.state);\n    location.href = '#!/record/instructions';\n    autosaveConfigStore.save(this.recMgr.state.recordConfig);\n\n    const target = this.getTarget();\n    const targetInfo = target.getInfo();\n    this.app.analytics.logEvent(\n      'Record Trace',\n      `Record trace (${targetInfo.targetType})`,\n    );\n    const traceConfig = genTraceConfig(\n      this.recMgr.state.recordConfig,\n      targetInfo,\n    );\n\n    this.tracingSessionWrapper = this.createTracingSessionWrapper(target);\n    this.tracingSessionWrapper.start(traceConfig);\n  }\n\n  onCancel() {\n    assertTrue(\n      RecordingState.AUTH_P2 <= this.state &&\n        this.state <= RecordingState.RECORDING,\n    );\n    // The 'Cancel' button will only be shown after a `tracingSessionWrapper`\n    // is created.\n    this.getTracingSessionWrapper().cancel();\n  }\n\n  onStop() {\n    assertTrue(\n      RecordingState.AUTH_P2 <= this.state &&\n        this.state <= RecordingState.RECORDING,\n    );\n    // The 'Stop' button will only be shown after a `tracingSessionWrapper`\n    // is created.\n    this.getTracingSessionWrapper().stop();\n  }\n\n  async fetchBufferUsage() {\n    assertTrue(this.state >= RecordingState.AUTH_P2);\n    if (!this.tracingSessionWrapper) return;\n    const session = this.tracingSessionWrapper;\n\n    try {\n      const usage = await session.getTraceBufferUsage();\n      if (this.tracingSessionWrapper === session) {\n        this.bufferUsagePercentage = usage;\n      }\n    } catch (e) {\n      // We ignore RecordingErrors because they are not necessary for the trace\n      // to be successfully collected.\n      if (!(e instanceof RecordingError)) {\n        throw e;\n      }\n    }\n    // We redraw if:\n    // 1. We received a correct buffer usage value.\n    // 2. We receive a RecordingError.\n    scheduleFullRedraw();\n  }\n\n  initFactories() {\n    assertTrue(this.state <= RecordingState.TARGET_INFO_DISPLAYED);\n    for (const targetFactory of targetFactoryRegistry.listTargetFactories()) {\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      if (targetFactory) {\n        targetFactory.setOnTargetChange(this.onTargetChange.bind(this));\n      }\n    }\n\n    if (targetFactoryRegistry.has(ANDROID_WEBSOCKET_TARGET_FACTORY)) {\n      const websocketTargetFactory = targetFactoryRegistry.get(\n        ANDROID_WEBSOCKET_TARGET_FACTORY,\n      ) as AndroidWebsocketTargetFactory;\n      websocketTargetFactory.tryEstablishWebsocket(DEFAULT_ADB_WEBSOCKET_URL);\n    }\n    if (targetFactoryRegistry.has(HOST_OS_TARGET_FACTORY)) {\n      const websocketTargetFactory = targetFactoryRegistry.get(\n        HOST_OS_TARGET_FACTORY,\n      ) as HostOsTargetFactory;\n      websocketTargetFactory.tryEstablishWebsocket(\n        DEFAULT_TRACED_WEBSOCKET_URL,\n      );\n    }\n  }\n\n  shouldShowTargetSelection(): boolean {\n    return (\n      RecordingState.NO_TARGET <= this.state &&\n      this.state < RecordingState.RECORDING\n    );\n  }\n\n  shouldShowStopCancelButtons(): boolean {\n    return (\n      RecordingState.AUTH_P2 <= this.state &&\n      this.state <= RecordingState.RECORDING\n    );\n  }\n\n  private onTargetChange() {\n    const allTargets = targetFactoryRegistry.listTargets();\n    // If the change happens for an existing target, the controller keeps the\n    // currently selected target in focus.\n    if (this.target && allTargets.includes(this.target)) {\n      scheduleFullRedraw();\n      return;\n    }\n    // If the change happens to a new target or the controller does not have a\n    // defined target, the selection process again is run again.\n    this.selectTarget();\n  }\n\n  private createTracingSessionWrapper(\n    target: RecordingTargetV2,\n  ): TracingSessionWrapper {\n    return new TracingSessionWrapper(target, this);\n  }\n\n  private clearRecordingState(): void {\n    this.bufferUsagePercentage = 0;\n    this.tracingSessionWrapper = undefined;\n    this.setState(RecordingState.TARGET_INFO_DISPLAYED);\n    this.recMgr.setRecordingStatus(undefined);\n    // Redrawing because this method has changed the RecordingState, which will\n    // affect the display of the record_page.\n    scheduleFullRedraw();\n  }\n\n  private setState(state: RecordingState) {\n    this.state = state;\n    this.stateGeneration += 1;\n  }\n\n  private getTarget(): RecordingTargetV2 {\n    assertTrue(RecordingState.TARGET_INFO_DISPLAYED === this.state);\n    return assertExists(this.target);\n  }\n\n  private getTracingSessionWrapper(): TracingSessionWrapper {\n    assertTrue(\n      RecordingState.ASK_TO_FORCE_P2 <= this.state &&\n        this.state <= RecordingState.RECORDING,\n    );\n    return assertExists(this.tracingSessionWrapper);\n  }\n}\n"]}