{"version":3,"file":"adb_connection_over_webusb.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/adb_connection_over_webusb.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer, Deferred} from '../../../base/deferred';\nimport {assertExists, assertFalse, assertTrue} from '../../../base/logging';\nimport {isString} from '../../../base/object_utils';\nimport {utf8Decode, utf8Encode} from '../../../base/string_utils';\nimport {CmdType} from '../adb_interfaces';\nimport {AdbConnectionImpl} from './adb_connection_impl';\nimport {AdbKeyManager, maybeStoreKey} from './auth/adb_key_manager';\nimport {RecordingError, wrapRecordingError} from './recording_error_handling';\nimport {\n  ByteStream,\n  OnStreamCloseCallback,\n  OnStreamDataCallback,\n} from './recording_interfaces_v2';\nimport {ALLOW_USB_DEBUGGING, findInterfaceAndEndpoint} from './recording_utils';\n\nexport const VERSION_WITH_CHECKSUM = 0x01000000;\nexport const VERSION_NO_CHECKSUM = 0x01000001;\nexport const DEFAULT_MAX_PAYLOAD_BYTES = 256 * 1024;\n\nexport enum AdbState {\n  DISCONNECTED = 0,\n  // Authentication steps, see AdbConnectionOverWebUsb's handleAuthentication().\n  AUTH_STARTED = 1,\n  AUTH_WITH_PRIVATE = 2,\n  AUTH_WITH_PUBLIC = 3,\n\n  CONNECTED = 4,\n}\n\nenum AuthCmd {\n  TOKEN = 1,\n  SIGNATURE = 2,\n  RSAPUBLICKEY = 3,\n}\n\nfunction generateChecksum(data: Uint8Array): number {\n  let res = 0;\n  for (let i = 0; i < data.byteLength; i++) res += data[i];\n  return res & 0xffffffff;\n}\n\n// Message to be written to the adb connection. Contains the message itself\n// and the corresponding stream identifier.\ninterface WriteQueueElement {\n  message: Uint8Array;\n  localStreamId: number;\n}\n\nexport class AdbConnectionOverWebusb extends AdbConnectionImpl {\n  private state: AdbState = AdbState.DISCONNECTED;\n  private connectingStreams = new Map<number, Deferred<AdbOverWebusbStream>>();\n  private streams = new Set<AdbOverWebusbStream>();\n  private maxPayload = DEFAULT_MAX_PAYLOAD_BYTES;\n  private writeInProgress = false;\n  private writeQueue: WriteQueueElement[] = [];\n\n  // Devices after Dec 2017 don't use checksum. This will be auto-detected\n  // during the connection.\n  private useChecksum = true;\n\n  private lastStreamId = 0;\n  private usbInterfaceNumber?: number;\n  private usbReadEndpoint = -1;\n  private usbWriteEpEndpoint = -1;\n  private isUsbReceiveLoopRunning = false;\n\n  private pendingConnPromises: Array<Deferred<void>> = [];\n\n  // We use a key pair for authenticating with the device, which we do in\n  // two ways:\n  // - Firstly, signing with the private key.\n  // - Secondly, sending over the public key (at which point the device asks the\n  //   user for permissions).\n  // Once we've sent the public key, for future recordings we only need to\n  // sign with the private key, so the user doesn't need to give permissions\n  // again.\n  constructor(\n    private device: USBDevice,\n    private keyManager: AdbKeyManager,\n  ) {\n    super();\n  }\n\n  shell(cmd: string): Promise<AdbOverWebusbStream> {\n    return this.openStream('shell:' + cmd);\n  }\n\n  connectSocket(path: string): Promise<AdbOverWebusbStream> {\n    return this.openStream(path);\n  }\n\n  async canConnectWithoutContention(): Promise<boolean> {\n    await this.device.open();\n    const usbInterfaceNumber = await this.setupUsbInterface();\n    try {\n      await this.device.claimInterface(usbInterfaceNumber);\n      await this.device.releaseInterface(usbInterfaceNumber);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  protected async openStream(\n    destination: string,\n  ): Promise<AdbOverWebusbStream> {\n    const streamId = ++this.lastStreamId;\n    const connectingStream = defer<AdbOverWebusbStream>();\n    this.connectingStreams.set(streamId, connectingStream);\n    // We create the stream before trying to establish the connection, so\n    // that if we fail to connect, we will reject the connecting stream.\n    await this.ensureConnectionEstablished();\n    await this.sendMessage('OPEN', streamId, 0, destination);\n    return connectingStream;\n  }\n\n  private async ensureConnectionEstablished(): Promise<void> {\n    if (this.state === AdbState.CONNECTED) {\n      return;\n    }\n\n    if (this.state === AdbState.DISCONNECTED) {\n      await this.device.open();\n      if (!(await this.canConnectWithoutContention())) {\n        await this.device.reset();\n      }\n      const usbInterfaceNumber = await this.setupUsbInterface();\n      await this.device.claimInterface(usbInterfaceNumber);\n    }\n\n    await this.startAdbAuth();\n    if (!this.isUsbReceiveLoopRunning) {\n      this.usbReceiveLoop();\n    }\n    const connPromise = defer<void>();\n    this.pendingConnPromises.push(connPromise);\n    await connPromise;\n  }\n\n  private async setupUsbInterface(): Promise<number> {\n    const interfaceAndEndpoint = findInterfaceAndEndpoint(this.device);\n    // `findInterfaceAndEndpoint` will always return a non-null value because\n    // we check for this in 'android_webusb_target_factory'. If no interface and\n    // endpoints are found, we do not create a target, so we can not connect to\n    // it, so we will never reach this logic.\n    const {configurationValue, usbInterfaceNumber, endpoints} =\n      assertExists(interfaceAndEndpoint);\n    this.usbInterfaceNumber = usbInterfaceNumber;\n    this.usbReadEndpoint = this.findEndpointNumber(endpoints, 'in');\n    this.usbWriteEpEndpoint = this.findEndpointNumber(endpoints, 'out');\n    assertTrue(this.usbReadEndpoint >= 0 && this.usbWriteEpEndpoint >= 0);\n    await this.device.selectConfiguration(configurationValue);\n    return usbInterfaceNumber;\n  }\n\n  async streamClose(stream: AdbOverWebusbStream): Promise<void> {\n    const otherStreamsQueue = this.writeQueue.filter(\n      (queueElement) => queueElement.localStreamId !== stream.localStreamId,\n    );\n    const droppedPacketCount =\n      this.writeQueue.length - otherStreamsQueue.length;\n    if (droppedPacketCount > 0) {\n      console.debug(\n        `Dropping ${droppedPacketCount} queued messages due to stream closing.`,\n      );\n      this.writeQueue = otherStreamsQueue;\n    }\n\n    this.streams.delete(stream);\n    if (this.streams.size === 0) {\n      // We disconnect BEFORE calling `signalStreamClosed`. Otherwise, there can\n      // be a race condition:\n      // Stream A: streamA.onStreamClose\n      // Stream B: device.open\n      // Stream A: device.releaseInterface\n      // Stream B: device.transferOut -> CRASH\n      await this.disconnect();\n    }\n    stream.signalStreamClosed();\n  }\n\n  streamWrite(msg: string | Uint8Array, stream: AdbOverWebusbStream): void {\n    const raw = isString(msg) ? utf8Encode(msg) : msg;\n    if (this.writeInProgress) {\n      this.writeQueue.push({message: raw, localStreamId: stream.localStreamId});\n      return;\n    }\n    this.writeInProgress = true;\n    this.sendMessage('WRTE', stream.localStreamId, stream.remoteStreamId, raw);\n  }\n\n  // We disconnect in 2 cases:\n  // 1. When we close the last stream of the connection. This is to prevent the\n  // browser holding onto the USB interface after having finished a trace\n  // recording, which would make it impossible to use \"adb shell\" from the same\n  // machine until the browser is closed.\n  // 2. When we get a USB disconnect event. This happens for instance when the\n  // device is unplugged.\n  async disconnect(disconnectMessage?: string): Promise<void> {\n    if (this.state === AdbState.DISCONNECTED) {\n      return;\n    }\n    // Clear the resources in a synchronous method, because this can be used\n    // for error handling callbacks as well.\n    this.reachDisconnectState(disconnectMessage);\n\n    // We have already disconnected so there is no need to pass a callback\n    // which clears resources or notifies the user into 'wrapRecordingError'.\n    await wrapRecordingError(\n      this.device.releaseInterface(assertExists(this.usbInterfaceNumber)),\n      () => {},\n    );\n    this.usbInterfaceNumber = undefined;\n  }\n\n  // This is a synchronous method which clears all resources.\n  // It can be used as a callback for error handling.\n  reachDisconnectState(disconnectMessage?: string): void {\n    // We need to delete the streams BEFORE checking the Adb state because:\n    //\n    // We create streams before changing the Adb state from DISCONNECTED.\n    // In case we can not claim the device, we will create a stream, but fail\n    // to connect to the WebUSB device so the state will remain DISCONNECTED.\n    const streamsToDelete = this.connectingStreams.entries();\n    // Clear the streams before rejecting so we are not caught in a loop of\n    // handling promise rejections.\n    this.connectingStreams.clear();\n    for (const [id, stream] of streamsToDelete) {\n      stream.reject(\n        `Failed to open stream with id ${id} because adb was disconnected.`,\n      );\n    }\n\n    if (this.state === AdbState.DISCONNECTED) {\n      return;\n    }\n\n    this.state = AdbState.DISCONNECTED;\n    this.writeInProgress = false;\n\n    this.writeQueue = [];\n\n    this.streams.forEach((stream) => stream.close());\n    this.onDisconnect(disconnectMessage);\n  }\n\n  private async startAdbAuth(): Promise<void> {\n    const VERSION = this.useChecksum\n      ? VERSION_WITH_CHECKSUM\n      : VERSION_NO_CHECKSUM;\n    this.state = AdbState.AUTH_STARTED;\n    await this.sendMessage('CNXN', VERSION, this.maxPayload, 'host:1:UsbADB');\n  }\n\n  private findEndpointNumber(\n    endpoints: USBEndpoint[],\n    direction: 'out' | 'in',\n    type = 'bulk',\n  ): number {\n    const ep = endpoints.find(\n      (ep) => ep.type === type && ep.direction === direction,\n    );\n\n    if (ep) return ep.endpointNumber;\n\n    throw new RecordingError(`Cannot find ${direction} endpoint`);\n  }\n\n  private async usbReceiveLoop(): Promise<void> {\n    assertFalse(this.isUsbReceiveLoopRunning);\n    this.isUsbReceiveLoopRunning = true;\n    for (; this.state !== AdbState.DISCONNECTED; ) {\n      const res = await this.wrapUsb(\n        this.device.transferIn(this.usbReadEndpoint, ADB_MSG_SIZE),\n      );\n      if (!res) {\n        this.isUsbReceiveLoopRunning = false;\n        return;\n      }\n      if (res.status !== 'ok') {\n        // Log and ignore messages with invalid status. These can occur\n        // when the device is connected/disconnected repeatedly.\n        console.error(\n          `Received message with unexpected status '${res.status}'`,\n        );\n        continue;\n      }\n\n      const msg = AdbMsg.decodeHeader(res.data!);\n      if (msg.dataLen > 0) {\n        const resp = await this.wrapUsb(\n          this.device.transferIn(this.usbReadEndpoint, msg.dataLen),\n        );\n        if (!resp) {\n          this.isUsbReceiveLoopRunning = false;\n          return;\n        }\n        msg.data = new Uint8Array(\n          resp.data!.buffer,\n          resp.data!.byteOffset,\n          resp.data!.byteLength,\n        );\n      }\n\n      if (this.useChecksum && generateChecksum(msg.data) !== msg.dataChecksum) {\n        // We ignore messages with an invalid checksum. These sometimes appear\n        // when the page is re-loaded in a middle of a recording.\n        continue;\n      }\n      // The server can still send messages streams for previous streams.\n      // This happens for instance if we record, reload the recording page and\n      // then record again. We can also receive a 'WRTE' or 'OKAY' after\n      // we have sent a 'CLSE' and marked the state as disconnected.\n      if (\n        (msg.cmd === 'CLSE' || msg.cmd === 'WRTE') &&\n        !this.getStreamForLocalStreamId(msg.arg1)\n      ) {\n        continue;\n      } else if (\n        msg.cmd === 'OKAY' &&\n        !this.connectingStreams.has(msg.arg1) &&\n        !this.getStreamForLocalStreamId(msg.arg1)\n      ) {\n        continue;\n      } else if (\n        msg.cmd === 'AUTH' &&\n        msg.arg0 === AuthCmd.TOKEN &&\n        this.state === AdbState.AUTH_WITH_PUBLIC\n      ) {\n        // If we start a recording but fail because of a faulty physical\n        // connection to the device, when we start a new recording, we will\n        // received multiple AUTH tokens, of which we should ignore all but\n        // one.\n        continue;\n      }\n\n      // handle the ADB message from the device\n      if (msg.cmd === 'CLSE') {\n        assertExists(this.getStreamForLocalStreamId(msg.arg1)).close();\n      } else if (msg.cmd === 'AUTH' && msg.arg0 === AuthCmd.TOKEN) {\n        const key = await this.keyManager.getKey();\n        if (this.state === AdbState.AUTH_STARTED) {\n          // During this step, we send back the token received signed with our\n          // private key. If the device has previously received our public key,\n          // the dialog asking for user confirmation will not be displayed on\n          // the device.\n          this.state = AdbState.AUTH_WITH_PRIVATE;\n          await this.sendMessage(\n            'AUTH',\n            AuthCmd.SIGNATURE,\n            0,\n            key.sign(msg.data),\n          );\n        } else {\n          // If our signature with the private key is not accepted by the\n          // device, we generate a new keypair and send the public key.\n          this.state = AdbState.AUTH_WITH_PUBLIC;\n          await this.sendMessage(\n            'AUTH',\n            AuthCmd.RSAPUBLICKEY,\n            0,\n            key.getPublicKey() + '\\0',\n          );\n          this.onStatus(ALLOW_USB_DEBUGGING);\n          await maybeStoreKey(key);\n        }\n      } else if (msg.cmd === 'CNXN') {\n        assertTrue(\n          [AdbState.AUTH_WITH_PRIVATE, AdbState.AUTH_WITH_PUBLIC].includes(\n            this.state,\n          ),\n        );\n        this.state = AdbState.CONNECTED;\n        this.maxPayload = msg.arg1;\n\n        const deviceVersion = msg.arg0;\n\n        if (\n          ![VERSION_WITH_CHECKSUM, VERSION_NO_CHECKSUM].includes(deviceVersion)\n        ) {\n          throw new RecordingError(`Version ${msg.arg0} not supported.`);\n        }\n        this.useChecksum = deviceVersion === VERSION_WITH_CHECKSUM;\n        this.state = AdbState.CONNECTED;\n\n        // This will resolve the promises awaited by\n        // \"ensureConnectionEstablished\".\n        this.pendingConnPromises.forEach((connPromise) =>\n          connPromise.resolve(),\n        );\n        this.pendingConnPromises = [];\n      } else if (msg.cmd === 'OKAY') {\n        if (this.connectingStreams.has(msg.arg1)) {\n          const connectingStream = assertExists(\n            this.connectingStreams.get(msg.arg1),\n          );\n          const stream = new AdbOverWebusbStream(this, msg.arg1, msg.arg0);\n          this.streams.add(stream);\n          this.connectingStreams.delete(msg.arg1);\n          connectingStream.resolve(stream);\n        } else {\n          assertTrue(this.writeInProgress);\n          this.writeInProgress = false;\n          for (; this.writeQueue.length; ) {\n            // We go through the queued writes and choose the first one\n            // corresponding to a stream that's still active.\n            const queuedElement = assertExists(this.writeQueue.shift());\n            const queuedStream = this.getStreamForLocalStreamId(\n              queuedElement.localStreamId,\n            );\n            if (queuedStream) {\n              queuedStream.write(queuedElement.message);\n              break;\n            }\n          }\n        }\n      } else if (msg.cmd === 'WRTE') {\n        const stream = assertExists(this.getStreamForLocalStreamId(msg.arg1));\n        await this.sendMessage(\n          'OKAY',\n          stream.localStreamId,\n          stream.remoteStreamId,\n        );\n        stream.signalStreamData(msg.data);\n      } else {\n        this.isUsbReceiveLoopRunning = false;\n        throw new RecordingError(\n          `Unexpected message ${msg} in state ${this.state}`,\n        );\n      }\n    }\n    this.isUsbReceiveLoopRunning = false;\n  }\n\n  private getStreamForLocalStreamId(\n    localStreamId: number,\n  ): AdbOverWebusbStream | undefined {\n    for (const stream of this.streams) {\n      if (stream.localStreamId === localStreamId) {\n        return stream;\n      }\n    }\n    return undefined;\n  }\n\n  //  The header and the message data must be sent consecutively. Using 2 awaits\n  //  Another message can interleave after the first header has been sent,\n  //  resulting in something like [header1] [header2] [data1] [data2];\n  //  In this way we are waiting both promises to be resolved before continuing.\n  private async sendMessage(\n    cmd: CmdType,\n    arg0: number,\n    arg1: number,\n    data?: Uint8Array | string,\n  ): Promise<void> {\n    const msg = AdbMsg.create({\n      cmd,\n      arg0,\n      arg1,\n      data,\n      useChecksum: this.useChecksum,\n    });\n\n    const msgHeader = msg.encodeHeader();\n    const msgData = msg.data;\n    assertTrue(\n      msgHeader.length <= this.maxPayload && msgData.length <= this.maxPayload,\n    );\n\n    const sendPromises = [\n      this.wrapUsb(\n        this.device.transferOut(this.usbWriteEpEndpoint, msgHeader.buffer),\n      ),\n    ];\n    if (msg.data.length > 0) {\n      sendPromises.push(\n        this.wrapUsb(\n          this.device.transferOut(this.usbWriteEpEndpoint, msgData.buffer),\n        ),\n      );\n    }\n    await Promise.all(sendPromises);\n  }\n\n  private wrapUsb<T>(promise: Promise<T>): Promise<T | undefined> {\n    return wrapRecordingError(promise, this.reachDisconnectState.bind(this));\n  }\n}\n\n// An AdbOverWebusbStream is instantiated after the creation of a socket to the\n// device. Thanks to this, we can send commands and receive their output.\n// Messages are received in the main adb class, and are forwarded to an instance\n// of this class based on a stream id match.\nexport class AdbOverWebusbStream implements ByteStream {\n  private adbConnection: AdbConnectionOverWebusb;\n  private _isConnected: boolean;\n  private onStreamDataCallbacks: OnStreamDataCallback[] = [];\n  private onStreamCloseCallbacks: OnStreamCloseCallback[] = [];\n  localStreamId: number;\n  remoteStreamId = -1;\n\n  constructor(\n    adb: AdbConnectionOverWebusb,\n    localStreamId: number,\n    remoteStreamId: number,\n  ) {\n    this.adbConnection = adb;\n    this.localStreamId = localStreamId;\n    this.remoteStreamId = remoteStreamId;\n    // When the stream is created, the connection has been already established.\n    this._isConnected = true;\n  }\n\n  addOnStreamDataCallback(onStreamData: OnStreamDataCallback): void {\n    this.onStreamDataCallbacks.push(onStreamData);\n  }\n\n  addOnStreamCloseCallback(onStreamClose: OnStreamCloseCallback): void {\n    this.onStreamCloseCallbacks.push(onStreamClose);\n  }\n\n  // Used by the connection object to signal newly received data, not exposed\n  // in the interface.\n  signalStreamData(data: Uint8Array): void {\n    for (const onStreamData of this.onStreamDataCallbacks) {\n      onStreamData(data);\n    }\n  }\n\n  // Used by the connection object to signal the stream is closed, not exposed\n  // in the interface.\n  signalStreamClosed(): void {\n    for (const onStreamClose of this.onStreamCloseCallbacks) {\n      onStreamClose();\n    }\n    this.onStreamDataCallbacks = [];\n    this.onStreamCloseCallbacks = [];\n  }\n\n  close(): void {\n    this.closeAndWaitForTeardown();\n  }\n\n  async closeAndWaitForTeardown(): Promise<void> {\n    this._isConnected = false;\n    await this.adbConnection.streamClose(this);\n  }\n\n  write(msg: string | Uint8Array): void {\n    this.adbConnection.streamWrite(msg, this);\n  }\n\n  isConnected(): boolean {\n    return this._isConnected;\n  }\n}\n\nconst ADB_MSG_SIZE = 6 * 4; // 6 * int32.\n\nclass AdbMsg {\n  data: Uint8Array;\n  readonly cmd: CmdType;\n  readonly arg0: number;\n  readonly arg1: number;\n  readonly dataLen: number;\n  readonly dataChecksum: number;\n  readonly useChecksum: boolean;\n\n  constructor(\n    cmd: CmdType,\n    arg0: number,\n    arg1: number,\n    dataLen: number,\n    dataChecksum: number,\n    useChecksum = false,\n  ) {\n    assertTrue(cmd.length === 4);\n    this.cmd = cmd;\n    this.arg0 = arg0;\n    this.arg1 = arg1;\n    this.dataLen = dataLen;\n    this.data = new Uint8Array(dataLen);\n    this.dataChecksum = dataChecksum;\n    this.useChecksum = useChecksum;\n  }\n\n  static create({\n    cmd,\n    arg0,\n    arg1,\n    data,\n    useChecksum = true,\n  }: {\n    cmd: CmdType;\n    arg0: number;\n    arg1: number;\n    data?: Uint8Array | string;\n    useChecksum?: boolean;\n  }): AdbMsg {\n    const encodedData = this.encodeData(data);\n    const msg = new AdbMsg(cmd, arg0, arg1, encodedData.length, 0, useChecksum);\n    msg.data = encodedData;\n    return msg;\n  }\n\n  get dataStr() {\n    return utf8Decode(this.data);\n  }\n\n  toString() {\n    return `${this.cmd} [${this.arg0},${this.arg1}] ${this.dataStr}`;\n  }\n\n  // A brief description of the message can be found here:\n  // https://android.googlesource.com/platform/system/core/+/main/adb/protocol.txt\n  //\n  // struct amessage {\n  //     uint32_t command;    // command identifier constant\n  //     uint32_t arg0;       // first argument\n  //     uint32_t arg1;       // second argument\n  //     uint32_t data_length;// length of payload (0 is allowed)\n  //     uint32_t data_check; // checksum of data payload\n  //     uint32_t magic;      // command ^ 0xffffffff\n  // };\n  static decodeHeader(dv: DataView): AdbMsg {\n    assertTrue(dv.byteLength === ADB_MSG_SIZE);\n    const cmd = utf8Decode(dv.buffer.slice(0, 4)) as CmdType;\n    const cmdNum = dv.getUint32(0, true);\n    const arg0 = dv.getUint32(4, true);\n    const arg1 = dv.getUint32(8, true);\n    const dataLen = dv.getUint32(12, true);\n    const dataChecksum = dv.getUint32(16, true);\n    const cmdChecksum = dv.getUint32(20, true);\n    assertTrue(cmdNum === (cmdChecksum ^ 0xffffffff));\n    return new AdbMsg(cmd, arg0, arg1, dataLen, dataChecksum);\n  }\n\n  encodeHeader(): Uint8Array {\n    const buf = new Uint8Array(ADB_MSG_SIZE);\n    const dv = new DataView(buf.buffer);\n    const cmdBytes: Uint8Array = utf8Encode(this.cmd);\n    const rawMsg = AdbMsg.encodeData(this.data);\n    const checksum = this.useChecksum ? generateChecksum(rawMsg) : 0;\n    for (let i = 0; i < 4; i++) dv.setUint8(i, cmdBytes[i]);\n\n    dv.setUint32(4, this.arg0, true);\n    dv.setUint32(8, this.arg1, true);\n    dv.setUint32(12, rawMsg.byteLength, true);\n    dv.setUint32(16, checksum, true);\n    dv.setUint32(20, dv.getUint32(0, true) ^ 0xffffffff, true);\n\n    return buf;\n  }\n\n  static encodeData(data?: Uint8Array | string): Uint8Array {\n    if (data === undefined) return new Uint8Array([]);\n    if (isString(data)) return utf8Encode(data + '\\0');\n    return data;\n  }\n}\n"]}