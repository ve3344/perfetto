{"version":3,"file":"android_webusb_target_factory.js","sourceRoot":"","sources":["../../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/target_factories/android_webusb_target_factory.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {getErrorMessage} from '../../../../base/errors';\nimport {assertExists} from '../../../../base/logging';\nimport {AdbKeyManager} from '../auth/adb_key_manager';\nimport {RecordingError} from '../recording_error_handling';\nimport {\n  OnTargetChangeCallback,\n  RecordingTargetV2,\n  TargetFactory,\n} from '../recording_interfaces_v2';\nimport {ADB_DEVICE_FILTER, findInterfaceAndEndpoint} from '../recording_utils';\nimport {AndroidWebusbTarget} from '../targets/android_webusb_target';\n\nexport const ANDROID_WEBUSB_TARGET_FACTORY = 'AndroidWebusbTargetFactory';\nconst SERIAL_NUMBER_ISSUE = 'an invalid serial number';\nconst ADB_INTERFACE_ISSUE = 'an incompatible adb interface';\n\ninterface DeviceValidity {\n  isValid: boolean;\n  issues: string[];\n}\n\nfunction createDeviceErrorMessage(device: USBDevice, issue: string): string {\n  const productName = device.productName;\n  return `USB device${productName ? ' ' + productName : ''} has ${issue}`;\n}\n\nexport class AndroidWebusbTargetFactory implements TargetFactory {\n  readonly kind = ANDROID_WEBUSB_TARGET_FACTORY;\n  onTargetChange: OnTargetChangeCallback = () => {};\n  private recordingProblems: string[] = [];\n  private targets: Map<string, AndroidWebusbTarget> = new Map<\n    string,\n    AndroidWebusbTarget\n  >();\n  // AdbKeyManager should only be instantiated once, so we can use the same key\n  // for all devices.\n  private keyManager: AdbKeyManager = new AdbKeyManager();\n\n  constructor(private usb: USB) {\n    this.init();\n  }\n\n  getName() {\n    return 'Android WebUsb';\n  }\n\n  listTargets(): RecordingTargetV2[] {\n    return Array.from(this.targets.values());\n  }\n\n  listRecordingProblems(): string[] {\n    return this.recordingProblems;\n  }\n\n  async connectNewTarget(): Promise<RecordingTargetV2> {\n    let device: USBDevice;\n    try {\n      device = await this.usb.requestDevice({filters: [ADB_DEVICE_FILTER]});\n    } catch (e) {\n      throw new RecordingError(getErrorMessage(e));\n    }\n\n    const deviceValid = this.checkDeviceValidity(device);\n    if (!deviceValid.isValid) {\n      throw new RecordingError(deviceValid.issues.join('\\n'));\n    }\n\n    const androidTarget = new AndroidWebusbTarget(\n      device,\n      this.keyManager,\n      this.onTargetChange,\n    );\n    this.targets.set(assertExists(device.serialNumber), androidTarget);\n    return androidTarget;\n  }\n\n  setOnTargetChange(onTargetChange: OnTargetChangeCallback) {\n    this.onTargetChange = onTargetChange;\n  }\n\n  private async init() {\n    let devices: USBDevice[] = [];\n    try {\n      devices = await this.usb.getDevices();\n    } catch (_) {\n      return; // WebUSB not available or disallowed in iframe.\n    }\n\n    for (const device of devices) {\n      if (this.checkDeviceValidity(device).isValid) {\n        this.targets.set(\n          assertExists(device.serialNumber),\n          new AndroidWebusbTarget(device, this.keyManager, this.onTargetChange),\n        );\n      }\n    }\n\n    this.usb.addEventListener('connect', (ev: USBConnectionEvent) => {\n      if (this.checkDeviceValidity(ev.device).isValid) {\n        this.targets.set(\n          assertExists(ev.device.serialNumber),\n          new AndroidWebusbTarget(\n            ev.device,\n            this.keyManager,\n            this.onTargetChange,\n          ),\n        );\n        this.onTargetChange();\n      }\n    });\n\n    this.usb.addEventListener('disconnect', async (ev: USBConnectionEvent) => {\n      // We don't check device validity when disconnecting because if the device\n      // is invalid we would not have connected in the first place.\n      const serialNumber = assertExists(ev.device.serialNumber);\n      await assertExists(this.targets.get(serialNumber)).disconnect(\n        `Device with serial ${serialNumber} was disconnected.`,\n      );\n      this.targets.delete(serialNumber);\n      this.onTargetChange();\n    });\n  }\n\n  private checkDeviceValidity(device: USBDevice): DeviceValidity {\n    const deviceValidity: DeviceValidity = {isValid: true, issues: []};\n    if (!device.serialNumber) {\n      deviceValidity.issues.push(\n        createDeviceErrorMessage(device, SERIAL_NUMBER_ISSUE),\n      );\n      deviceValidity.isValid = false;\n    }\n    if (!findInterfaceAndEndpoint(device)) {\n      deviceValidity.issues.push(\n        createDeviceErrorMessage(device, ADB_INTERFACE_ISSUE),\n      );\n      deviceValidity.isValid = false;\n    }\n    this.recordingProblems.push(...deviceValidity.issues);\n    return deviceValidity;\n  }\n}\n"]}