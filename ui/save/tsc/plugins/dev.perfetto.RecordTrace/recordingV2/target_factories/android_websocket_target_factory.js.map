{"version":3,"file":"android_websocket_target_factory.js","sourceRoot":"","sources":["../../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/target_factories/android_websocket_target_factory.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  OnTargetChangeCallback,\n  RecordingTargetV2,\n  TargetFactory,\n} from '../recording_interfaces_v2';\nimport {\n  buildAbdWebsocketCommand,\n  WEBSOCKET_CLOSED_ABNORMALLY_CODE,\n} from '../recording_utils';\nimport {AndroidWebsocketTarget} from '../targets/android_websocket_target';\n\nexport const ANDROID_WEBSOCKET_TARGET_FACTORY = 'AndroidWebsocketTargetFactory';\n\n// https://cs.android.com/android/platform/superproject/+/main:packages/\n// modules/adb/SERVICES.TXT;l=135\nconst PREFIX_LENGTH = 4;\n\n// information received over the websocket regarding a device\n// Ex: \"${serialNumber} authorized\"\ninterface ListedDevice {\n  serialNumber: string;\n  // Full list of connection states can be seen at:\n  // go/codesearch/android/packages/modules/adb/adb.cpp;l=115-139\n  connectionState: string;\n}\n\n// Contains the result of parsing a message received over websocket.\ninterface ParsingResult {\n  listedDevices: ListedDevice[];\n  messageRemainder: string;\n}\n\n// We issue the command 'track-devices' which will encode the short form\n// of the device:\n// see go/codesearch/android/packages/modules/adb/services.cpp;l=244-245\n// and go/codesearch/android/packages/modules/adb/transport.cpp;l=1417-1420\n// Therefore a line will contain solely the device serial number and the\n// connectionState (and no other properties).\nfunction parseListedDevice(line: string): ListedDevice | undefined {\n  const parts = line.split('\\t');\n  if (parts.length === 2) {\n    return {\n      serialNumber: parts[0],\n      connectionState: parts[1],\n    };\n  }\n  return undefined;\n}\n\nexport function parseWebsocketResponse(message: string): ParsingResult {\n  // A response we receive on the websocket contains multiple messages:\n  // \"{m1.length}{m1.payload}{m2.length}{m2.payload}...\"\n  // where m1, m2 are messages\n  // Each message has the form:\n  // \"{message.length}SN1\\t${connectionState1}\\nSN2\\t${connectionState2}\\n...\"\n  // where SN1, SN2 are device serial numbers\n  // and connectionState1, connectionState2 are adb connection states, created\n  // here: go/codesearch/android/packages/modules/adb/adb.cpp;l=115-139\n  const latestStatusByDevice: Map<string, string> = new Map();\n  while (message.length >= PREFIX_LENGTH) {\n    const payloadLength = parseInt(message.substring(0, PREFIX_LENGTH), 16);\n    const prefixAndPayloadLength = PREFIX_LENGTH + payloadLength;\n    if (message.length < prefixAndPayloadLength) {\n      break;\n    }\n\n    const payload = message.substring(PREFIX_LENGTH, prefixAndPayloadLength);\n    for (const line of payload.split('\\n')) {\n      const listedDevice = parseListedDevice(line);\n      if (listedDevice) {\n        // We overwrite previous states for the same serial number.\n        latestStatusByDevice.set(\n          listedDevice.serialNumber,\n          listedDevice.connectionState,\n        );\n      }\n    }\n    message = message.substring(prefixAndPayloadLength);\n  }\n  const listedDevices: ListedDevice[] = [];\n  for (const [\n    serialNumber,\n    connectionState,\n  ] of latestStatusByDevice.entries()) {\n    listedDevices.push({serialNumber, connectionState});\n  }\n  return {listedDevices, messageRemainder: message};\n}\n\nexport class WebsocketConnection {\n  private targets: Map<string, AndroidWebsocketTarget> = new Map<\n    string,\n    AndroidWebsocketTarget\n  >();\n  private pendingData: string = '';\n\n  constructor(\n    private websocket: WebSocket,\n    private maybeClearConnection: (connection: WebsocketConnection) => void,\n    private onTargetChange: OnTargetChangeCallback,\n  ) {\n    this.initWebsocket();\n  }\n\n  listTargets(): RecordingTargetV2[] {\n    return Array.from(this.targets.values());\n  }\n\n  // Setup websocket callbacks.\n  initWebsocket(): void {\n    this.websocket.onclose = (ev: CloseEvent) => {\n      if (ev.code === WEBSOCKET_CLOSED_ABNORMALLY_CODE) {\n        console.info(\n          `It's safe to ignore the 'WebSocket connection to ${this.websocket.url} error above, if present. It occurs when ` +\n            'checking the connection to the local Websocket server.',\n        );\n      }\n      this.maybeClearConnection(this);\n      this.close();\n    };\n\n    // once the websocket is open, we start tracking the devices\n    this.websocket.onopen = () => {\n      this.websocket.send(buildAbdWebsocketCommand('host:track-devices'));\n    };\n\n    this.websocket.onmessage = async (evt: MessageEvent) => {\n      let resp = await evt.data.text();\n      if (resp.substr(0, 4) === 'OKAY') {\n        resp = resp.substr(4);\n      }\n      const parsingResult = parseWebsocketResponse(this.pendingData + resp);\n      this.pendingData = parsingResult.messageRemainder;\n      this.trackDevices(parsingResult.listedDevices);\n    };\n  }\n\n  close() {\n    // The websocket connection may have already been closed by the websocket\n    // server.\n    if (this.websocket.readyState === this.websocket.OPEN) {\n      this.websocket.close();\n    }\n    // Disconnect all the targets, to release all the websocket connections that\n    // they hold and end their tracing sessions.\n    for (const target of this.targets.values()) {\n      target.disconnect();\n    }\n    this.targets.clear();\n\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (this.onTargetChange) {\n      this.onTargetChange();\n    }\n  }\n\n  getUrl() {\n    return this.websocket.url;\n  }\n\n  // Handle messages received over the websocket regarding devices connecting\n  // or disconnecting.\n  private trackDevices(listedDevices: ListedDevice[]) {\n    // When a SN becomes offline, we should remove it from the list\n    // of targets. Otherwise, we should check if it maps to a target. If the\n    // SN does not map to a target, we should create one for it.\n    let targetsUpdated = false;\n    for (const listedDevice of listedDevices) {\n      if (['offline', 'unknown'].includes(listedDevice.connectionState)) {\n        const target = this.targets.get(listedDevice.serialNumber);\n        if (target === undefined) {\n          continue;\n        }\n        target.disconnect();\n        this.targets.delete(listedDevice.serialNumber);\n        targetsUpdated = true;\n      } else if (!this.targets.has(listedDevice.serialNumber)) {\n        this.targets.set(\n          listedDevice.serialNumber,\n          new AndroidWebsocketTarget(\n            listedDevice.serialNumber,\n            this.websocket.url,\n            this.onTargetChange,\n          ),\n        );\n        targetsUpdated = true;\n      }\n    }\n\n    // Notify the calling code that the list of targets has been updated.\n    if (targetsUpdated) {\n      this.onTargetChange();\n    }\n  }\n}\n\nexport class AndroidWebsocketTargetFactory implements TargetFactory {\n  readonly kind = ANDROID_WEBSOCKET_TARGET_FACTORY;\n  private onTargetChange: OnTargetChangeCallback = () => {};\n  private websocketConnection?: WebsocketConnection;\n\n  getName() {\n    return 'Android Websocket';\n  }\n\n  listTargets(): RecordingTargetV2[] {\n    return this.websocketConnection\n      ? this.websocketConnection.listTargets()\n      : [];\n  }\n\n  listRecordingProblems(): string[] {\n    return [];\n  }\n\n  // This interface method can not return anything because a websocket target\n  // can not be created on user input. It can only be created when the websocket\n  // server detects a new target.\n  connectNewTarget(): Promise<RecordingTargetV2> {\n    return Promise.reject(\n      new Error(\n        'The websocket can only automatically connect targets ' +\n          'when they become available.',\n      ),\n    );\n  }\n\n  tryEstablishWebsocket(websocketUrl: string) {\n    if (this.websocketConnection) {\n      if (this.websocketConnection.getUrl() === websocketUrl) {\n        return;\n      } else {\n        this.websocketConnection.close();\n      }\n    }\n\n    const websocket = new WebSocket(websocketUrl);\n    this.websocketConnection = new WebsocketConnection(\n      websocket,\n      this.maybeClearConnection,\n      this.onTargetChange,\n    );\n  }\n\n  maybeClearConnection(connection: WebsocketConnection): void {\n    if (this.websocketConnection === connection) {\n      this.websocketConnection = undefined;\n    }\n  }\n\n  setOnTargetChange(onTargetChange: OnTargetChangeCallback) {\n    this.onTargetChange = onTargetChange;\n  }\n}\n"]}