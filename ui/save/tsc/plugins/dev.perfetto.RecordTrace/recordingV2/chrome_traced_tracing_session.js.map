{"version":3,"file":"chrome_traced_tracing_session.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/chrome_traced_tracing_session.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer, Deferred} from '../../../base/deferred';\nimport {assertExists, assertTrue} from '../../../base/logging';\nimport {binaryDecode, binaryEncode} from '../../../base/string_utils';\nimport {\n  ChromeExtensionMessage,\n  isChromeExtensionError,\n  isChromeExtensionStatus,\n  isGetCategoriesResponse,\n} from '../chrome_proxy_record_controller';\nimport {\n  isDisableTracingResponse,\n  isEnableTracingResponse,\n  isFreeBuffersResponse,\n  isGetTraceStatsResponse,\n  isReadBuffersResponse,\n} from '../consumer_port_types';\nimport {\n  EnableTracingRequest,\n  IBufferStats,\n  ISlice,\n  TraceConfig,\n} from '../protos';\nimport {RecordingError} from './recording_error_handling';\nimport {\n  TracingSession,\n  TracingSessionListener,\n} from './recording_interfaces_v2';\nimport {\n  BUFFER_USAGE_INCORRECT_FORMAT,\n  BUFFER_USAGE_NOT_ACCESSIBLE,\n  EXTENSION_ID,\n  MALFORMED_EXTENSION_MESSAGE,\n} from './recording_utils';\n\n// This class implements the protocol described in\n// https://perfetto.dev/docs/design-docs/api-and-abi#tracing-protocol-abi\n// However, with the Chrome extension we communicate using JSON messages.\nexport class ChromeTracedTracingSession implements TracingSession {\n  // Needed for ReadBufferResponse: all the trace packets are split into\n  // several slices. |partialPacket| is the buffer for them. Once we receive a\n  // slice with the flag |lastSliceForPacket|, a new packet is created.\n  private partialPacket: ISlice[] = [];\n\n  // For concurrent calls to 'GetCategories', we return the same value.\n  private pendingGetCategoriesMessage?: Deferred<string[]>;\n\n  private pendingStatsMessages = new Array<Deferred<IBufferStats[]>>();\n\n  // Port through which we communicate with the extension.\n  private chromePort: chrome.runtime.Port;\n  // True when Perfetto is connected via the port to the tracing session.\n  private isPortConnected: boolean;\n\n  constructor(private tracingSessionListener: TracingSessionListener) {\n    this.chromePort = chrome.runtime.connect(EXTENSION_ID);\n    this.isPortConnected = true;\n  }\n\n  start(config: TraceConfig): void {\n    if (!this.isPortConnected) return;\n    const duration = config.durationMs;\n    this.tracingSessionListener.onStatus(\n      `Recording in progress${\n        duration ? ' for ' + duration.toString() + ' ms' : ''\n      }...`,\n    );\n\n    const enableTracingRequest = new EnableTracingRequest();\n    enableTracingRequest.traceConfig = config;\n    const enableTracingRequestProto = binaryEncode(\n      EnableTracingRequest.encode(enableTracingRequest).finish(),\n    );\n    this.chromePort.postMessage({\n      method: 'EnableTracing',\n      requestData: enableTracingRequestProto,\n    });\n  }\n\n  // The 'cancel' method will end the tracing session and will NOT return the\n  // trace. Therefore, we do not need to keep the connection open.\n  cancel(): void {\n    if (!this.isPortConnected) return;\n    this.terminateConnection();\n  }\n\n  // The 'stop' method will end the tracing session and cause the trace to be\n  // returned via a callback. We maintain the connection to the target so we can\n  // extract the trace.\n  // See 'DisableTracing' in:\n  // https://perfetto.dev/docs/design-docs/life-of-a-tracing-session\n  stop(): void {\n    if (!this.isPortConnected) return;\n    this.chromePort.postMessage({method: 'DisableTracing'});\n  }\n\n  getCategories(): Promise<string[]> {\n    if (!this.isPortConnected) {\n      throw new RecordingError(\n        'Attempting to get categories from a ' +\n          'disconnected tracing session.',\n      );\n    }\n    if (this.pendingGetCategoriesMessage) {\n      return this.pendingGetCategoriesMessage;\n    }\n\n    this.chromePort.postMessage({method: 'GetCategories'});\n    return (this.pendingGetCategoriesMessage = defer<string[]>());\n  }\n\n  async getTraceBufferUsage(): Promise<number> {\n    if (!this.isPortConnected) return 0;\n    const bufferStats = await this.getBufferStats();\n    let percentageUsed = -1;\n    for (const buffer of bufferStats) {\n      const used = assertExists(buffer.bytesWritten);\n      const total = assertExists(buffer.bufferSize);\n      if (total >= 0) {\n        percentageUsed = Math.max(percentageUsed, used / total);\n      }\n    }\n\n    if (percentageUsed === -1) {\n      throw new RecordingError(BUFFER_USAGE_INCORRECT_FORMAT);\n    }\n    return percentageUsed;\n  }\n\n  initConnection(): void {\n    this.chromePort.onMessage.addListener((message: ChromeExtensionMessage) => {\n      this.handleExtensionMessage(message);\n    });\n  }\n\n  private getBufferStats(): Promise<IBufferStats[]> {\n    this.chromePort.postMessage({method: 'GetTraceStats'});\n\n    const statsMessage = defer<IBufferStats[]>();\n    this.pendingStatsMessages.push(statsMessage);\n    return statsMessage;\n  }\n\n  private terminateConnection(): void {\n    this.chromePort.postMessage({method: 'FreeBuffers'});\n    this.clearState();\n  }\n\n  private clearState() {\n    this.chromePort.disconnect();\n    this.isPortConnected = false;\n    for (const statsMessage of this.pendingStatsMessages) {\n      statsMessage.reject(new RecordingError(BUFFER_USAGE_NOT_ACCESSIBLE));\n    }\n    this.pendingStatsMessages = [];\n    this.pendingGetCategoriesMessage = undefined;\n  }\n\n  private handleExtensionMessage(message: ChromeExtensionMessage) {\n    if (isChromeExtensionError(message)) {\n      this.terminateConnection();\n      this.tracingSessionListener.onError(message.error);\n    } else if (isChromeExtensionStatus(message)) {\n      this.tracingSessionListener.onStatus(message.status);\n    } else if (isReadBuffersResponse(message)) {\n      if (!message.slices) {\n        return;\n      }\n      for (const messageSlice of message.slices) {\n        // The extension sends the binary data as a string.\n        // see http://shortn/_oPmO2GT6Vb\n        if (typeof messageSlice.data !== 'string') {\n          throw new RecordingError(MALFORMED_EXTENSION_MESSAGE);\n        }\n        const decodedSlice = {\n          data: binaryDecode(messageSlice.data),\n        };\n        this.partialPacket.push(decodedSlice);\n        if (messageSlice.lastSliceForPacket) {\n          let bufferSize = 0;\n          for (const slice of this.partialPacket) {\n            bufferSize += slice.data!.length;\n          }\n\n          const completeTrace = new Uint8Array(bufferSize);\n          let written = 0;\n          for (const slice of this.partialPacket) {\n            const data = slice.data!;\n            completeTrace.set(data, written);\n            written += data.length;\n          }\n          // The trace already comes encoded as a proto.\n          this.tracingSessionListener.onTraceData(completeTrace);\n          this.terminateConnection();\n        }\n      }\n    } else if (isGetCategoriesResponse(message)) {\n      assertExists(this.pendingGetCategoriesMessage).resolve(\n        message.categories,\n      );\n      this.pendingGetCategoriesMessage = undefined;\n    } else if (isEnableTracingResponse(message)) {\n      // Once the service notifies us that a tracing session is enabled,\n      // we can start streaming the response using 'ReadBuffers'.\n      this.chromePort.postMessage({method: 'ReadBuffers'});\n    } else if (isGetTraceStatsResponse(message)) {\n      const maybePendingStatsMessage = this.pendingStatsMessages.shift();\n      if (maybePendingStatsMessage) {\n        maybePendingStatsMessage.resolve(\n          message?.traceStats?.bufferStats || [],\n        );\n      }\n    } else if (isFreeBuffersResponse(message)) {\n      // No action required. If we successfully read a whole trace,\n      // we close the connection. Alternatively, if the tracing finishes\n      // with an exception or if the user cancels it, we also close the\n      // connection.\n    } else {\n      assertTrue(isDisableTracingResponse(message));\n      // No action required. Same reasoning as for FreeBuffers.\n    }\n  }\n}\n"]}