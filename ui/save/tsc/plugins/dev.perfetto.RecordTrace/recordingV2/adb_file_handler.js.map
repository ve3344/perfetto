{"version":3,"file":"adb_file_handler.js","sourceRoot":"","sources":["../../../../../src/plugins/dev.perfetto.RecordTrace/recordingV2/adb_file_handler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2022 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer, Deferred} from '../../../base/deferred';\nimport {assertFalse} from '../../../base/logging';\nimport {ArrayBufferBuilder} from '../../../base/array_buffer_builder';\nimport {RecordingError} from './recording_error_handling';\nimport {ByteStream} from './recording_interfaces_v2';\nimport {\n  BINARY_PUSH_FAILURE,\n  BINARY_PUSH_UNKNOWN_RESPONSE,\n} from './recording_utils';\nimport {utf8Decode} from '../../../base/string_utils';\n\n// https://cs.android.com/android/platform/superproject/+/main:packages/\n// modules/adb/file_sync_protocol.h;l=144\nconst MAX_SYNC_SEND_CHUNK_SIZE = 64 * 1024;\n\n// Adb does not accurately send some file permissions. If you need a special set\n// of permissions, do not rely on this value. Rather, send a shell command which\n// explicitly sets permissions, such as:\n// 'shell:chmod ${permissions} ${path}'\nconst FILE_PERMISSIONS = 2 ** 15 + 0o644;\n\n// For details about the protocol, see:\n// https://cs.android.com/android/platform/superproject/+/main:packages/modules/adb/SYNC.TXT\nexport class AdbFileHandler {\n  private sentByteCount = 0;\n  private isPushOngoing: boolean = false;\n\n  constructor(private byteStream: ByteStream) {}\n\n  async pushBinary(binary: Uint8Array, path: string): Promise<void> {\n    // For a given byteStream, we only support pushing one binary at a time.\n    assertFalse(this.isPushOngoing);\n    this.isPushOngoing = true;\n    const transferFinished = defer<void>();\n\n    this.byteStream.addOnStreamDataCallback((data) =>\n      this.onStreamData(data, transferFinished),\n    );\n    this.byteStream.addOnStreamCloseCallback(\n      () => (this.isPushOngoing = false),\n    );\n\n    const sendMessage = new ArrayBufferBuilder();\n    // 'SEND' is the API method used to send a file to device.\n    sendMessage.append('SEND');\n    // The remote file name is split into two parts separated by the last\n    // comma (\",\"). The first part is the actual path, while the second is a\n    // decimal encoded file mode containing the permissions of the file on\n    // device.\n    sendMessage.append(path.length + 6);\n    sendMessage.append(path);\n    sendMessage.append(',');\n    sendMessage.append(FILE_PERMISSIONS.toString());\n    this.byteStream.write(new Uint8Array(sendMessage.toArrayBuffer()));\n\n    while (!(await this.sendNextDataChunk(binary)));\n\n    return transferFinished;\n  }\n\n  private onStreamData(data: Uint8Array, transferFinished: Deferred<void>) {\n    this.sentByteCount = 0;\n    const response = utf8Decode(data);\n    if (response.split('\\n')[0].includes('FAIL')) {\n      // Sample failure response (when the file is transferred successfully\n      // but the date is not formatted correctly):\n      // 'OKAYFAIL\\npath too long'\n      transferFinished.reject(\n        new RecordingError(`${BINARY_PUSH_FAILURE}: ${response}`),\n      );\n    } else if (utf8Decode(data).substring(0, 4) === 'OKAY') {\n      // In case of success, the server responds to the last request with\n      // 'OKAY'.\n      transferFinished.resolve();\n    } else {\n      throw new RecordingError(`${BINARY_PUSH_UNKNOWN_RESPONSE}: ${response}`);\n    }\n  }\n\n  private async sendNextDataChunk(binary: Uint8Array): Promise<boolean> {\n    const endPosition = Math.min(\n      this.sentByteCount + MAX_SYNC_SEND_CHUNK_SIZE,\n      binary.byteLength,\n    );\n    const chunk = await binary.slice(this.sentByteCount, endPosition);\n    // The file is sent in chunks. Each chunk is prefixed with \"DATA\" and the\n    // chunk length. This is repeated until the entire file is transferred. Each\n    // chunk must not be larger than 64k.\n    const chunkLength = chunk.byteLength;\n    const dataMessage = new ArrayBufferBuilder();\n    dataMessage.append('DATA');\n    dataMessage.append(chunkLength);\n    dataMessage.append(\n      new Uint8Array(chunk.buffer, chunk.byteOffset, chunkLength),\n    );\n\n    this.sentByteCount += chunkLength;\n    const isDone = this.sentByteCount === binary.byteLength;\n\n    if (isDone) {\n      // When the file is transferred a sync request \"DONE\" is sent, together\n      // with a timestamp, representing the last modified time for the file. The\n      // server responds to this last request.\n      dataMessage.append('DONE');\n      // We send the date in seconds.\n      dataMessage.append(Math.floor(Date.now() / 1000));\n    }\n    this.byteStream.write(new Uint8Array(dataMessage.toArrayBuffer()));\n    return isDone;\n  }\n}\n"]}