{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugins/dev.perfetto.AsyncSlices/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {removeFalsyValues} from '../../base/array_utils';\nimport {TrackNode} from '../../public/workspace';\nimport {SLICE_TRACK_KIND} from '../../public/track_kinds';\nimport {Trace} from '../../public/trace';\nimport {PerfettoPlugin} from '../../public/plugin';\nimport {getThreadUriPrefix, getTrackName} from '../../public/utils';\nimport {NUM, NUM_NULL, STR, STR_NULL} from '../../trace_processor/query_result';\nimport {AsyncSliceTrack} from './async_slice_track';\nimport {exists} from '../../base/utils';\nimport {assertExists, assertTrue} from '../../base/logging';\nimport {SliceSelectionAggregator} from './slice_selection_aggregator';\nimport ProcessThreadGroupsPlugin from '../dev.perfetto.ProcessThreadGroups';\n\nexport default class implements PerfettoPlugin {\n  static readonly id = 'dev.perfetto.AsyncSlices';\n  static readonly dependencies = [ProcessThreadGroupsPlugin];\n\n  async onTraceLoad(ctx: Trace): Promise<void> {\n    const trackIdsToUris = new Map<number, string>();\n\n    await this.addGlobalAsyncTracks(ctx, trackIdsToUris);\n    await this.addProcessAsyncSliceTracks(ctx, trackIdsToUris);\n    await this.addThreadAsyncSliceTracks(ctx, trackIdsToUris);\n\n    ctx.selection.registerSqlSelectionResolver({\n      sqlTableName: 'slice',\n      callback: async (id: number) => {\n        // Locate the track for a given id in the slice table\n        const result = await ctx.engine.query(`\n          select\n            track_id as trackId\n          from\n            slice\n          where slice.id = ${id}\n        `);\n\n        if (result.numRows() === 0) {\n          return undefined;\n        }\n\n        const {trackId} = result.firstRow({\n          trackId: NUM,\n        });\n\n        const trackUri = trackIdsToUris.get(trackId);\n        if (!trackUri) {\n          return undefined;\n        }\n\n        return {\n          trackUri,\n          eventId: id,\n        };\n      },\n    });\n\n    ctx.selection.registerAreaSelectionAggregator(\n      new SliceSelectionAggregator(),\n    );\n  }\n\n  async addGlobalAsyncTracks(\n    ctx: Trace,\n    trackIdsToUris: Map<number, string>,\n  ): Promise<void> {\n    const {engine} = ctx;\n    const rawGlobalAsyncTracks = await engine.query(`\n      include perfetto module graphs.search;\n      include perfetto module viz.summary.tracks;\n\n      with global_tracks_grouped as (\n        select\n          t.parent_id,\n          t.name,\n          group_concat(t.id) as trackIds,\n          count() as trackCount,\n          ifnull(min(a.order_id), 0) as order_id\n        from track t\n        join _slice_track_summary s using (id)\n        left join _track_event_tracks_ordered a USING (id)\n        where\n          s.is_legacy_global\n          and (name != 'Suspend/Resume Latency' or name is null)\n        group by parent_id, name\n        order by parent_id, order_id\n      ),\n      intermediate_groups as (\n        select\n          t.name,\n          t.id,\n          t.parent_id,\n          ifnull(a.order_id, 0) as order_id\n        from graph_reachable_dfs!(\n          (\n            select id as source_node_id, parent_id as dest_node_id\n            from track\n            where parent_id is not null\n          ),\n          (\n            select distinct parent_id as node_id\n            from global_tracks_grouped\n            where parent_id is not null\n          )\n        ) g\n        join track t on g.node_id = t.id\n        left join _track_event_tracks_ordered a USING (id)\n      )\n      select\n        t.name as name,\n        t.parent_id as parentId,\n        t.trackIds as trackIds,\n        t.order_id as orderId,\n        __max_layout_depth(t.trackCount, t.trackIds) as maxDepth\n      from global_tracks_grouped t\n      union all\n      select\n        t.name as name,\n        t.parent_id as parentId,\n        cast_string!(t.id) as trackIds,\n        t.order_id as orderId,\n        NULL as maxDepth\n      from intermediate_groups t\n      left join _slice_track_summary s using (id)\n      where s.id is null\n      order by parentId, orderId\n    `);\n    const it = rawGlobalAsyncTracks.iter({\n      name: STR_NULL,\n      parentId: NUM_NULL,\n      trackIds: STR,\n      orderId: NUM,\n      maxDepth: NUM_NULL,\n    });\n\n    // Create a map of track nodes by id\n    const trackMap = new Map<\n      number,\n      {parentId: number | null; trackNode: TrackNode}\n    >();\n\n    for (; it.valid(); it.next()) {\n      const rawName = it.name === null ? undefined : it.name;\n      const title = getTrackName({\n        name: rawName,\n        kind: SLICE_TRACK_KIND,\n      });\n      const rawTrackIds = it.trackIds;\n      const trackIds = rawTrackIds.split(',').map((v) => Number(v));\n      const maxDepth = it.maxDepth;\n\n      if (maxDepth === null) {\n        assertTrue(trackIds.length == 1);\n        const trackNode = new TrackNode({title, sortOrder: -25});\n        trackMap.set(trackIds[0], {parentId: it.parentId, trackNode});\n      } else {\n        const uri = `/async_slices_${rawName}_${it.parentId}`;\n        ctx.tracks.registerTrack({\n          uri,\n          title,\n          tags: {\n            trackIds,\n            kind: SLICE_TRACK_KIND,\n            scope: 'global',\n          },\n          track: new AsyncSliceTrack(ctx, uri, maxDepth, trackIds),\n        });\n        const trackNode = new TrackNode({\n          uri,\n          title,\n          sortOrder: it.orderId,\n        });\n        trackIds.forEach((id) => {\n          trackMap.set(id, {parentId: it.parentId, trackNode});\n          trackIdsToUris.set(id, uri);\n        });\n      }\n    }\n\n    // Attach track nodes to parents / or the workspace if they have no parent\n    trackMap.forEach(({parentId, trackNode}) => {\n      if (exists(parentId)) {\n        const parent = assertExists(trackMap.get(parentId));\n        parent.trackNode.addChildInOrder(trackNode);\n      } else {\n        ctx.workspace.addChildInOrder(trackNode);\n      }\n    });\n  }\n\n  async addCpuTracks(\n    ctx: Trace,\n    trackIdsToUris: Map<number, string>,\n  ): Promise<void> {\n    const {engine} = ctx;\n    const res = await engine.query(`\n      include perfetto module viz.summary.tracks;\n\n      with global_tracks_grouped as (\n        select\n          t.name,\n          group_concat(t.id) as trackIds,\n          count() as trackCount\n        from cpu_track t\n        join _slice_track_summary using (id)\n        group by name\n      )\n      select\n        t.name as name,\n        t.trackIds as trackIds,\n        __max_layout_depth(t.trackCount, t.trackIds) as maxDepth\n      from global_tracks_grouped t\n    `);\n    const it = res.iter({\n      name: STR_NULL,\n      trackIds: STR,\n      maxDepth: NUM,\n    });\n\n    for (; it.valid(); it.next()) {\n      const rawName = it.name === null ? undefined : it.name;\n      const title = getTrackName({\n        name: rawName,\n        kind: SLICE_TRACK_KIND,\n      });\n      const rawTrackIds = it.trackIds;\n      const trackIds = rawTrackIds.split(',').map((v) => Number(v));\n      const maxDepth = it.maxDepth;\n\n      const uri = `/cpu_slices_${rawName}`;\n      ctx.tracks.registerTrack({\n        uri,\n        title,\n        tags: {\n          trackIds,\n          kind: SLICE_TRACK_KIND,\n          scope: 'global',\n        },\n        track: new AsyncSliceTrack(ctx, uri, maxDepth, trackIds),\n      });\n      const trackNode = new TrackNode({\n        uri,\n        title,\n      });\n      ctx.workspace.addChildInOrder(trackNode);\n      trackIds.forEach((id) => {\n        trackIdsToUris.set(id, uri);\n      });\n    }\n  }\n\n  async addProcessAsyncSliceTracks(\n    ctx: Trace,\n    trackIdsToUris: Map<number, string>,\n  ): Promise<void> {\n    const result = await ctx.engine.query(`\n      select\n        upid,\n        t.name as trackName,\n        t.track_ids as trackIds,\n        process.name as processName,\n        process.pid as pid,\n        t.parent_id as parentId,\n        __max_layout_depth(t.track_count, t.track_ids) as maxDepth\n      from _process_track_summary_by_upid_and_parent_id_and_name t\n      join process using (upid)\n      where t.name is null or t.name not glob \"* Timeline\"\n    `);\n\n    const it = result.iter({\n      upid: NUM,\n      parentId: NUM_NULL,\n      trackName: STR_NULL,\n      trackIds: STR,\n      processName: STR_NULL,\n      pid: NUM_NULL,\n      maxDepth: NUM,\n    });\n\n    const trackMap = new Map<\n      number,\n      {parentId: number | null; upid: number; trackNode: TrackNode}\n    >();\n\n    for (; it.valid(); it.next()) {\n      const upid = it.upid;\n      const trackName = it.trackName;\n      const rawTrackIds = it.trackIds;\n      const trackIds = rawTrackIds.split(',').map((v) => Number(v));\n      const processName = it.processName;\n      const pid = it.pid;\n      const maxDepth = it.maxDepth;\n\n      const kind = SLICE_TRACK_KIND;\n      const title = getTrackName({\n        name: trackName,\n        upid,\n        pid,\n        processName,\n        kind,\n      });\n\n      const uri = `/process_${upid}/async_slices_${rawTrackIds}`;\n      ctx.tracks.registerTrack({\n        uri,\n        title,\n        tags: {\n          trackIds,\n          kind: SLICE_TRACK_KIND,\n          scope: 'process',\n          upid,\n        },\n        track: new AsyncSliceTrack(ctx, uri, maxDepth, trackIds),\n      });\n      const track = new TrackNode({uri, title, sortOrder: 30});\n      trackIds.forEach((id) => {\n        trackMap.set(id, {trackNode: track, parentId: it.parentId, upid});\n        trackIdsToUris.set(id, uri);\n      });\n    }\n\n    // Attach track nodes to parents / or the workspace if they have no parent\n    trackMap.forEach((t) => {\n      const parent = exists(t.parentId) && trackMap.get(t.parentId);\n      if (parent !== false && parent !== undefined) {\n        parent.trackNode.addChildInOrder(t.trackNode);\n      } else {\n        const processGroup = ctx.plugins\n          .getPlugin(ProcessThreadGroupsPlugin)\n          .getGroupForProcess(t.upid);\n        processGroup?.addChildInOrder(t.trackNode);\n      }\n    });\n  }\n\n  async addThreadAsyncSliceTracks(\n    ctx: Trace,\n    trackIdsToUris: Map<number, string>,\n  ): Promise<void> {\n    const result = await ctx.engine.query(`\n      include perfetto module viz.summary.slices;\n      include perfetto module viz.summary.threads;\n      include perfetto module viz.threads;\n\n      select\n        t.utid,\n        t.parent_id as parentId,\n        thread.upid,\n        t.name as trackName,\n        thread.name as threadName,\n        thread.tid as tid,\n        t.track_ids as trackIds,\n        __max_layout_depth(t.track_count, t.track_ids) as maxDepth,\n        k.is_main_thread as isMainThread,\n        k.is_kernel_thread AS isKernelThread\n      from _thread_track_summary_by_utid_and_name t\n      join _threads_with_kernel_flag k using(utid)\n      join thread using (utid)\n    `);\n\n    const it = result.iter({\n      utid: NUM,\n      parentId: NUM_NULL,\n      upid: NUM_NULL,\n      trackName: STR_NULL,\n      trackIds: STR,\n      maxDepth: NUM,\n      isMainThread: NUM_NULL,\n      isKernelThread: NUM,\n      threadName: STR_NULL,\n      tid: NUM_NULL,\n    });\n\n    const trackMap = new Map<\n      number,\n      {parentId: number | null; utid: number; trackNode: TrackNode}\n    >();\n\n    for (; it.valid(); it.next()) {\n      const {\n        utid,\n        parentId,\n        upid,\n        trackName,\n        isMainThread,\n        isKernelThread,\n        maxDepth,\n        threadName,\n        tid,\n      } = it;\n      const rawTrackIds = it.trackIds;\n      const trackIds = rawTrackIds.split(',').map((v) => Number(v));\n      const title = getTrackName({\n        name: trackName,\n        utid,\n        tid,\n        threadName,\n        kind: 'Slices',\n      });\n\n      const uri = `/${getThreadUriPrefix(upid, utid)}_slice_${rawTrackIds}`;\n      ctx.tracks.registerTrack({\n        uri,\n        title,\n        tags: {\n          trackIds,\n          kind: SLICE_TRACK_KIND,\n          scope: 'thread',\n          utid,\n          upid: upid ?? undefined,\n          ...(isKernelThread === 1 && {kernelThread: true}),\n        },\n        chips: removeFalsyValues([\n          isKernelThread === 0 && isMainThread === 1 && 'main thread',\n        ]),\n        track: new AsyncSliceTrack(ctx, uri, maxDepth, trackIds),\n      });\n      const track = new TrackNode({uri, title, sortOrder: 20});\n      trackIds.forEach((id) => {\n        trackMap.set(id, {trackNode: track, parentId, utid});\n        trackIdsToUris.set(id, uri);\n      });\n    }\n\n    // Attach track nodes to parents / or the workspace if they have no parent\n    trackMap.forEach((t) => {\n      const parent = exists(t.parentId) && trackMap.get(t.parentId);\n      if (parent !== false && parent !== undefined) {\n        parent.trackNode.addChildInOrder(t.trackNode);\n      } else {\n        const group = ctx.plugins\n          .getPlugin(ProcessThreadGroupsPlugin)\n          .getGroupForThread(t.utid);\n        group?.addChildInOrder(t.trackNode);\n      }\n    });\n  }\n}\n"]}