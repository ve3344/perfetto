{"version":3,"file":"query_result.js","sourceRoot":"","sources":["../../../src/trace_processor/query_result.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This file deals with deserialization and iteration of the proto-encoded\n// byte buffer that is returned by TraceProcessor when invoking the\n// TPM_QUERY_STREAMING method. The returned |query_result| buffer is optimized\n// for being moved cheaply across workers and decoded on-the-flight as we step\n// through the iterator.\n// See comments around QueryResult in trace_processor.proto for more details.\n\n// The classes in this file are organized as follows:\n//\n// QueryResultImpl:\n// The object returned by the Engine.query(sql) method.\n// This object is a holder of row data. Batches of raw get appended\n// incrementally as they are received by the remote TraceProcessor instance.\n// QueryResultImpl also deals with asynchronicity of queries and allows callers\n// to obtain a promise that waits for more (or all) rows.\n// At any point in time the following objects hold a reference to QueryResult:\n// - The Engine: for appending row batches.\n// - UI code, typically controllers, who make queries.\n//\n// ResultBatch:\n// Hold the data, returned by the remote TraceProcessor instance, for a number\n// of rows (TP typically chunks the results in batches of 128KB).\n// A QueryResultImpl holds exclusively ResultBatches for a given query.\n// ResultBatch is not exposed externally, it's just an internal representation\n// that helps with proto decoding. ResultBatch is immutable after it gets\n// appended and decoded. The iteration state is held by the RowIteratorImpl.\n//\n// RowIteratorImpl:\n// Decouples the data owned by QueryResultImpl (and its ResultBatch(es)) from\n// the iteration state. The iterator effectively is the union of a ResultBatch\n// and the row number in it. Rows within the batch are decoded as the user calls\n// next(). When getting at the end of the batch, it takes care of switching to\n// the next batch (if any) within the QueryResultImpl.\n// This object is part of the API exposed to tracks / controllers.\n\n// Ensure protobuf is initialized.\nimport '../base/static_initializers';\nimport protobuf from 'protobufjs/minimal';\nimport {defer, Deferred} from '../base/deferred';\nimport {assertExists, assertFalse, assertTrue} from '../base/logging';\nimport {utf8Decode} from '../base/string_utils';\nimport {Duration, duration, Time, time} from '../base/time';\n\nexport type SqlValue = string | number | bigint | null | Uint8Array;\n// TODO(altimin): Replace ColumnType with SqlValue across the codebase and\n// remove export here.\nexport type ColumnType = SqlValue;\n\nexport const UNKNOWN: ColumnType = null;\nexport const NUM = 0;\nexport const STR = 'str';\nexport const NUM_NULL: number | null = 1;\nexport const STR_NULL: string | null = 'str_null';\nexport const BLOB: Uint8Array = new Uint8Array();\nexport const BLOB_NULL: Uint8Array | null = new Uint8Array();\nexport const LONG: bigint = 0n;\nexport const LONG_NULL: bigint | null = 1n;\n\nconst SHIFT_32BITS = 32n;\n\n// Fast decode varint int64 into a bigint\n// Inspired by\n// https://github.com/protobufjs/protobuf.js/blob/56b1e64979dae757b67a21d326e16acee39f2267/src/reader.js#L123\nexport function decodeInt64Varint(buf: Uint8Array, pos: number): bigint {\n  let hi: number = 0;\n  let lo: number = 0;\n  let i = 0;\n\n  if (buf.length - pos > 4) {\n    // fast route (lo)\n    for (; i < 4; ++i) {\n      // 1st..4th\n      lo = (lo | ((buf[pos] & 127) << (i * 7))) >>> 0;\n      if (buf[pos++] < 128) {\n        return BigInt(lo);\n      }\n    }\n    // 5th\n    lo = (lo | ((buf[pos] & 127) << 28)) >>> 0;\n    hi = (hi | ((buf[pos] & 127) >> 4)) >>> 0;\n    if (buf[pos++] < 128) {\n      return (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);\n    }\n    i = 0;\n  } else {\n    for (; i < 3; ++i) {\n      if (pos >= buf.length) {\n        throw Error('Index out of range');\n      }\n      // 1st..3rd\n      lo = (lo | ((buf[pos] & 127) << (i * 7))) >>> 0;\n      if (buf[pos++] < 128) {\n        return BigInt(lo);\n      }\n    }\n    // 4th\n    lo = (lo | ((buf[pos++] & 127) << (i * 7))) >>> 0;\n    return (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);\n  }\n  if (buf.length - pos > 4) {\n    // fast route (hi)\n    for (; i < 5; ++i) {\n      // 6th..10th\n      hi = (hi | ((buf[pos] & 127) << (i * 7 + 3))) >>> 0;\n      if (buf[pos++] < 128) {\n        const big = (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);\n        return BigInt.asIntN(64, big);\n      }\n    }\n  } else {\n    for (; i < 5; ++i) {\n      if (pos >= buf.length) {\n        throw Error('Index out of range');\n      }\n      // 6th..10th\n      hi = (hi | ((buf[pos] & 127) << (i * 7 + 3))) >>> 0;\n      if (buf[pos++] < 128) {\n        const big = (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);\n        return BigInt.asIntN(64, big);\n      }\n    }\n  }\n  throw Error('invalid varint encoding');\n}\n\n// Info that could help debug a query error. For example the query\n// in question, the stack where the query was issued, the active\n// plugin etc.\nexport interface QueryErrorInfo {\n  query: string;\n}\n\nexport class QueryError extends Error {\n  readonly query: string;\n\n  constructor(message: string, info: QueryErrorInfo) {\n    super(message);\n    this.query = info.query;\n  }\n\n  toString() {\n    return `${super.toString()}\\nQuery:\\n${this.query}`;\n  }\n}\n\n// One row extracted from an SQL result:\nexport interface Row {\n  [key: string]: ColumnType;\n}\n\n// The methods that any iterator has to implement.\nexport interface RowIteratorBase {\n  valid(): boolean;\n  next(): void;\n\n  // Reflection support for cases where the column names are not known upfront\n  // (e.g. the query result table for user-provided SQL queries).\n  // It throws if the passed column name doesn't exist.\n  // Example usage:\n  // for (const it = queryResult.iter({}); it.valid(); it.next()) {\n  //   for (const columnName : queryResult.columns()) {\n  //      console.log(it.get(columnName));\n  get(columnName: string): ColumnType;\n}\n\n// A RowIterator is a type that has all the fields defined in the query spec\n// plus the valid() and next() operators. This is to ultimately allow the\n// clients to do:\n// const result = await engine.query(\"select name, surname, id from people;\");\n// const iter = queryResult.iter({name: STR, surname: STR, id: NUM});\n// for (; iter.valid(); iter.next())\n//  console.log(iter.name, iter.surname);\nexport type RowIterator<T extends Row> = RowIteratorBase & T;\n\nfunction columnTypeToString(t: ColumnType): string {\n  switch (t) {\n    case NUM:\n      return 'NUM';\n    case NUM_NULL:\n      return 'NUM_NULL';\n    case STR:\n      return 'STR';\n    case STR_NULL:\n      return 'STR_NULL';\n    case BLOB:\n      return 'BLOB';\n    case BLOB_NULL:\n      return 'BLOB_NULL';\n    case LONG:\n      return 'LONG';\n    case LONG_NULL:\n      return 'LONG_NULL';\n    case UNKNOWN:\n      return 'UNKNOWN';\n    default:\n      return `INVALID(${t})`;\n  }\n}\n\nfunction isCompatible(actual: CellType, expected: ColumnType): boolean {\n  switch (actual) {\n    case CellType.CELL_NULL:\n      return (\n        expected === NUM_NULL ||\n        expected === STR_NULL ||\n        expected === BLOB_NULL ||\n        expected === LONG_NULL ||\n        expected === UNKNOWN\n      );\n    case CellType.CELL_VARINT:\n      return (\n        expected === NUM ||\n        expected === NUM_NULL ||\n        expected === LONG ||\n        expected === LONG_NULL ||\n        expected === UNKNOWN\n      );\n    case CellType.CELL_FLOAT64:\n      return expected === NUM || expected === NUM_NULL || expected === UNKNOWN;\n    case CellType.CELL_STRING:\n      return expected === STR || expected === STR_NULL || expected === UNKNOWN;\n    case CellType.CELL_BLOB:\n      return (\n        expected === BLOB || expected === BLOB_NULL || expected === UNKNOWN\n      );\n    default:\n      throw new Error(`Unknown CellType ${actual}`);\n  }\n}\n\n// This has to match CellType in trace_processor.proto.\nenum CellType {\n  CELL_NULL = 1,\n  CELL_VARINT = 2,\n  CELL_FLOAT64 = 3,\n  CELL_STRING = 4,\n  CELL_BLOB = 5,\n}\n\nconst CELL_TYPE_NAMES = [\n  'UNKNOWN',\n  'NULL',\n  'VARINT',\n  'FLOAT64',\n  'STRING',\n  'BLOB',\n];\n\nconst TAG_LEN_DELIM = 2;\n\n// This is the interface exposed to readers (e.g. tracks). The underlying object\n// (QueryResultImpl) owns the result data. This allows to obtain iterators on\n// that. In future it will allow to wait for incremental updates (new rows being\n// fetched) for streaming queries.\nexport interface QueryResult {\n  // Obtains an iterator.\n  // TODO(primiano): this should have an option to destruct data as we read. In\n  // the case of a long query (e.g. `SELECT * FROM sched` in the query prompt)\n  // we don't want to accumulate everything in memory. OTOH UI tracks want to\n  // keep the data around so they can redraw them on each animation frame. For\n  // now we keep everything in memory in the QueryResultImpl object.\n  // iter<T extends Row>(spec: T): RowIterator<T>;\n  iter<T extends Row>(spec: T): RowIterator<T>;\n\n  // Like iter() for queries that expect only one row. It embeds the valid()\n  // check (i.e. throws if no rows are available) and returns directly the\n  // first result.\n  firstRow<T extends Row>(spec: T): T;\n\n  // Like firstRow() but returns undefined if no rows are available.\n  maybeFirstRow<T extends Row>(spec: T): T | undefined;\n\n  // If != undefined the query errored out and error() contains the message.\n  error(): string | undefined;\n\n  // Returns the number of rows accumulated so far. Note that this number can\n  // change over time as more batches are received. It becomes stable only\n  // when isComplete() returns true or after waitAllRows() is resolved.\n  numRows(): number;\n\n  // If true all rows have been fetched. Calling iter() will iterate through the\n  // last row. If false, iter() will return an iterator which might iterate\n  // through some rows (or none) but will surely not reach the end.\n  isComplete(): boolean;\n\n  // Returns a promise that is resolved only when all rows (i.e. all batches)\n  // have been fetched. The promise return value is always the object itself.\n  waitAllRows(): Promise<QueryResult>;\n\n  // Returns a promise that is resolved when either:\n  // - more rows are available\n  // - all rows are available\n  // The promise return value is always the object iself.\n  waitMoreRows(): Promise<QueryResult>;\n\n  // Can return an empty array if called before the first batch is resolved.\n  // This should be called only after having awaited for at least one batch.\n  columns(): string[];\n\n  // Returns the number of SQL statements in the query\n  // (e.g. 2 'if SELECT 1; SELECT 2;')\n  statementCount(): number;\n\n  // Returns the number of SQL statement that produced output rows. This number\n  // is <= statementCount().\n  statementWithOutputCount(): number;\n\n  // Returns the last SQL statement.\n  lastStatementSql(): string;\n}\n\n// Interface exposed to engine.ts to pump in the data as new row batches arrive.\nexport interface WritableQueryResult extends QueryResult {\n  // |resBytes| is a proto-encoded trace_processor.QueryResult message.\n  //  The overall flow looks as follows:\n  // - The user calls engine.query('select ...') and gets a QueryResult back.\n  // - The query call posts a message to the worker that runs the SQL engine (\n  //   or sends a HTTP request in case of the RPC+HTTP interface).\n  // - The returned QueryResult object is initially empty.\n  // - Over time, the sql engine will postMessage() back results in batches.\n  // - Each bach will end up calling this appendResultBatch() method.\n  // - If there is any pending promise (e.g. the caller called\n  //   queryResult.waitAllRows()), this call will awake them (if this is the\n  //   last batch).\n  appendResultBatch(resBytes: Uint8Array): void;\n}\n\n// The actual implementation, which bridges together the reader side and the\n// writer side (the one exposed to the Engine). This is the same object so that\n// when the engine pumps new row batches we can resolve pending promises that\n// readers (e.g. track code) are waiting for.\nclass QueryResultImpl implements QueryResult, WritableQueryResult {\n  columnNames: string[] = [];\n  private _error?: string;\n  private _numRows = 0;\n  private _isComplete = false;\n  private _errorInfo: QueryErrorInfo;\n  private _statementCount = 0;\n  private _statementWithOutputCount = 0;\n  private _lastStatementSql = '';\n\n  constructor(errorInfo: QueryErrorInfo) {\n    this._errorInfo = errorInfo;\n  }\n\n  // --- QueryResult implementation.\n\n  // TODO(primiano): for the moment new batches are appended but old batches\n  // are never removed. This won't work with abnormally large result sets, as\n  // it will stash all rows in memory. We could switch to a model where the\n  // iterator is destructive and deletes batch objects once iterating past the\n  // end of each batch. If we do that, than we need to assign monotonic IDs to\n  // batches. Also if we do that, we should prevent creating more than one\n  // iterator for a QueryResult.\n  batches: ResultBatch[] = [];\n\n  // Promise awaiting on waitAllRows(). This should be resolved only when the\n  // last result batch has been been retrieved.\n  private allRowsPromise?: Deferred<QueryResult>;\n\n  // Promise awaiting on waitMoreRows(). This resolved when the next\n  // batch is appended via appendResultBatch.\n  private moreRowsPromise?: Deferred<QueryResult>;\n\n  isComplete(): boolean {\n    return this._isComplete;\n  }\n  numRows(): number {\n    return this._numRows;\n  }\n  error(): string | undefined {\n    return this._error;\n  }\n  columns(): string[] {\n    return this.columnNames;\n  }\n  statementCount(): number {\n    return this._statementCount;\n  }\n  statementWithOutputCount(): number {\n    return this._statementWithOutputCount;\n  }\n  lastStatementSql(): string {\n    return this._lastStatementSql;\n  }\n\n  iter<T extends Row>(spec: T): RowIterator<T> {\n    const impl = new RowIteratorImplWithRowData(spec, this);\n    return impl as {} as RowIterator<T>;\n  }\n\n  firstRow<T extends Row>(spec: T): T {\n    const impl = new RowIteratorImplWithRowData(spec, this);\n    assertTrue(impl.valid());\n    return impl as {} as RowIterator<T> as T;\n  }\n\n  maybeFirstRow<T extends Row>(spec: T): T | undefined {\n    const impl = new RowIteratorImplWithRowData(spec, this);\n    if (!impl.valid()) {\n      return undefined;\n    }\n    return impl as {} as RowIterator<T> as T;\n  }\n\n  // Can be called only once.\n  waitAllRows(): Promise<QueryResult> {\n    assertTrue(this.allRowsPromise === undefined);\n    this.allRowsPromise = defer<QueryResult>();\n    if (this._isComplete) {\n      this.resolveOrReject(this.allRowsPromise, this);\n    }\n    return this.allRowsPromise;\n  }\n\n  waitMoreRows(): Promise<QueryResult> {\n    if (this.moreRowsPromise !== undefined) {\n      return this.moreRowsPromise;\n    }\n\n    const moreRowsPromise = defer<QueryResult>();\n    if (this._isComplete) {\n      this.resolveOrReject(moreRowsPromise, this);\n    } else {\n      this.moreRowsPromise = moreRowsPromise;\n    }\n    return moreRowsPromise;\n  }\n\n  // --- WritableQueryResult implementation.\n\n  // Called by the engine when a new QueryResult is available. Note that a\n  // single Query() call can yield >1 QueryResult due to result batching\n  // if more than ~64K of data are returned, e.g. when returning O(M) rows.\n  // |resBytes| is a proto-encoded trace_processor.QueryResult message.\n  // It is fine to retain the resBytes without slicing a copy, because\n  // ProtoRingBuffer does the slice() for us (or passes through the buffer\n  // coming from postMessage() (Wasm case) of fetch() (HTTP+RPC case).\n  appendResultBatch(resBytes: Uint8Array) {\n    const reader = protobuf.Reader.create(resBytes);\n    assertTrue(reader.pos === 0);\n    const columnNamesEmptyAtStartOfBatch = this.columnNames.length === 0;\n    const columnNamesSet = new Set<string>();\n    while (reader.pos < reader.len) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: // column_names\n          // Only the first batch should contain the column names. If this fires\n          // something is going wrong in the handling of the batch stream.\n          assertTrue(columnNamesEmptyAtStartOfBatch);\n          const origColName = reader.string();\n          let colName = origColName;\n          // In some rare cases two columns can have the same name (b/194891824)\n          // e.g. `select 1 as x, 2 as x`. These queries don't happen in the\n          // UI code, but they can happen when the user types a query (e.g.\n          // with a join). The most practical thing we can do here is renaming\n          // the columns with a suffix. Keeping the same name will break when\n          // iterating, because column names become iterator object keys.\n          for (let i = 1; columnNamesSet.has(colName); ++i) {\n            colName = `${origColName}_${i}`;\n            assertTrue(i < 100); // Give up at some point;\n          }\n          columnNamesSet.add(colName);\n          this.columnNames.push(colName);\n          break;\n        case 2: // error\n          // The query has errored only if the |error| field is non-empty.\n          // In protos, we don't distinguish between non-present and empty.\n          // Make sure we don't propagate ambiguous empty strings to JS.\n          const err = reader.string();\n          this._error = err !== undefined && err.length ? err : undefined;\n          break;\n        case 3: // batch\n          const batchLen = reader.uint32();\n          const batchRaw = resBytes.subarray(reader.pos, reader.pos + batchLen);\n          reader.pos += batchLen;\n\n          // The ResultBatch ctor parses the CellsBatch submessage.\n          const parsedBatch = new ResultBatch(batchRaw);\n          this.batches.push(parsedBatch);\n          this._isComplete = parsedBatch.isLastBatch;\n\n          // In theory one could construct a valid proto serializing the column\n          // names after the cell batches. In practice the QueryResultSerializer\n          // doesn't do that so it's not worth complicating the code.\n          const numColumns = this.columnNames.length;\n          if (numColumns !== 0) {\n            assertTrue(parsedBatch.numCells % numColumns === 0);\n            this._numRows += parsedBatch.numCells / numColumns;\n          } else {\n            // numColumns == 0 is  plausible for queries like CREATE TABLE ... .\n            assertTrue(parsedBatch.numCells === 0);\n          }\n          break;\n\n        case 4:\n          this._statementCount = reader.uint32();\n          break;\n\n        case 5:\n          this._statementWithOutputCount = reader.uint32();\n          break;\n\n        case 6:\n          this._lastStatementSql = reader.string();\n          break;\n\n        default:\n          console.warn(`Unexpected QueryResult field ${tag >>> 3}`);\n          reader.skipType(tag & 7);\n          break;\n      } // switch (tag)\n    } // while (pos < end)\n\n    if (this.moreRowsPromise !== undefined) {\n      this.resolveOrReject(this.moreRowsPromise, this);\n      this.moreRowsPromise = undefined;\n    }\n\n    if (this._isComplete && this.allRowsPromise !== undefined) {\n      this.resolveOrReject(this.allRowsPromise, this);\n    }\n  }\n\n  ensureAllRowsPromise(): Promise<QueryResult> {\n    if (this.allRowsPromise === undefined) {\n      this.waitAllRows(); // Will populate |this.allRowsPromise|.\n    }\n    return assertExists(this.allRowsPromise);\n  }\n\n  get errorInfo(): QueryErrorInfo {\n    return this._errorInfo;\n  }\n\n  private resolveOrReject(promise: Deferred<QueryResult>, arg: QueryResult) {\n    if (this._error === undefined) {\n      promise.resolve(arg);\n    } else {\n      promise.reject(new QueryError(this._error, this._errorInfo));\n    }\n  }\n}\n\n// This class holds onto a received result batch (a Uint8Array) and does some\n// partial parsing to tokenize the various cell groups. This parsing mainly\n// consists of identifying and caching the offsets of each cell group and\n// initializing the varint decoders. This half parsing is done to keep the\n// iterator's next() fast, without decoding everything into memory.\n// This is an internal implementation detail and is not exposed outside. The\n// RowIteratorImpl uses this class to iterate through batches (this class takes\n// care of iterating within a batch, RowIteratorImpl takes care of switching\n// batches when needed).\n// Note: at any point in time there can be more than one ResultIterator\n// referencing the same batch. The batch must be immutable.\nclass ResultBatch {\n  readonly isLastBatch: boolean = false;\n  readonly batchBytes: Uint8Array;\n  readonly cellTypesOff: number = 0;\n  readonly cellTypesLen: number = 0;\n  readonly varintOff: number = 0;\n  readonly varintLen: number = 0;\n  readonly float64Cells = new Float64Array();\n  readonly blobCells: Uint8Array[] = [];\n  readonly stringCells: string[] = [];\n\n  // batchBytes is a trace_processor.QueryResult.CellsBatch proto.\n  constructor(batchBytes: Uint8Array) {\n    this.batchBytes = batchBytes;\n    const reader = protobuf.Reader.create(batchBytes);\n    assertTrue(reader.pos === 0);\n    const end = reader.len;\n\n    // Here we deconstruct the proto by hand. The CellsBatch is carefully\n    // designed to allow a very fast parsing from the TS side. We pack all cells\n    // of the same types together, so we can do only one call (per batch) to\n    // TextDecoder.decode(), we can overlay a memory-aligned typedarray for\n    // float values and can quickly tell and type-check the cell types.\n    // One row = N cells (we know the number upfront from the outer message).\n    // Each bach contains always an integer multiple of N cells (i.e. rows are\n    // never fragmented across different batches).\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: // cell types, a packed array containing one CellType per cell.\n          assertTrue((tag & 7) === TAG_LEN_DELIM); // Must be packed varint.\n          this.cellTypesLen = reader.uint32();\n          this.cellTypesOff = reader.pos;\n          reader.pos += this.cellTypesLen;\n          break;\n\n        case 2: // varint_cells, a packed varint buffer.\n          assertTrue((tag & 7) === TAG_LEN_DELIM); // Must be packed varint.\n          const packLen = reader.uint32();\n          this.varintOff = reader.pos;\n          this.varintLen = packLen;\n          assertTrue(reader.buf === batchBytes);\n          assertTrue(\n            this.varintOff + this.varintLen <=\n              batchBytes.byteOffset + batchBytes.byteLength,\n          );\n          reader.pos += packLen;\n          break;\n\n        case 3: // float64_cells, a 64-bit aligned packed fixed64 buffer.\n          assertTrue((tag & 7) === TAG_LEN_DELIM); // Must be packed varint.\n          const f64Len = reader.uint32();\n          assertTrue(f64Len % 8 === 0);\n          // Float64Array's constructor is evil: the offset is in bytes but the\n          // length is in 8-byte words.\n          const f64Words = f64Len / 8;\n          const f64Off = batchBytes.byteOffset + reader.pos;\n          if (f64Off % 8 === 0) {\n            this.float64Cells = new Float64Array(\n              batchBytes.buffer,\n              f64Off,\n              f64Words,\n            );\n          } else {\n            // When using the production code in trace_processor's rpc.cc, the\n            // float64 should be 8-bytes aligned. The slow-path case is only for\n            // tests.\n            const slice = batchBytes.buffer.slice(f64Off, f64Off + f64Len);\n            this.float64Cells = new Float64Array(slice);\n          }\n          reader.pos += f64Len;\n          break;\n\n        case 4: // blob_cells: one entry per blob.\n          assertTrue((tag & 7) === TAG_LEN_DELIM);\n          // protobufjs's bytes() under the hoods calls slice() and creates\n          // a copy. Fine here as blobs are rare and not a fastpath.\n          this.blobCells.push(new Uint8Array(reader.bytes()));\n          break;\n\n        case 5: // string_cells: all the string cells concatenated with \\0s.\n          assertTrue((tag & 7) === TAG_LEN_DELIM);\n          const strLen = reader.uint32();\n          assertTrue(reader.pos + strLen <= end);\n          const subArr = batchBytes.subarray(reader.pos, reader.pos + strLen);\n          assertTrue(subArr.length === strLen);\n          // The reason why we do this split rather than creating one string\n          // per entry is that utf8 decoding has some non-negligible cost. See\n          // go/postmessage-benchmark .\n          this.stringCells = utf8Decode(subArr).split('\\0');\n          reader.pos += strLen;\n          break;\n\n        case 6: // is_last_batch (boolean).\n          this.isLastBatch = !!reader.bool();\n          break;\n\n        case 7: // padding for realignment, skip silently.\n          reader.skipType(tag & 7);\n          break;\n\n        default:\n          console.warn(`Unexpected QueryResult.CellsBatch field ${tag >>> 3}`);\n          reader.skipType(tag & 7);\n          break;\n      } // switch(tag)\n    } // while (pos < end)\n  }\n\n  get numCells() {\n    return this.cellTypesLen;\n  }\n}\n\nclass RowIteratorImpl implements RowIteratorBase {\n  // The spec passed to the iter call containing the expected types, e.g.:\n  // {'colA': NUM, 'colB': NUM_NULL, 'colC': STRING}.\n  // This doesn't ever change.\n  readonly rowSpec: Row;\n\n  // The object that holds the current row. This points to the parent\n  // RowIteratorImplWithRowData instance that created this class.\n  rowData: Row;\n\n  // The QueryResult object we are reading data from. The engine will pump\n  // batches over time into this object.\n  private resultObj: QueryResultImpl;\n\n  // All the member variables in the group below point to the identically-named\n  // members in result.batch[batchIdx]. This is to avoid indirection layers in\n  // the next() hotpath, so we can do this.float64Cells vs\n  // this.resultObj.batch[this.batchIdx].float64Cells.\n  // These are re-set every time tryMoveToNextBatch() is called (and succeeds).\n  private batchIdx = -1; // The batch index within |result.batches[]|.\n  private batchBytes = new Uint8Array();\n  private columnNames: string[] = [];\n  private numColumns = 0;\n  private cellTypesEnd = -1; // -1 so the 1st next() hits tryMoveToNextBatch().\n  private float64Cells = new Float64Array();\n  private varIntReader = protobuf.Reader.create(this.batchBytes);\n  private blobCells: Uint8Array[] = [];\n  private stringCells: string[] = [];\n\n  // These members instead are incremented as we read cells from next(). They\n  // are the mutable state of the iterator.\n  private nextCellTypeOff = 0;\n  private nextFloat64Cell = 0;\n  private nextStringCell = 0;\n  private nextBlobCell = 0;\n  private isValid = false;\n\n  constructor(querySpec: Row, rowData: Row, res: QueryResultImpl) {\n    Object.assign(this, querySpec);\n    this.rowData = rowData;\n    this.rowSpec = {...querySpec}; // ... -> Copy all the key/value pairs.\n    this.resultObj = res;\n    this.next();\n  }\n\n  valid(): boolean {\n    return this.isValid;\n  }\n\n  private makeError(message: string): QueryError {\n    return new QueryError(message, this.resultObj.errorInfo);\n  }\n\n  get(columnName: string): ColumnType {\n    const res = this.rowData[columnName];\n    if (res === undefined) {\n      throw this.makeError(\n        `Column '${columnName}' doesn't exist. ` +\n          `Actual columns: [${this.columnNames.join(',')}]`,\n      );\n    }\n    return res;\n  }\n\n  // Moves the cursor next by one row and updates |isValid|.\n  // When this fails to move, two cases are possible:\n  // 1. We reached the end of the result set (this is the case if\n  //    QueryResult.isComplete() == true when this fails).\n  // 2. We reached the end of the current batch, but more rows might come later\n  //    (if QueryResult.isComplete() == false).\n  next() {\n    // At some point we might reach the end of the current batch, but the next\n    // batch might be available already. In this case we want next() to\n    // transparently move on to the next batch.\n    while (this.nextCellTypeOff + this.numColumns > this.cellTypesEnd) {\n      // If TraceProcessor is behaving well, we should never end up in a\n      // situation where we have leftover cells. TP is expected to serialize\n      // whole rows in each QueryResult batch and NOT truncate them midway.\n      // If this assert fires the TP RPC logic has a bug.\n      assertTrue(\n        this.nextCellTypeOff === this.cellTypesEnd || this.cellTypesEnd === -1,\n      );\n      if (!this.tryMoveToNextBatch()) {\n        this.isValid = false;\n        return;\n      }\n    }\n\n    const rowData = this.rowData;\n    const numColumns = this.numColumns;\n\n    // Read the current row.\n    for (let i = 0; i < numColumns; i++) {\n      const cellType = this.batchBytes[this.nextCellTypeOff++];\n      const colName = this.columnNames[i];\n      const expType = this.rowSpec[colName];\n\n      switch (cellType) {\n        case CellType.CELL_NULL:\n          rowData[colName] = null;\n          break;\n\n        case CellType.CELL_VARINT:\n          if (expType === NUM || expType === NUM_NULL) {\n            // This is very subtle. The return type of int64 can be either a\n            // number or a Long.js {high:number, low:number} if Long.js is\n            // installed. The default state seems different in node and browser.\n            // We force-disable Long.js support in the top of this source file.\n            const val = this.varIntReader.int64();\n            rowData[colName] = val as {} as number;\n          } else {\n            // LONG, LONG_NULL, or unspecified - return as bigint\n            const value = decodeInt64Varint(\n              this.batchBytes,\n              this.varIntReader.pos,\n            );\n            rowData[colName] = value;\n            this.varIntReader.skip(); // Skips a varint\n          }\n          break;\n\n        case CellType.CELL_FLOAT64:\n          rowData[colName] = this.float64Cells[this.nextFloat64Cell++];\n          break;\n\n        case CellType.CELL_STRING:\n          rowData[colName] = this.stringCells[this.nextStringCell++];\n          break;\n\n        case CellType.CELL_BLOB:\n          const blob = this.blobCells[this.nextBlobCell++];\n          rowData[colName] = blob;\n          break;\n\n        default:\n          throw this.makeError(`Invalid cell type ${cellType}`);\n      }\n    } // For (cells)\n    this.isValid = true;\n  }\n\n  private tryMoveToNextBatch(): boolean {\n    const nextBatchIdx = this.batchIdx + 1;\n    if (nextBatchIdx >= this.resultObj.batches.length) {\n      return false;\n    }\n\n    this.columnNames = this.resultObj.columnNames;\n    this.numColumns = this.columnNames.length;\n\n    this.batchIdx = nextBatchIdx;\n    const batch = assertExists(this.resultObj.batches[nextBatchIdx]);\n    this.batchBytes = batch.batchBytes;\n    this.nextCellTypeOff = batch.cellTypesOff;\n    this.cellTypesEnd = batch.cellTypesOff + batch.cellTypesLen;\n    this.float64Cells = batch.float64Cells;\n    this.blobCells = batch.blobCells;\n    this.stringCells = batch.stringCells;\n    this.varIntReader = protobuf.Reader.create(batch.batchBytes);\n    this.varIntReader.pos = batch.varintOff;\n    this.varIntReader.len = batch.varintOff + batch.varintLen;\n    this.nextFloat64Cell = 0;\n    this.nextStringCell = 0;\n    this.nextBlobCell = 0;\n\n    // Check that all the expected columns are present.\n    for (const expectedCol of Object.keys(this.rowSpec)) {\n      if (this.columnNames.indexOf(expectedCol) < 0) {\n        throw this.makeError(\n          `Column ${expectedCol} not found in the SQL result ` +\n            `set {${this.columnNames.join(' ')}}`,\n        );\n      }\n    }\n\n    // Check that the cells types are consistent.\n    const numColumns = this.numColumns;\n    if (batch.numCells === 0) {\n      // This can happen if the query result contains just an error. In this\n      // an empty batch with isLastBatch=true is appended as an EOF marker.\n      // In theory TraceProcessor could return an empty batch in the middle and\n      // that would be fine from a protocol viewpoint. In practice, no code path\n      // does that today so it doesn't make sense trying supporting it with a\n      // recursive call to tryMoveToNextBatch().\n      assertTrue(batch.isLastBatch);\n      return false;\n    }\n\n    assertTrue(numColumns > 0);\n    for (let i = this.nextCellTypeOff; i < this.cellTypesEnd; i++) {\n      const col = (i - this.nextCellTypeOff) % numColumns;\n      const colName = this.columnNames[col];\n      const actualType = this.batchBytes[i] as CellType;\n      const expType = this.rowSpec[colName];\n\n      // If undefined, the caller doesn't want to read this column at all, so\n      // it can be whatever.\n      if (expType === undefined) continue;\n\n      let err = '';\n      if (!isCompatible(actualType, expType)) {\n        if (actualType === CellType.CELL_NULL) {\n          err =\n            'SQL value is NULL but that was not expected' +\n            ` (expected type: ${columnTypeToString(expType)}). ` +\n            'Did you mean NUM_NULL, LONG_NULL, STR_NULL or BLOB_NULL?';\n        } else {\n          err = `Incompatible cell type. Expected: ${columnTypeToString(\n            expType,\n          )} actual: ${CELL_TYPE_NAMES[actualType]}`;\n        }\n      }\n      if (err.length > 0) {\n        const row = Math.floor(i / numColumns);\n        const message = `Error @ row: ${row} col: '${colName}': ${err}`;\n        throw this.makeError(message);\n      }\n    }\n    return true;\n  }\n}\n\n// This is the object ultimately returned to the client when calling\n// QueryResult.iter(...).\n// The only reason why this is disjoint from RowIteratorImpl is to avoid\n// naming collisions between the members variables required by RowIteratorImpl\n// and the column names returned by the iterator.\nclass RowIteratorImplWithRowData implements RowIteratorBase {\n  private _impl: RowIteratorImpl;\n\n  next: () => void;\n  valid: () => boolean;\n  get: (columnName: string) => ColumnType;\n\n  constructor(querySpec: Row, res: QueryResultImpl) {\n    const thisAsRow = this as {} as Row;\n    Object.assign(thisAsRow, querySpec);\n    this._impl = new RowIteratorImpl(querySpec, thisAsRow, res);\n    this.next = this._impl.next.bind(this._impl);\n    this.valid = this._impl.valid.bind(this._impl);\n    this.get = this._impl.get.bind(this._impl);\n  }\n}\n\n// This is a proxy object that wraps QueryResultImpl, adding await-ability.\n// This is so that:\n// 1. Clients that just want to await for the full result set can just call\n//    await engine.query('...') and will get a QueryResult that is guaranteed\n//    to be complete.\n// 2. Clients that know how to handle the streaming can use it straight away.\nclass WaitableQueryResultImpl\n  implements QueryResult, WritableQueryResult, PromiseLike<QueryResult>\n{\n  private impl: QueryResultImpl;\n  private thenCalled = false;\n\n  constructor(errorInfo: QueryErrorInfo) {\n    this.impl = new QueryResultImpl(errorInfo);\n  }\n\n  // QueryResult implementation. Proxies all calls to the impl object.\n  iter<T extends Row>(spec: T) {\n    return this.impl.iter(spec);\n  }\n  firstRow<T extends Row>(spec: T) {\n    return this.impl.firstRow(spec);\n  }\n  maybeFirstRow<T extends Row>(spec: T) {\n    return this.impl.maybeFirstRow(spec);\n  }\n  waitAllRows() {\n    return this.impl.waitAllRows();\n  }\n  waitMoreRows() {\n    return this.impl.waitMoreRows();\n  }\n  isComplete() {\n    return this.impl.isComplete();\n  }\n  numRows() {\n    return this.impl.numRows();\n  }\n  columns() {\n    return this.impl.columns();\n  }\n  error() {\n    return this.impl.error();\n  }\n  statementCount() {\n    return this.impl.statementCount();\n  }\n  statementWithOutputCount() {\n    return this.impl.statementWithOutputCount();\n  }\n  lastStatementSql() {\n    return this.impl.lastStatementSql();\n  }\n\n  // WritableQueryResult implementation.\n  appendResultBatch(resBytes: Uint8Array) {\n    return this.impl.appendResultBatch(resBytes);\n  }\n\n  // PromiseLike<QueryResult> implementaton.\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  then(onfulfilled: any, onrejected: any): any {\n    assertFalse(this.thenCalled);\n    this.thenCalled = true;\n    return this.impl.ensureAllRowsPromise().then(onfulfilled, onrejected);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  catch(error: any): any {\n    return this.impl.ensureAllRowsPromise().catch(error);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  finally(callback: () => void): any {\n    return this.impl.ensureAllRowsPromise().finally(callback);\n  }\n\n  // eslint and clang-format disagree on how to format get[foo](). Let\n  // clang-format win:\n  get [Symbol.toStringTag](): string {\n    return 'Promise<WaitableQueryResult>';\n  }\n}\n\nexport function createQueryResult(\n  errorInfo: QueryErrorInfo,\n): QueryResult & Promise<QueryResult> & WritableQueryResult {\n  return new WaitableQueryResultImpl(errorInfo);\n}\n\n// Throws if the value cannot be reasonably converted to a bigint.\n// Assumes value is in native time units.\nexport function timeFromSql(value: ColumnType): time {\n  if (typeof value === 'bigint') {\n    return Time.fromRaw(value);\n  } else if (typeof value === 'number') {\n    return Time.fromRaw(BigInt(Math.floor(value)));\n  } else if (value === null) {\n    return Time.ZERO;\n  } else {\n    throw Error(`Refusing to create time from unrelated type ${value}`);\n  }\n}\n\n// Throws if the value cannot be reasonably converted to a bigint.\n// Assumes value is in nanoseconds.\nexport function durationFromSql(value: ColumnType): duration {\n  if (typeof value === 'bigint') {\n    return value;\n  } else if (typeof value === 'number') {\n    return BigInt(Math.floor(value));\n  } else if (value === null) {\n    return Duration.ZERO;\n  } else {\n    throw Error(`Refusing to create duration from unrelated type ${value}`);\n  }\n}\n"]}