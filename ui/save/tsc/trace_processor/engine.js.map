{"version":3,"file":"engine.js","sourceRoot":"","sources":["../../../src/trace_processor/engine.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2018 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport protos from '../protos';\nimport {defer, Deferred} from '../base/deferred';\nimport {assertExists, assertTrue} from '../base/logging';\nimport {ProtoRingBuffer} from './proto_ring_buffer';\nimport {\n  createQueryResult,\n  QueryError,\n  QueryResult,\n  WritableQueryResult,\n} from './query_result';\nimport TPM = protos.TraceProcessorRpc.TraceProcessorMethod;\nimport {exists} from '../base/utils';\nimport {errResult, okResult, Result} from '../base/result';\n\nexport type EngineMode = 'WASM' | 'HTTP_RPC';\nexport type NewEngineMode = 'USE_HTTP_RPC_IF_AVAILABLE' | 'FORCE_BUILTIN_WASM';\n\n// This is used to skip the decoding of queryResult from protobufjs and deal\n// with it ourselves. See the comment below around `QueryResult.decode = ...`.\ninterface QueryResultBypass {\n  rawQueryResult: Uint8Array;\n}\n\nexport interface TraceProcessorConfig {\n  cropTrackEvents: boolean;\n  ingestFtraceInRawTable: boolean;\n  analyzeTraceProtoContent: boolean;\n  ftraceDropUntilAllCpusValid: boolean;\n}\n\nexport interface Engine {\n  readonly mode: EngineMode;\n  readonly engineId: string;\n\n  /**\n   * Execute a query against the database, returning a promise that resolves\n   * when the query has completed but rejected when the query fails for whatever\n   * reason. On success, the promise will only resolve once all the resulting\n   * rows have been received.\n   *\n   * The promise will be rejected if the query fails.\n   *\n   * @param sql The query to execute.\n   * @param tag An optional tag used to trace the origin of the query.\n   */\n  query(sql: string, tag?: string): Promise<QueryResult>;\n\n  /**\n   * Execute a query against the database, returning a promise that resolves\n   * when the query has completed or failed. The promise will never get\n   * rejected, it will always successfully resolve. Use the returned wrapper\n   * object to determine whether the query completed successfully.\n   *\n   * The promise will only resolve once all the resulting rows have been\n   * received.\n   *\n   * @param sql The query to execute.\n   * @param tag An optional tag used to trace the origin of the query.\n   */\n  tryQuery(sql: string, tag?: string): Promise<Result<QueryResult>>;\n\n  /**\n   * Execute one or more metric and get the result.\n   *\n   * @param metrics The metrics to run.\n   * @param format The format of the response.\n   */\n  computeMetric(\n    metrics: string[],\n    format: 'json' | 'prototext' | 'proto',\n  ): Promise<string | Uint8Array>;\n\n  enableMetatrace(categories?: protos.MetatraceCategories): void;\n  stopAndGetMetatrace(): Promise<protos.DisableAndReadMetatraceResult>;\n\n  getProxy(tag: string): EngineProxy;\n  readonly numRequestsPending: number;\n  readonly failed: string | undefined;\n}\n\n// Abstract interface of a trace proccessor.\n// This is the TypeScript equivalent of src/trace_processor/rpc.h.\n// There are two concrete implementations:\n//   1. WasmEngineProxy: creates a Wasm module and interacts over postMessage().\n//   2. HttpRpcEngine: connects to an external `trace_processor_shell --httpd`.\n//      and interacts via fetch().\n// In both cases, we have a byte-oriented pipe to interact with TraceProcessor.\n// The derived class is only expected to deal with these two functions:\n// 1. Implement the abstract rpcSendRequestBytes() function, sending the\n//    proto-encoded TraceProcessorRpc requests to the TraceProcessor instance.\n// 2. Call onRpcResponseBytes() when response data is received.\nexport abstract class EngineBase implements Engine, Disposable {\n  abstract readonly id: string;\n  abstract readonly mode: EngineMode;\n  private txSeqId = 0;\n  private rxSeqId = 0;\n  private rxBuf = new ProtoRingBuffer();\n  private pendingParses = new Array<Deferred<void>>();\n  private pendingEOFs = new Array<Deferred<void>>();\n  private pendingResetTraceProcessors = new Array<Deferred<void>>();\n  private pendingQueries = new Array<WritableQueryResult>();\n  private pendingRestoreTables = new Array<Deferred<void>>();\n  private pendingComputeMetrics = new Array<Deferred<string | Uint8Array>>();\n  private pendingReadMetatrace?: Deferred<protos.DisableAndReadMetatraceResult>;\n  private pendingRegisterSqlPackage?: Deferred<void>;\n  private _isMetatracingEnabled = false;\n  private _numRequestsPending = 0;\n  private _failed: string | undefined = undefined;\n\n  // TraceController sets this to raf.scheduleFullRedraw().\n  onResponseReceived?: () => void;\n\n  // Called to send data to the TraceProcessor instance. This turns into a\n  // postMessage() or a HTTP request, depending on the Engine implementation.\n  abstract rpcSendRequestBytes(data: Uint8Array): void;\n\n  // Called when an inbound message is received by the Engine implementation\n  // (e.g. onmessage for the Wasm case, on when HTTP replies are received for\n  // the HTTP+RPC case).\n  onRpcResponseBytes(dataWillBeRetained: Uint8Array) {\n    // Note: when hitting the fastpath inside ProtoRingBuffer, the |data| buffer\n    // is returned back by readMessage() (% subarray()-ing it) and held onto by\n    // other classes (e.g., QueryResult). For both fetch() and Wasm we are fine\n    // because every response creates a new buffer.\n    this.rxBuf.append(dataWillBeRetained);\n    for (;;) {\n      const msg = this.rxBuf.readMessage();\n      if (msg === undefined) break;\n      this.onRpcResponseMessage(msg);\n    }\n  }\n\n  // Parses a response message.\n  // |rpcMsgEncoded| is a sub-array to to the start of a TraceProcessorRpc\n  // proto-encoded message (without the proto preamble and varint size).\n  private onRpcResponseMessage(rpcMsgEncoded: Uint8Array) {\n    // Here we override the protobufjs-generated code to skip the parsing of the\n    // new streaming QueryResult and instead passing it through like a buffer.\n    // This is the overall problem: All trace processor responses are wrapped\n    // into a TraceProcessorRpc proto message. In all cases %\n    // TPM_QUERY_STREAMING, we want protobufjs to decode the proto bytes and\n    // give us a structured object. In the case of TPM_QUERY_STREAMING, instead,\n    // we want to deal with the proto parsing ourselves using the new\n    // QueryResult.appendResultBatch() method, because that handled streaming\n    // results more efficiently and skips several copies.\n    // By overriding the decode method below, we achieve two things:\n    // 1. We avoid protobufjs decoding the TraceProcessorRpc.query_result field.\n    // 2. We stash (a view of) the original buffer into the |rawQueryResult| so\n    //    the `case TPM_QUERY_STREAMING` below can take it.\n    protos.QueryResult.decode = (reader: protobuf.Reader, length: number) => {\n      const res = protos.QueryResult.create() as {} as QueryResultBypass;\n      res.rawQueryResult = reader.buf.subarray(reader.pos, reader.pos + length);\n      // All this works only if protobufjs returns the original ArrayBuffer\n      // from |rpcMsgEncoded|. It should be always the case given the\n      // current implementation. This check mainly guards against future\n      // behavioral changes of protobufjs. We don't want to accidentally\n      // hold onto some internal protobufjs buffer. We are fine holding\n      // onto |rpcMsgEncoded| because those come from ProtoRingBuffer which\n      // is buffer-retention-friendly.\n      assertTrue(res.rawQueryResult.buffer === rpcMsgEncoded.buffer);\n      reader.pos += length;\n      return res as {} as protos.QueryResult;\n    };\n\n    const rpc = protos.TraceProcessorRpc.decode(rpcMsgEncoded);\n\n    if (rpc.fatalError !== undefined && rpc.fatalError.length > 0) {\n      this.fail(`${rpc.fatalError}`);\n    }\n\n    // Allow restarting sequences from zero (when reloading the browser).\n    if (rpc.seq !== this.rxSeqId + 1 && this.rxSeqId !== 0 && rpc.seq !== 0) {\n      // \"(ERR:rpc_seq)\" is intercepted by error_dialog.ts to show a more\n      // graceful and actionable error.\n      this.fail(\n        `RPC sequence id mismatch ` +\n          `cur=${rpc.seq} last=${this.rxSeqId} (ERR:rpc_seq)`,\n      );\n    }\n\n    this.rxSeqId = rpc.seq;\n\n    let isFinalResponse = true;\n\n    switch (rpc.response) {\n      case TPM.TPM_APPEND_TRACE_DATA: {\n        const appendResult = assertExists(rpc.appendResult);\n        const pendingPromise = assertExists(this.pendingParses.shift());\n        if (exists(appendResult.error) && appendResult.error.length > 0) {\n          pendingPromise.reject(appendResult.error);\n        } else {\n          pendingPromise.resolve();\n        }\n        break;\n      }\n      case TPM.TPM_FINALIZE_TRACE_DATA: {\n        const finalizeResult = assertExists(rpc.finalizeDataResult);\n        const pendingPromise = assertExists(this.pendingEOFs.shift());\n        if (exists(finalizeResult.error) && finalizeResult.error.length > 0) {\n          pendingPromise.reject(finalizeResult.error);\n        } else {\n          pendingPromise.resolve();\n        }\n        break;\n      }\n      case TPM.TPM_RESET_TRACE_PROCESSOR:\n        assertExists(this.pendingResetTraceProcessors.shift()).resolve();\n        break;\n      case TPM.TPM_RESTORE_INITIAL_TABLES:\n        assertExists(this.pendingRestoreTables.shift()).resolve();\n        break;\n      case TPM.TPM_QUERY_STREAMING:\n        const qRes = assertExists(rpc.queryResult) as {} as QueryResultBypass;\n        const pendingQuery = assertExists(this.pendingQueries[0]);\n        pendingQuery.appendResultBatch(qRes.rawQueryResult);\n        if (pendingQuery.isComplete()) {\n          this.pendingQueries.shift();\n        } else {\n          isFinalResponse = false;\n        }\n        break;\n      case TPM.TPM_COMPUTE_METRIC:\n        const metricRes = assertExists(\n          rpc.metricResult,\n        ) as protos.ComputeMetricResult;\n        const pendingComputeMetric = assertExists(\n          this.pendingComputeMetrics.shift(),\n        );\n        if (exists(metricRes.error) && metricRes.error.length > 0) {\n          const error = new QueryError(\n            `ComputeMetric() error: ${metricRes.error}`,\n            {\n              query: 'COMPUTE_METRIC',\n            },\n          );\n          pendingComputeMetric.reject(error);\n        } else {\n          const result =\n            metricRes.metricsAsPrototext ??\n            metricRes.metricsAsJson ??\n            metricRes.metrics ??\n            '';\n          pendingComputeMetric.resolve(result);\n        }\n        break;\n      case TPM.TPM_DISABLE_AND_READ_METATRACE:\n        const metatraceRes = assertExists(\n          rpc.metatrace,\n        ) as protos.DisableAndReadMetatraceResult;\n        assertExists(this.pendingReadMetatrace).resolve(metatraceRes);\n        this.pendingReadMetatrace = undefined;\n        break;\n      case TPM.TPM_REGISTER_SQL_PACKAGE:\n        const registerResult = assertExists(rpc.registerSqlPackageResult);\n        const res = assertExists(this.pendingRegisterSqlPackage);\n        if (exists(registerResult.error) && registerResult.error.length > 0) {\n          res.reject(registerResult.error);\n        } else {\n          res.resolve();\n        }\n        break;\n      default:\n        console.log(\n          'Unexpected TraceProcessor response received: ',\n          rpc.response,\n        );\n        break;\n    } // switch(rpc.response);\n\n    if (isFinalResponse) {\n      --this._numRequestsPending;\n    }\n\n    this.onResponseReceived?.();\n  }\n\n  // TraceProcessor methods below this point.\n  // The methods below are called by the various controllers in the UI and\n  // deal with marshalling / unmarshaling requests to/from TraceProcessor.\n\n  // Push trace data into the engine. The engine is supposed to automatically\n  // figure out the type of the trace (JSON vs Protobuf).\n  parse(data: Uint8Array): Promise<void> {\n    const asyncRes = defer<void>();\n    this.pendingParses.push(asyncRes);\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_APPEND_TRACE_DATA;\n    rpc.appendTraceData = data;\n    this.rpcSendRequest(rpc);\n    return asyncRes; // Linearize with the worker.\n  }\n\n  // Notify the engine that we reached the end of the trace.\n  // Called after the last parse() call.\n  notifyEof(): Promise<void> {\n    const asyncRes = defer<void>();\n    this.pendingEOFs.push(asyncRes);\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_FINALIZE_TRACE_DATA;\n    this.rpcSendRequest(rpc);\n    return asyncRes; // Linearize with the worker.\n  }\n\n  // Updates the TraceProcessor Config. This method creates a new\n  // TraceProcessor instance, so it should be called before passing any trace\n  // data.\n  resetTraceProcessor({\n    cropTrackEvents,\n    ingestFtraceInRawTable,\n    analyzeTraceProtoContent,\n    ftraceDropUntilAllCpusValid,\n  }: TraceProcessorConfig): Promise<void> {\n    const asyncRes = defer<void>();\n    this.pendingResetTraceProcessors.push(asyncRes);\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_RESET_TRACE_PROCESSOR;\n    const args = (rpc.resetTraceProcessorArgs =\n      new protos.ResetTraceProcessorArgs());\n    args.dropTrackEventDataBefore = cropTrackEvents\n      ? protos.ResetTraceProcessorArgs.DropTrackEventDataBefore\n          .TRACK_EVENT_RANGE_OF_INTEREST\n      : protos.ResetTraceProcessorArgs.DropTrackEventDataBefore.NO_DROP;\n    args.ingestFtraceInRawTable = ingestFtraceInRawTable;\n    args.analyzeTraceProtoContent = analyzeTraceProtoContent;\n    args.ftraceDropUntilAllCpusValid = ftraceDropUntilAllCpusValid;\n    this.rpcSendRequest(rpc);\n    return asyncRes;\n  }\n\n  // Resets the trace processor state by destroying any table/views created by\n  // the UI after loading.\n  restoreInitialTables(): Promise<void> {\n    const asyncRes = defer<void>();\n    this.pendingRestoreTables.push(asyncRes);\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_RESTORE_INITIAL_TABLES;\n    this.rpcSendRequest(rpc);\n    return asyncRes; // Linearize with the worker.\n  }\n\n  // Shorthand for sending a compute metrics request to the engine.\n  async computeMetric(\n    metrics: string[],\n    format: 'json' | 'prototext' | 'proto',\n  ): Promise<string | Uint8Array> {\n    const asyncRes = defer<string | Uint8Array>();\n    this.pendingComputeMetrics.push(asyncRes);\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_COMPUTE_METRIC;\n    const args = (rpc.computeMetricArgs = new protos.ComputeMetricArgs());\n    args.metricNames = metrics;\n    if (format === 'json') {\n      args.format = protos.ComputeMetricArgs.ResultFormat.JSON;\n    } else if (format === 'prototext') {\n      args.format = protos.ComputeMetricArgs.ResultFormat.TEXTPROTO;\n    } else if (format === 'proto') {\n      args.format = protos.ComputeMetricArgs.ResultFormat.BINARY_PROTOBUF;\n    } else {\n      throw new Error(`Unknown compute metric format ${format}`);\n    }\n    this.rpcSendRequest(rpc);\n    return asyncRes;\n  }\n\n  // Issues a streaming query and retrieve results in batches.\n  // The returned QueryResult object will be populated over time with batches\n  // of rows (each batch conveys ~128KB of data and a variable number of rows).\n  // The caller can decide whether to wait that all batches have been received\n  // (by awaiting the returned object or calling result.waitAllRows()) or handle\n  // the rows incrementally.\n  //\n  // Example usage:\n  // const res = engine.execute('SELECT foo, bar FROM table');\n  // console.log(res.numRows());  // Will print 0 because we didn't await.\n  // await(res.waitAllRows());\n  // console.log(res.numRows());  // Will print the total number of rows.\n  //\n  // for (const it = res.iter({foo: NUM, bar:STR}); it.valid(); it.next()) {\n  //   console.log(it.foo, it.bar);\n  // }\n  //\n  // Optional |tag| (usually a component name) can be provided to allow\n  // attributing trace processor workload to different UI components.\n  private streamingQuery(\n    sqlQuery: string,\n    tag?: string,\n  ): Promise<QueryResult> & QueryResult {\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_QUERY_STREAMING;\n    rpc.queryArgs = new protos.QueryArgs();\n    rpc.queryArgs.sqlQuery = sqlQuery;\n    if (tag) {\n      rpc.queryArgs.tag = tag;\n    }\n    const result = createQueryResult({\n      query: sqlQuery,\n    });\n    this.pendingQueries.push(result);\n    this.rpcSendRequest(rpc);\n    return result;\n  }\n\n  // Wraps .streamingQuery(), captures errors and re-throws with current stack.\n  //\n  // Note: This function is less flexible than .execute() as it only returns a\n  // promise which must be unwrapped before the QueryResult may be accessed.\n  async query(sqlQuery: string, tag?: string): Promise<QueryResult> {\n    try {\n      return await this.streamingQuery(sqlQuery, tag);\n    } catch (e) {\n      // Replace the error's stack trace with the one from here\n      // Note: It seems only V8 can trace the stack up the promise chain, so its\n      // likely this stack won't be useful on !V8.\n      // See\n      // https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q\n      captureStackTrace(e);\n      throw e;\n    }\n  }\n\n  async tryQuery(sql: string, tag?: string): Promise<Result<QueryResult>> {\n    try {\n      const result = await this.query(sql, tag);\n      return okResult(result);\n    } catch (error) {\n      const msg = 'message' in error ? `${error.message}` : `${error}`;\n      return errResult(msg);\n    }\n  }\n\n  isMetatracingEnabled(): boolean {\n    return this._isMetatracingEnabled;\n  }\n\n  enableMetatrace(categories?: protos.MetatraceCategories) {\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_ENABLE_METATRACE;\n    if (\n      categories !== undefined &&\n      categories !== protos.MetatraceCategories.NONE\n    ) {\n      rpc.enableMetatraceArgs = new protos.EnableMetatraceArgs();\n      rpc.enableMetatraceArgs.categories = categories;\n    }\n    this._isMetatracingEnabled = true;\n    this.rpcSendRequest(rpc);\n  }\n\n  stopAndGetMetatrace(): Promise<protos.DisableAndReadMetatraceResult> {\n    // If we are already finalising a metatrace, ignore the request.\n    if (this.pendingReadMetatrace) {\n      return Promise.reject(new Error('Already finalising a metatrace'));\n    }\n\n    const result = defer<protos.DisableAndReadMetatraceResult>();\n\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_DISABLE_AND_READ_METATRACE;\n    this._isMetatracingEnabled = false;\n    this.pendingReadMetatrace = result;\n    this.rpcSendRequest(rpc);\n    return result;\n  }\n\n  registerSqlPackages(pkg: {\n    name: string;\n    modules: {name: string; sql: string}[];\n  }): Promise<void> {\n    if (this.pendingRegisterSqlPackage) {\n      return Promise.reject(new Error('Already finalising a metatrace'));\n    }\n\n    const result = defer<void>();\n\n    const rpc = protos.TraceProcessorRpc.create();\n    rpc.request = TPM.TPM_REGISTER_SQL_PACKAGE;\n    const args = (rpc.registerSqlPackageArgs =\n      new protos.RegisterSqlPackageArgs());\n    args.packageName = pkg.name;\n    args.modules = pkg.modules;\n    args.allowOverride = true;\n    this.pendingRegisterSqlPackage = result;\n    this.rpcSendRequest(rpc);\n    return result;\n  }\n\n  // Marshals the TraceProcessorRpc request arguments and sends the request\n  // to the concrete Engine (Wasm or HTTP).\n  private rpcSendRequest(rpc: protos.TraceProcessorRpc) {\n    rpc.seq = this.txSeqId++;\n    // Each message is wrapped in a TraceProcessorRpcStream to add the varint\n    // preamble with the size, which allows tokenization on the other end.\n    const outerProto = protos.TraceProcessorRpcStream.create();\n    outerProto.msg.push(rpc);\n    const buf = protos.TraceProcessorRpcStream.encode(outerProto).finish();\n    ++this._numRequestsPending;\n    this.rpcSendRequestBytes(buf);\n  }\n\n  get engineId(): string {\n    return this.id;\n  }\n\n  get numRequestsPending(): number {\n    return this._numRequestsPending;\n  }\n\n  getProxy(tag: string): EngineProxy {\n    return new EngineProxy(this, tag);\n  }\n\n  protected fail(reason: string) {\n    this._failed = reason;\n    throw new Error(reason);\n  }\n\n  get failed(): string | undefined {\n    return this._failed;\n  }\n\n  abstract [Symbol.dispose](): void;\n}\n\n// Lightweight engine proxy which annotates all queries with a tag\nexport class EngineProxy implements Engine, Disposable {\n  private engine: EngineBase;\n  private tag: string;\n  private _isAlive: boolean;\n\n  constructor(engine: EngineBase, tag: string) {\n    this.engine = engine;\n    this.tag = tag;\n    this._isAlive = true;\n  }\n\n  async query(query: string, tag?: string): Promise<QueryResult> {\n    if (!this._isAlive) {\n      throw new Error(`EngineProxy ${this.tag} was disposed.`);\n    }\n    return await this.engine.query(query, tag);\n  }\n\n  async tryQuery(query: string, tag?: string): Promise<Result<QueryResult>> {\n    if (!this._isAlive) {\n      return errResult(`EngineProxy ${this.tag} was disposed`);\n    }\n    return await this.engine.tryQuery(query, tag);\n  }\n\n  async computeMetric(\n    metrics: string[],\n    format: 'json' | 'prototext' | 'proto',\n  ): Promise<string | Uint8Array> {\n    if (!this._isAlive) {\n      return Promise.reject(new Error(`EngineProxy ${this.tag} was disposed.`));\n    }\n    return this.engine.computeMetric(metrics, format);\n  }\n\n  enableMetatrace(categories?: protos.MetatraceCategories): void {\n    this.engine.enableMetatrace(categories);\n  }\n\n  stopAndGetMetatrace(): Promise<protos.DisableAndReadMetatraceResult> {\n    return this.engine.stopAndGetMetatrace();\n  }\n\n  get engineId(): string {\n    return this.engine.id;\n  }\n\n  getProxy(tag: string): EngineProxy {\n    return this.engine.getProxy(`${this.tag}/${tag}`);\n  }\n\n  get numRequestsPending() {\n    return this.engine.numRequestsPending;\n  }\n\n  get mode() {\n    return this.engine.mode;\n  }\n\n  get failed() {\n    return this.engine.failed;\n  }\n\n  [Symbol.dispose]() {\n    this._isAlive = false;\n  }\n}\n\n// Capture stack trace and attach to the given error object\nfunction captureStackTrace(e: Error): void {\n  const stack = new Error().stack;\n  if ('captureStackTrace' in Error) {\n    // V8 specific\n    Error.captureStackTrace(e, captureStackTrace);\n  } else {\n    // Generic\n    Object.defineProperty(e, 'stack', {\n      value: stack,\n      writable: true,\n      configurable: true,\n    });\n  }\n}\n\n// A convenience interface to inject the App in Mithril components.\nexport interface EngineAttrs {\n  engine: Engine;\n}\n"]}