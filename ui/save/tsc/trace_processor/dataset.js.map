{"version":3,"file":"dataset.js","sourceRoot":"","sources":["../../../src/trace_processor/dataset.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assertUnreachable} from '../base/logging';\nimport {getOrCreate} from '../base/utils';\nimport {ColumnType, SqlValue} from './query_result';\n\n/**\n * A dataset defines a set of rows in TraceProcessor and a schema of the\n * resultant columns. Dataset implementations describe how to get the data in\n * different ways - e.g. 'source' datasets define a dataset as a table name (or\n * select statement) + filters, whereas a 'union' dataset defines a dataset as\n * the union of other datasets.\n *\n * The idea is that users can build arbitrarily complex trees of datasets, then\n * at any point call `optimize()` to create the smallest possible tree that\n * represents the same dataset, and `query()` which produces a select statement\n * for the resultant dataset.\n *\n * Users can also use the `schema` property and `implements()` to get and test\n * the schema of a given dataset.\n */\nexport interface Dataset {\n  /**\n   * Get or calculate the resultant schema of this dataset.\n   */\n  readonly schema: DatasetSchema;\n\n  /**\n   * Produce a query for this dataset.\n   *\n   * @param schema - The schema to use for extracting columns - if undefined,\n   * the most specific possible schema is evaluated from the dataset first and\n   * used instead.\n   */\n  query(schema?: DatasetSchema): string;\n\n  /**\n   * Optimizes a dataset into the smallest possible expression.\n   *\n   * For example by combining elements of union data sets that have the same src\n   * and similar filters into a single set.\n   *\n   * For example, the following 'union' dataset...\n   *\n   * ```\n   * {\n   *   union: [\n   *     {\n   *       src: 'foo',\n   *       schema: {\n   *         'a': NUM,\n   *         'b': NUM,\n   *       },\n   *       filter: {col: 'a', eq: 1},\n   *     },\n   *     {\n   *       src: 'foo',\n   *       schema: {\n   *         'a': NUM,\n   *         'b': NUM,\n   *       },\n   *       filter: {col: 'a', eq: 2},\n   *     },\n   *   ]\n   * }\n   * ```\n   *\n   * ...will be combined into a single 'source' dataset...\n   *\n   * ```\n   * {\n   *   src: 'foo',\n   *   schema: {\n   *     'a': NUM,\n   *     'b': NUM,\n   *   },\n   *   filter: {col: 'a', in: [1, 2]},\n   * },\n   * ```\n   */\n  optimize(): Dataset;\n\n  /**\n   * Returns true if this dataset implements a given schema.\n   *\n   * @param schema - The schema to test against.\n   */\n  implements(schema: DatasetSchema): boolean;\n}\n\n/**\n * Defines a list of columns and types that define the shape of the data\n * represented by a dataset.\n */\nexport type DatasetSchema = Record<string, ColumnType>;\n\n/**\n * A filter used to express that a column must equal a value.\n */\ninterface EqFilter {\n  readonly col: string;\n  readonly eq: SqlValue;\n}\n\n/**\n * A filter used to express that column must be one of a set of values.\n */\ninterface InFilter {\n  readonly col: string;\n  readonly in: ReadonlyArray<SqlValue>;\n}\n\n/**\n * Union of all filter types.\n */\ntype Filter = EqFilter | InFilter;\n\n/**\n * Named arguments for a SourceDataset.\n */\ninterface SourceDatasetConfig {\n  readonly src: string;\n  readonly schema: DatasetSchema;\n  readonly filter?: Filter;\n}\n\n/**\n * Defines a dataset with a source SQL select statement of table name, a\n * schema describing the columns, and an optional filter.\n */\nexport class SourceDataset implements Dataset {\n  readonly src: string;\n  readonly schema: DatasetSchema;\n  readonly filter?: Filter;\n\n  constructor(config: SourceDatasetConfig) {\n    this.src = config.src;\n    this.schema = config.schema;\n    this.filter = config.filter;\n  }\n\n  query(schema?: DatasetSchema) {\n    schema = schema ?? this.schema;\n    const cols = Object.keys(schema);\n    const whereClause = this.filterToQuery();\n    return `select ${cols.join(', ')} from (${this.src}) ${whereClause}`.trim();\n  }\n\n  optimize() {\n    // Cannot optimize SourceDataset\n    return this;\n  }\n\n  implements(schema: DatasetSchema) {\n    return Object.entries(schema).every(([name, kind]) => {\n      return name in this.schema && this.schema[name] === kind;\n    });\n  }\n\n  private filterToQuery() {\n    const filter = this.filter;\n    if (filter === undefined) {\n      return '';\n    }\n    if ('eq' in filter) {\n      return `where ${filter.col} = ${filter.eq}`;\n    } else if ('in' in filter) {\n      return `where ${filter.col} in (${filter.in.join(',')})`;\n    } else {\n      assertUnreachable(filter);\n    }\n  }\n}\n\n/**\n * A dataset that represents the union of multiple datasets.\n */\nexport class UnionDataset implements Dataset {\n  constructor(readonly union: ReadonlyArray<Dataset>) {}\n\n  get schema(): DatasetSchema {\n    // Find the minimal set of columns that are supported by all datasets of\n    // the union\n    let sch: Record<string, ColumnType> | undefined = undefined;\n    this.union.forEach((ds) => {\n      const dsSchema = ds.schema;\n      if (sch === undefined) {\n        // First time just use this one\n        sch = dsSchema;\n      } else {\n        const newSch: Record<string, ColumnType> = {};\n        for (const [key, kind] of Object.entries(sch)) {\n          if (key in dsSchema && dsSchema[key] === kind) {\n            newSch[key] = kind;\n          }\n        }\n        sch = newSch;\n      }\n    });\n    return sch ?? {};\n  }\n\n  query(schema?: DatasetSchema): string {\n    schema = schema ?? this.schema;\n    return this.union\n      .map((dataset) => dataset.query(schema))\n      .join(' union all ');\n  }\n\n  optimize(): Dataset {\n    // Recursively optimize each dataset of this union\n    const optimizedUnion = this.union.map((ds) => ds.optimize());\n\n    // Find all source datasets and combine then based on src\n    const combinedSrcSets = new Map<string, SourceDataset[]>();\n    const otherDatasets: Dataset[] = [];\n    for (const e of optimizedUnion) {\n      if (e instanceof SourceDataset) {\n        const set = getOrCreate(combinedSrcSets, e.src, () => []);\n        set.push(e);\n      } else {\n        otherDatasets.push(e);\n      }\n    }\n\n    const mergedSrcSets = Array.from(combinedSrcSets.values()).map(\n      (srcGroup) => {\n        if (srcGroup.length === 1) return srcGroup[0];\n\n        // Combine schema across all members in the union\n        const combinedSchema = srcGroup.reduce((acc, e) => {\n          Object.assign(acc, e.schema);\n          return acc;\n        }, {} as DatasetSchema);\n\n        // Merge filters for the same src\n        const inFilters: InFilter[] = [];\n        for (const {filter} of srcGroup) {\n          if (filter) {\n            if ('eq' in filter) {\n              inFilters.push({col: filter.col, in: [filter.eq]});\n            } else {\n              inFilters.push(filter);\n            }\n          }\n        }\n\n        const mergedFilter = mergeFilters(inFilters);\n        return new SourceDataset({\n          src: srcGroup[0].src,\n          schema: combinedSchema,\n          filter: mergedFilter,\n        });\n      },\n    );\n\n    const finalUnion = [...mergedSrcSets, ...otherDatasets];\n\n    if (finalUnion.length === 1) {\n      return finalUnion[0];\n    } else {\n      return new UnionDataset(finalUnion);\n    }\n  }\n\n  implements(schema: DatasetSchema) {\n    return Object.entries(schema).every(([name, kind]) => {\n      return name in this.schema && this.schema[name] === kind;\n    });\n  }\n}\n\nfunction mergeFilters(filters: InFilter[]): InFilter | undefined {\n  if (filters.length === 0) return undefined;\n  const col = filters[0].col;\n  const values = new Set(filters.flatMap((filter) => filter.in));\n  return {col, in: Array.from(values)};\n}\n"]}