{"version":3,"file":"proto_ring_buffer.js","sourceRoot":"","sources":["../../../src/trace_processor/proto_ring_buffer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assertTrue} from '../base/logging';\n\n// This class is the TypeScript equivalent of the identically-named C++ class in\n// //protozero/proto_ring_buffer.h. See comments in that header for a detailed\n// description. The architecture is identical.\n\nconst kGrowBytes = 128 * 1024;\nconst kMaxMsgSize = 1024 * 1024 * 1024;\n\nexport class ProtoRingBuffer {\n  private buf = new Uint8Array(kGrowBytes);\n  private fastpath?: Uint8Array;\n  private rd = 0;\n  private wr = 0;\n\n  // The caller must call ReadMessage() after each append() call.\n  // The |data| might be either copied in the internal ring buffer or returned\n  // (% subarray()) to the next ReadMessage() call.\n  append(data: Uint8Array) {\n    assertTrue(this.wr <= this.buf.length);\n    assertTrue(this.rd <= this.wr);\n\n    // If the last call to ReadMessage() consumed all the data in the buffer and\n    // there are no incomplete messages pending, restart from the beginning\n    // rather than keep ringing. This is the most common case.\n    if (this.rd === this.wr) {\n      this.rd = this.wr = 0;\n    }\n\n    // The caller is expected to issue a ReadMessage() after each append().\n    const dataLen = data.length;\n    if (dataLen === 0) return;\n    assertTrue(this.fastpath === undefined);\n    if (this.rd === this.wr) {\n      const msg = ProtoRingBuffer.tryReadMessage(data, 0, dataLen);\n      if (\n        msg !== undefined &&\n        msg.byteOffset + msg.length === data.byteOffset + dataLen\n      ) {\n        // Fastpath: in many cases, the underlying stream will effectively\n        // preserve the atomicity of messages for most small messages.\n        // In this case we can avoid the extra buffer roundtrip and return the\n        // original array (actually a subarray that skips the proto header).\n        // The next call to ReadMessage() will return this.\n        this.fastpath = msg;\n        return;\n      }\n    }\n\n    let avail = this.buf.length - this.wr;\n    if (dataLen > avail) {\n      // This whole section should be hit extremely rarely.\n\n      // Try first just recompacting the buffer by moving everything to the\n      // left. This can happen if we received \"a message and a bit\" on each\n      // append() call.\n      this.buf.copyWithin(0, this.rd, this.wr);\n      avail += this.rd;\n      this.wr -= this.rd;\n      this.rd = 0;\n      if (dataLen > avail) {\n        // Still not enough, expand the buffer.\n        let newSize = this.buf.length;\n        while (dataLen > newSize - this.wr) {\n          newSize += kGrowBytes;\n        }\n        assertTrue(newSize <= kMaxMsgSize * 2);\n        const newBuf = new Uint8Array(newSize);\n        newBuf.set(this.buf);\n        this.buf = newBuf;\n        // No need to touch rd / wr.\n      }\n    }\n\n    // Append the received data at the end of the ring buffer.\n    this.buf.set(data, this.wr);\n    this.wr += dataLen;\n  }\n\n  // Tries to extract a message from the ring buffer. If there is no message,\n  // or if the current message is still incomplete, returns undefined.\n  // The caller is expected to call this in a loop until it returns undefined.\n  // Note that a single write to Append() can yield more than one message\n  // (see ProtoRingBufferTest.CoalescingStream in the unittest).\n  readMessage(): Uint8Array | undefined {\n    if (this.fastpath !== undefined) {\n      assertTrue(this.rd === this.wr);\n      const msg = this.fastpath;\n      this.fastpath = undefined;\n      return msg;\n    }\n    assertTrue(this.rd <= this.wr);\n    if (this.rd >= this.wr) {\n      return undefined; // Completely empty.\n    }\n    const msg = ProtoRingBuffer.tryReadMessage(this.buf, this.rd, this.wr);\n    if (msg === undefined) return undefined;\n    assertTrue(msg.buffer === this.buf.buffer);\n    assertTrue(this.buf.byteOffset === 0);\n    this.rd = msg.byteOffset + msg.length;\n\n    // Deliberately returning a copy of the data with slice(). In various cases\n    // (streaming query response) the caller will hold onto the returned buffer.\n    // If we get to this point, |msg| is a view of the circular buffer that we\n    // will overwrite on the next calls to append().\n    return msg.slice();\n  }\n\n  private static tryReadMessage(\n    data: Uint8Array,\n    dataStart: number,\n    dataEnd: number,\n  ): Uint8Array | undefined {\n    assertTrue(dataEnd <= data.length);\n    let pos = dataStart;\n    if (pos >= dataEnd) return undefined;\n    const tag = data[pos++]; // Assume one-byte tag.\n    if (tag >= 0x80 || (tag & 0x07) !== 2 /* len delimited */) {\n      throw new Error(\n        `RPC framing error, unexpected tag ${tag} @ offset ${pos - 1}`,\n      );\n    }\n\n    let len = 0;\n    for (let shift = 0 /* no check */; ; shift += 7) {\n      if (pos >= dataEnd) {\n        return undefined; // Not enough data to read varint.\n      }\n      const val = data[pos++];\n      len |= ((val & 0x7f) << shift) >>> 0;\n      if (val < 0x80) break;\n    }\n\n    if (len >= kMaxMsgSize) {\n      throw new Error(\n        `RPC framing error, message too large (${len} > ${kMaxMsgSize}`,\n      );\n    }\n    const end = pos + len;\n    if (end > dataEnd) return undefined;\n\n    // This is a subarray() and not a slice() because in the |fastpath| case\n    // we want to just return the original buffer pushed by append().\n    // In the slow-path (ring-buffer) case, the readMessage() above will create\n    // a copy via slice() before returning it.\n    return data.subarray(pos, end);\n  }\n}\n"]}