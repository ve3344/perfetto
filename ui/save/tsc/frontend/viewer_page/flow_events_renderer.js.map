{"version":3,"file":"flow_events_renderer.js","sourceRoot":"","sources":["../../../../src/frontend/viewer_page/flow_events_renderer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use size file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {ArrowHeadStyle, drawBezierArrow} from '../../base/canvas/bezier_arrow';\nimport {HorizontalBounds, Point2D, Size2D} from '../../base/geom';\nimport {TimeScale} from '../../base/time_scale';\nimport {Flow} from '../../core/flow_types';\nimport {TraceImpl} from '../../core/trace_impl';\nimport {TrackNode} from '../../public/workspace';\nimport {ALL_CATEGORIES, getFlowCategories} from '../flow_events_panel';\nimport {RenderedPanelInfo} from './panel_container';\n\nconst TRACK_GROUP_CONNECTION_OFFSET = 5;\nconst TRIANGLE_SIZE = 5;\nconst CIRCLE_RADIUS = 3;\nconst BEZIER_OFFSET = 30;\n\nconst CONNECTED_FLOW_HUE = 10;\nconst SELECTED_FLOW_HUE = 230;\n\nconst DEFAULT_FLOW_WIDTH = 2;\nconst FOCUSED_FLOW_WIDTH = 3;\n\nconst HIGHLIGHTED_FLOW_INTENSITY = 45;\nconst FOCUSED_FLOW_INTENSITY = 55;\nconst DEFAULT_FLOW_INTENSITY = 70;\n\ntype VerticalEdgeOrPoint =\n  | ({kind: 'vertical_edge'} & Point2D)\n  | ({kind: 'point'} & Point2D);\n\n/**\n * Renders the flows overlay on top of the timeline, given the set of panels and\n * a canvas to draw on.\n *\n * Note: the actual flow data is retrieved from trace.flows, which are produced\n * by FlowManager.\n *\n * @param trace - The Trace instance, which holds onto the FlowManager.\n * @param ctx - The canvas to draw on.\n * @param size - The size of the canvas.\n * @param panels - A list of panels and their locations on the canvas.\n */\nexport function renderFlows(\n  trace: TraceImpl,\n  ctx: CanvasRenderingContext2D,\n  size: Size2D,\n  panels: ReadonlyArray<RenderedPanelInfo>,\n  trackRoot: TrackNode,\n): void {\n  const timescale = new TimeScale(trace.timeline.visibleWindow, {\n    left: 0,\n    right: size.width,\n  });\n\n  // Create an index of track node instances to panels. This doesn't need to be\n  // a WeakMap because it's thrown away every render cycle.\n  const panelsByTrackNode = new Map(\n    panels.map((panel) => [panel.panel.trackNode, panel]),\n  );\n\n  const drawFlow = (flow: Flow, hue: number) => {\n    const flowStartTs =\n      flow.flowToDescendant || flow.begin.sliceStartTs >= flow.end.sliceStartTs\n        ? flow.begin.sliceStartTs\n        : flow.begin.sliceEndTs;\n\n    const flowEndTs = flow.end.sliceStartTs;\n\n    const startX = timescale.timeToPx(flowStartTs);\n    const endX = timescale.timeToPx(flowEndTs);\n\n    const flowBounds = {\n      left: Math.min(startX, endX),\n      right: Math.max(startX, endX),\n    };\n\n    if (!isInViewport(flowBounds, size)) {\n      return;\n    }\n\n    const highlighted =\n      flow.end.sliceId === trace.timeline.highlightedSliceId ||\n      flow.begin.sliceId === trace.timeline.highlightedSliceId;\n    const focused =\n      flow.id === trace.flows.focusedFlowIdLeft ||\n      flow.id === trace.flows.focusedFlowIdRight;\n\n    let intensity = DEFAULT_FLOW_INTENSITY;\n    let width = DEFAULT_FLOW_WIDTH;\n    if (focused) {\n      intensity = FOCUSED_FLOW_INTENSITY;\n      width = FOCUSED_FLOW_WIDTH;\n    }\n    if (highlighted) {\n      intensity = HIGHLIGHTED_FLOW_INTENSITY;\n    }\n\n    const start = getConnectionTarget(\n      flow.begin.trackUri,\n      flow.begin.depth,\n      startX,\n    );\n    const end = getConnectionTarget(flow.end.trackUri, flow.end.depth, endX);\n\n    if (start && end) {\n      drawArrow(ctx, start, end, intensity, hue, width);\n    }\n  };\n\n  const getConnectionTarget = (\n    trackUri: string | undefined,\n    depth: number,\n    x: number,\n  ): VerticalEdgeOrPoint | undefined => {\n    if (trackUri === undefined) {\n      return undefined;\n    }\n\n    const track = trackRoot.findTrackByUri(trackUri);\n    if (!track) {\n      return undefined;\n    }\n\n    const trackPanel = panelsByTrackNode.get(track);\n    if (trackPanel) {\n      const trackRect = trackPanel.rect;\n      const sliceRectRaw = trackPanel.panel.getSliceVerticalBounds?.(depth);\n      if (sliceRectRaw) {\n        const sliceRect = {\n          top: sliceRectRaw.top + trackRect.top,\n          bottom: sliceRectRaw.bottom + trackRect.top,\n        };\n        return {\n          kind: 'vertical_edge',\n          x,\n          y: (sliceRect.top + sliceRect.bottom) / 2,\n        };\n      } else {\n        // Slice bounds are not available for this track, so just put the target\n        // in the middle of the track\n        return {\n          kind: 'vertical_edge',\n          x,\n          y: (trackRect.top + trackRect.bottom) / 2,\n        };\n      }\n    } else {\n      // If we didn't find a track, it might inside a group, so check for the group\n      const containerNode = track.findClosestVisibleAncestor();\n      const groupPanel = panelsByTrackNode.get(containerNode);\n      if (groupPanel) {\n        return {\n          kind: 'point',\n          x,\n          y: groupPanel.rect.bottom - TRACK_GROUP_CONNECTION_OFFSET,\n        };\n      }\n    }\n\n    return undefined;\n  };\n\n  // Render the connected flows\n  trace.flows.connectedFlows.forEach((flow) => {\n    drawFlow(flow, CONNECTED_FLOW_HUE);\n  });\n\n  // Render the selected flows\n  trace.flows.selectedFlows.forEach((flow) => {\n    const categories = getFlowCategories(flow);\n    for (const cat of categories) {\n      if (\n        trace.flows.visibleCategories.get(cat) ||\n        trace.flows.visibleCategories.get(ALL_CATEGORIES)\n      ) {\n        drawFlow(flow, SELECTED_FLOW_HUE);\n        break;\n      }\n    }\n  });\n}\n\n// Check if an object defined by the horizontal bounds |bounds| is inside the\n// viewport defined by |viewportSizeZ.\nfunction isInViewport(bounds: HorizontalBounds, viewportSize: Size2D): boolean {\n  return bounds.right >= 0 && bounds.left < viewportSize.width;\n}\n\nfunction drawArrow(\n  ctx: CanvasRenderingContext2D,\n  start: VerticalEdgeOrPoint,\n  end: VerticalEdgeOrPoint,\n  intensity: number,\n  hue: number,\n  width: number,\n): void {\n  ctx.strokeStyle = `hsl(${hue}, 50%, ${intensity}%)`;\n  ctx.fillStyle = `hsl(${hue}, 50%, ${intensity}%)`;\n  ctx.lineWidth = width;\n\n  // TODO(stevegolton): Consider vertical distance too\n  const roomForArrowHead = Math.abs(start.x - end.x) > 3 * TRIANGLE_SIZE;\n\n  let startStyle: ArrowHeadStyle;\n  if (start.kind === 'vertical_edge') {\n    startStyle = {\n      orientation: 'east',\n      shape: 'none',\n    };\n  } else {\n    startStyle = {\n      orientation: 'auto_vertical',\n      shape: 'circle',\n      size: CIRCLE_RADIUS,\n    };\n  }\n\n  let endStyle: ArrowHeadStyle;\n  if (end.kind === 'vertical_edge') {\n    endStyle = {\n      orientation: 'west',\n      shape: roomForArrowHead ? 'triangle' : 'none',\n      size: TRIANGLE_SIZE,\n    };\n  } else {\n    endStyle = {\n      orientation: 'auto_vertical',\n      shape: 'circle',\n      size: CIRCLE_RADIUS,\n    };\n  }\n\n  drawBezierArrow(ctx, start, end, BEZIER_OFFSET, startStyle, endStyle);\n}\n"]}