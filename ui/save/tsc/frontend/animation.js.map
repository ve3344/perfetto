{"version":3,"file":"animation.js","sourceRoot":"","sources":["../../../src/frontend/animation.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AAEjC,yDAA0C;AAE1C,MAAa,SAAS;IAKA;IAJZ,OAAO,GAAG,CAAC,CAAC;IACZ,KAAK,GAAG,CAAC,CAAC;IACV,qBAAqB,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAEjE,YAAoB,eAAmD;QAAnD,oBAAe,GAAf,eAAe,CAAoC;IAAG,CAAC;IAE3E,KAAK,CAAC,UAAkB;QACtB,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QAEhC,mEAAmE;QACnE,IAAI,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YACxB,IAAI,CAAC,KAAK,GAAG,KAAK,GAAG,UAAU,CAAC;YAChC,OAAO;QACT,CAAC;QACD,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,GAAG,UAAU,CAAC;QAChC,mBAAG,CAAC,cAAc,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;IACjD,CAAC;IAED,IAAI;QACF,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QACf,mBAAG,CAAC,aAAa,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;IAChD,CAAC;IAED,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAEO,gBAAgB,CAAC,KAAa;QACpC,IAAI,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YACxB,mBAAG,CAAC,aAAa,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAC9C,OAAO;QACT,CAAC;QACD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACtE,CAAC;CACF;AApCD,8BAoCC","sourcesContent":["// Copyright (C) 2018 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {raf} from '../core/raf_scheduler';\n\nexport class Animation {\n  private startMs = 0;\n  private endMs = 0;\n  private boundOnAnimationFrame = this.onAnimationFrame.bind(this);\n\n  constructor(private onAnimationStep: (timeSinceStartMs: number) => void) {}\n\n  start(durationMs: number) {\n    const nowMs = performance.now();\n\n    // If the animation is already happening, just update its end time.\n    if (nowMs <= this.endMs) {\n      this.endMs = nowMs + durationMs;\n      return;\n    }\n    this.startMs = nowMs;\n    this.endMs = nowMs + durationMs;\n    raf.startAnimation(this.boundOnAnimationFrame);\n  }\n\n  stop() {\n    this.endMs = 0;\n    raf.stopAnimation(this.boundOnAnimationFrame);\n  }\n\n  get startTimeMs(): number {\n    return this.startMs;\n  }\n\n  private onAnimationFrame(nowMs: number) {\n    if (nowMs >= this.endMs) {\n      raf.stopAnimation(this.boundOnAnimationFrame);\n      return;\n    }\n    this.onAnimationStep(Math.max(Math.round(nowMs - this.startMs), 0));\n  }\n}\n"]}