{"version":3,"file":"trace_url_handler.js","sourceRoot":"","sources":["../../../src/frontend/trace_url_handler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\nimport {tryGetTrace} from '../core/cache_manager';\nimport {showModal} from '../widgets/modal';\nimport {loadPermalink} from './permalink';\nimport {loadAndroidBugToolInfo} from './android_bug_tool';\nimport {Route, Router} from '../core/router';\nimport {taskTracker} from './task_tracker';\nimport {AppImpl} from '../core/app_impl';\n\nfunction getCurrentTraceUrl(): undefined | string {\n  const source = AppImpl.instance.trace?.traceInfo.source;\n  if (source && source.type === 'URL') {\n    return source.url;\n  }\n  return undefined;\n}\n\nexport function maybeOpenTraceFromRoute(route: Route) {\n  if (route.args.s) {\n    // /?s=xxxx for permalinks.\n    loadPermalink(route.args.s);\n    return;\n  }\n\n  const url = route.args.url;\n  if (url && url !== getCurrentTraceUrl()) {\n    // /?url=https://commondatastorage.googleapis.com/bucket/trace\n    // This really works only for GCS because the Content Security Policy\n    // forbids any other url.\n    loadTraceFromUrl(url);\n    return;\n  }\n\n  if (route.args.openFromAndroidBugTool) {\n    // Handles interaction with the Android Bug Tool extension. See b/163421158.\n    openTraceFromAndroidBugTool();\n    return;\n  }\n\n  if (route.args.p && route.page === '/record') {\n    // Handles backwards compatibility for old URLs (linked from various docs),\n    // generated before we switched URL scheme. e.g., 'record?p=power' vs\n    // 'record/power'. See b/191255021#comment2.\n    Router.navigate(`#!/record/${route.args.p}`);\n    return;\n  }\n\n  if (route.args.local_cache_key) {\n    // Handles the case of loading traces from the cache storage.\n    maybeOpenCachedTrace(route.args.local_cache_key);\n    return;\n  }\n}\n\n/*\n * openCachedTrace(uuid) is called: (1) on startup, from frontend/index.ts; (2)\n * every time the fragment changes (from Router.onRouteChange).\n * This function must be idempotent (imagine this is called on every frame).\n * It must take decision based on the app state, not on URL change events.\n * Fragment changes are handled by the union of Router.onHashChange() and this\n * function, as follows:\n * 1. '' -> URL without a ?local_cache_key=xxx arg:\n *  - no effect (except redrawing)\n * 2. URL without local_cache_key -> URL with local_cache_key:\n *  - Load cached trace (without prompting any dialog).\n *  - Show a (graceful) error dialog in the case of cache misses.\n * 3. '' -> URL with a ?local_cache_key=xxx arg:\n *  - Same as case 2.\n * 4. URL with local_cache_key=1 -> URL with local_cache_key=2:\n *  a) If 2 != uuid of the trace currently loaded (TraceImpl.traceInfo.uuid):\n *  - Ask the user if they intend to switch trace and load 2.\n *  b) If 2 == uuid of current trace (e.g., after a new trace has loaded):\n *  - no effect (except redrawing).\n * 5. URL with local_cache_key -> URL without local_cache_key:\n *  - Redirect to ?local_cache_key=1234 where 1234 is the UUID of the previous\n *    URL (this might or might not match traceInfo.uuid).\n *\n * Backward navigation cases:\n * 6. URL without local_cache_key <- URL with local_cache_key:\n *  - Same as case 5.\n * 7. URL with local_cache_key=1 <- URL with local_cache_key=2:\n *  - Same as case 4a: go back to local_cache_key=1 but ask the user to confirm.\n * 8. landing page <- URL with local_cache_key:\n *  - Same as case 5: re-append the local_cache_key.\n */\nasync function maybeOpenCachedTrace(traceUuid: string) {\n  const curTrace = AppImpl.instance.trace?.traceInfo;\n  const curCacheUuid = curTrace?.cached ? curTrace.uuid : '';\n\n  if (traceUuid === curCacheUuid) {\n    // Do nothing, matches the currently loaded trace.\n    return;\n  }\n\n  if (traceUuid === '') {\n    // This can happen if we switch from an empty UI state to an invalid UUID\n    // (e.g. due to a cache miss, below). This can also happen if the user just\n    // types /#!/viewer?local_cache_key=.\n    return;\n  }\n\n  // This handles the case when a trace T1 is loaded and then the url is set to\n  // ?local_cache_key=T2. In that case globals.state.traceUuid remains set to T1\n  // until T2 has been loaded by the trace processor (can take several seconds).\n  // This early out prevents to re-trigger the openTraceFromXXX() action if the\n  // URL changes (e.g. if the user navigates back/fwd) while the new trace is\n  // being loaded.\n  if (\n    curTrace !== undefined &&\n    curTrace.source.type === 'ARRAY_BUFFER' &&\n    curTrace.source.uuid === traceUuid\n  ) {\n    return;\n  }\n\n  // Fetch the trace from the cache storage. If available load it. If not, show\n  // a dialog informing the user about the cache miss.\n  const maybeTrace = await tryGetTrace(traceUuid);\n\n  const navigateToOldTraceUuid = () =>\n    Router.navigate(`#!/viewer?local_cache_key=${curCacheUuid}`);\n\n  if (!maybeTrace) {\n    showModal({\n      title: 'Could not find the trace in the cache storage',\n      content: m(\n        'div',\n        m(\n          'p',\n          'You are trying to load a cached trace by setting the ' +\n            '?local_cache_key argument in the URL.',\n        ),\n        m('p', \"Unfortunately the trace wasn't in the cache storage.\"),\n        m(\n          'p',\n          \"This can happen if a tab was discarded and wasn't opened \" +\n            'for too long, or if you just mis-pasted the URL.',\n        ),\n        m('pre', `Trace UUID: ${traceUuid}`),\n      ),\n    });\n    navigateToOldTraceUuid();\n    return;\n  }\n\n  // If the UI is in a blank state (no trace has been ever opened), just load\n  // the trace without showing any further dialog. This is the case of tab\n  // discarding, reloading or pasting a url with a local_cache_key in an empty\n  // instance.\n  if (curTrace === undefined) {\n    AppImpl.instance.openTraceFromBuffer(maybeTrace);\n    return;\n  }\n\n  // If, instead, another trace is loaded, ask confirmation to the user.\n  // Switching to another trace clears the UI state. It can be quite annoying to\n  // lose the UI state by accidentally navigating back too much.\n  let hasOpenedNewTrace = false;\n\n  await showModal({\n    title: 'You are about to load a different trace and reset the UI state',\n    content: m(\n      'div',\n      m(\n        'p',\n        'You are seeing this because you either pasted a URL with ' +\n          'a different ?local_cache_key=xxx argument or because you hit ' +\n          'the history back/fwd button and reached a different trace.',\n      ),\n      m(\n        'p',\n        'If you continue another trace will be loaded and the UI ' +\n          'state will be cleared.',\n      ),\n      m(\n        'pre',\n        `Old trace: ${curTrace !== undefined ? curCacheUuid : '<no trace>'}\\n` +\n          `New trace: ${traceUuid}`,\n      ),\n    ),\n    buttons: [\n      {\n        text: 'Continue',\n        id: 'trace_id_open', // Used by tests.\n        primary: true,\n        action: () => {\n          hasOpenedNewTrace = true;\n          AppImpl.instance.openTraceFromBuffer(maybeTrace);\n        },\n      },\n      {text: 'Cancel'},\n    ],\n  });\n\n  if (!hasOpenedNewTrace) {\n    // We handle this after the modal await rather than in the cancel button\n    // action so this has effect even if the user clicks Esc or clicks outside\n    // of the modal dialog and dismisses it.\n    navigateToOldTraceUuid();\n  }\n}\n\nfunction loadTraceFromUrl(url: string) {\n  const isLocalhostTraceUrl = ['127.0.0.1', 'localhost'].includes(\n    new URL(url).hostname,\n  );\n\n  if (isLocalhostTraceUrl) {\n    // This handles the special case of tools/record_android_trace serving the\n    // traces from a local webserver and killing it immediately after having\n    // seen the HTTP GET request. In those cases store the trace as a file, so\n    // when users click on share we don't fail the re-fetch().\n    const fileName = url.split('/').pop() ?? 'local_trace.pftrace';\n    const request = fetch(url)\n      .then((response) => response.blob())\n      .then((b) => AppImpl.instance.openTraceFromFile(new File([b], fileName)))\n      .catch((e) => alert(`Could not load local trace ${e}`));\n    taskTracker.trackPromise(request, 'Downloading local trace');\n  } else {\n    AppImpl.instance.openTraceFromUrl(url);\n  }\n}\n\nfunction openTraceFromAndroidBugTool() {\n  const msg = 'Loading trace from ABT extension';\n  AppImpl.instance.omnibox.showStatusMessage(msg);\n  const loadInfo = loadAndroidBugToolInfo();\n  taskTracker.trackPromise(loadInfo, msg);\n  loadInfo\n    .then((info) => AppImpl.instance.openTraceFromFile(info.file))\n    .catch((e) => console.error(e));\n}\n"]}