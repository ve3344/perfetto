{"version":3,"file":"permalink.js","sourceRoot":"","sources":["../../../src/frontend/permalink.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\nimport {assertExists} from '../base/logging';\nimport {\n  JsonSerialize,\n  parseAppState,\n  serializeAppState,\n} from '../core/state_serialization';\nimport {\n  BUCKET_NAME,\n  MIME_BINARY,\n  MIME_JSON,\n  GcsUploader,\n} from '../base/gcs_uploader';\nimport {\n  SERIALIZED_STATE_VERSION,\n  SerializedAppState,\n} from '../core/state_serialization_schema';\nimport {z} from 'zod';\nimport {showModal} from '../widgets/modal';\nimport {AppImpl} from '../core/app_impl';\nimport {CopyableLink} from '../widgets/copyable_link';\n\n// Permalink serialization has two layers:\n// 1. Serialization of the app state (state_serialization.ts):\n//    This is a JSON object that represents the visual app state (pinned tracks,\n//    visible viewport bounds, etc) BUT not the trace source.\n// 2. An outer layer that contains the app state AND a link to the trace file.\n//    (This file)\n//\n// In a nutshell:\n//   AppState:  {viewport: {...}, pinnedTracks: {...}, notes: {...}}\n//   Permalink: {appState: {see above}, traceUrl: 'https://gcs/trace/file'}\n//\n// This file deals with the outer layer, state_serialization.ts with the inner.\n\nconst PERMALINK_SCHEMA = z.object({\n  traceUrl: z.string().optional(),\n\n  // We don't want to enforce validation at this level but want to delegate it\n  // to parseAppState(), for two reasons:\n  // 1. parseAppState() does further semantic checks (e.g. version checking).\n  // 2. We want to still load the traceUrl even if the app state is invalid.\n  appState: z.any().optional(),\n});\n\ntype PermalinkState = z.infer<typeof PERMALINK_SCHEMA>;\n\nexport async function createPermalink(): Promise<void> {\n  const hash = await createPermalinkInternal();\n  showPermalinkDialog(hash);\n}\n\n// Returns the file name, not the full url (i.e. the name of the GCS object).\nasync function createPermalinkInternal(): Promise<string> {\n  const permalinkData: PermalinkState = {};\n\n  // Check if we need to upload the trace file, before serializing the app\n  // state.\n  let alreadyUploadedUrl = '';\n  const trace = assertExists(AppImpl.instance.trace);\n  const traceSource = trace.traceInfo.source;\n  let dataToUpload: File | ArrayBuffer | undefined = undefined;\n  let traceName = trace.traceInfo.traceTitle || 'trace';\n  if (traceSource.type === 'FILE') {\n    dataToUpload = traceSource.file;\n    traceName = dataToUpload.name;\n  } else if (traceSource.type === 'ARRAY_BUFFER') {\n    dataToUpload = traceSource.buffer;\n  } else if (traceSource.type === 'URL') {\n    alreadyUploadedUrl = traceSource.url;\n  } else {\n    throw new Error(`Cannot share trace ${JSON.stringify(traceSource)}`);\n  }\n\n  // Upload the trace file, unless it's already uploaded (type == 'URL').\n  // Internally TraceGcsUploader will skip the upload if an object with the\n  // same hash exists already.\n  if (alreadyUploadedUrl) {\n    permalinkData.traceUrl = alreadyUploadedUrl;\n  } else if (dataToUpload !== undefined) {\n    updateStatus(`Uploading ${traceName}`);\n    const uploader: GcsUploader = new GcsUploader(dataToUpload, {\n      mimeType: MIME_BINARY,\n      onProgress: () => reportUpdateProgress(uploader),\n    });\n    await uploader.waitForCompletion();\n    permalinkData.traceUrl = uploader.uploadedUrl;\n  }\n\n  permalinkData.appState = serializeAppState(trace);\n\n  // Serialize the permalink with the app state (or recording state) and upload.\n  updateStatus(`Creating permalink...`);\n  const permalinkJson = JsonSerialize(permalinkData);\n  const uploader: GcsUploader = new GcsUploader(permalinkJson, {\n    mimeType: MIME_JSON,\n    onProgress: () => reportUpdateProgress(uploader),\n  });\n  await uploader.waitForCompletion();\n\n  return uploader.uploadedFileName;\n}\n\n/**\n * Loads a permalink from Google Cloud Storage.\n * This is invoked when passing !#?s=fileName to URL.\n * @param gcsFileName the file name of the cloud storage object. This is\n * expected to be a JSON file that respects the schema defined by\n * PERMALINK_SCHEMA.\n */\nexport async function loadPermalink(gcsFileName: string): Promise<void> {\n  // Otherwise, this is a request to load the permalink.\n  const url = `https://storage.googleapis.com/${BUCKET_NAME}/${gcsFileName}`;\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Could not fetch permalink.\\n URL: ${url}`);\n  }\n  const text = await response.text();\n  const permalinkJson = JSON.parse(text);\n  let permalink: PermalinkState;\n  let error = '';\n\n  // Try to recover permalinks generated by older versions of the UI before\n  // r.android.com/3119920 .\n  const convertedLegacyPermalink = tryLoadLegacyPermalink(permalinkJson);\n  if (convertedLegacyPermalink !== undefined) {\n    permalink = convertedLegacyPermalink;\n  } else {\n    const res = PERMALINK_SCHEMA.safeParse(permalinkJson);\n    if (res.success) {\n      permalink = res.data;\n    } else {\n      error = res.error.toString();\n      permalink = {};\n    }\n  }\n\n  let serializedAppState: SerializedAppState | undefined = undefined;\n  if (permalink.appState !== undefined) {\n    // This is the most common case where the permalink contains the app state\n    // (and optionally a traceUrl, below).\n    const parseRes = parseAppState(permalink.appState);\n    if (parseRes.success) {\n      serializedAppState = parseRes.data;\n    } else {\n      error = parseRes.error;\n    }\n  }\n  if (permalink.traceUrl) {\n    AppImpl.instance.openTraceFromUrl(permalink.traceUrl, serializedAppState);\n  }\n\n  if (error) {\n    showModal({\n      title: 'Failed to restore the serialized app state',\n      content: m(\n        'div',\n        m(\n          'p',\n          'Something went wrong when restoring the app state.' +\n            'This is due to some backwards-incompatible change ' +\n            'when the permalink is generated and then opened using ' +\n            'two different UI versions.',\n        ),\n        m(\n          'p',\n          \"I'm going to try to open the trace file anyways, but \" +\n            'the zoom level, pinned tracks and other UI ' +\n            \"state wont't be recovered\",\n        ),\n        m('p', 'Error details:'),\n        m('.modal-logs', error),\n      ),\n      buttons: [\n        {\n          text: 'Open only the trace file',\n          primary: true,\n        },\n      ],\n    });\n  }\n}\n\n// Tries to recover a previous permalink, before the split in two layers,\n// where the permalink JSON contains the app state, which contains inside it\n// the trace URL.\n// If we suceed, convert it to a new-style JSON object preserving some minimal\n// information (really just vieport and pinned tracks).\nfunction tryLoadLegacyPermalink(data: unknown): PermalinkState | undefined {\n  const legacyData = data as {\n    version?: number;\n    engine?: {source?: {url?: string}};\n    pinnedTracks?: string[];\n    frontendLocalState?: {\n      visibleState?: {start?: {value?: string}; end?: {value?: string}};\n    };\n  };\n  if (legacyData.version === undefined) return undefined;\n  const vizState = legacyData.frontendLocalState?.visibleState;\n  return {\n    traceUrl: legacyData.engine?.source?.url,\n    appState: {\n      version: SERIALIZED_STATE_VERSION,\n      pinnedTracks: legacyData.pinnedTracks ?? [],\n      viewport: vizState\n        ? {start: vizState.start?.value, end: vizState.end?.value}\n        : undefined,\n    } as SerializedAppState,\n  } as PermalinkState;\n}\n\nfunction reportUpdateProgress(uploader: GcsUploader) {\n  switch (uploader.state) {\n    case 'UPLOADING':\n      const statusTxt = `Uploading ${uploader.getEtaString()}`;\n      updateStatus(statusTxt);\n      break;\n    case 'ERROR':\n      updateStatus(`Upload failed ${uploader.error}`);\n      break;\n    default:\n      break;\n  } // switch (state)\n}\n\nfunction updateStatus(msg: string): void {\n  AppImpl.instance.omnibox.showStatusMessage(msg);\n}\n\nfunction showPermalinkDialog(hash: string) {\n  showModal({\n    title: 'Permalink',\n    content: m(CopyableLink, {url: `${self.location.origin}/#!/?s=${hash}`}),\n  });\n}\n"]}