{"version":3,"file":"virtual_overlay_canvas.js","sourceRoot":"","sources":["../../../src/widgets/virtual_overlay_canvas.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * VirtualCanvas - A Mithril Component for Virtual Canvas Rendering\n *\n * This module provides a Mithril component that acts as a scrolling container\n * for tall and/or wide content. It overlays a floating canvas on top of its\n * content rendered inside it, which stays in the viewport of scrolling\n * container element as the user scrolls, allowing for rendering of large-scale\n * visualizations which would be too large for a normal HTML canvas element.\n *\n * Key Features:\n * - Supports horizontal, vertical, or both axes scrolling, moving the canvas\n *   while the user scrolls to keep it in the viewport.\n * - Automatically handles canvas resizing using resize observers, including\n *   scaling for high DPI displays.\n * - Calls a callback whenever the canvas needs to be redrawn.\n */\n\nimport m from 'mithril';\nimport {DisposableStack} from '../base/disposable_stack';\nimport {findRef, toHTMLElement} from '../base/dom_utils';\nimport {Rect2D, Size2D} from '../base/geom';\nimport {assertExists} from '../base/logging';\nimport {VirtualCanvas} from '../base/virtual_canvas';\n\nconst CANVAS_CONTAINER_REF = 'canvas-container';\nconst CANVAS_OVERDRAW_PX = 300;\nconst CANVAS_TOLERANCE_PX = 100;\n\nexport interface VirtualOverlayCanvasDrawContext {\n  // Canvas rendering context.\n  readonly ctx: CanvasRenderingContext2D;\n\n  // The size of the virtual canvas element.\n  readonly virtualCanvasSize: Size2D;\n\n  // The rect of the actual canvas W.R.T to the virtual canvas element.\n  readonly canvasRect: Rect2D;\n}\n\nexport interface VirtualOverlayCanvasAttrs {\n  // Additional class names applied to the root element.\n  readonly className?: string;\n\n  // Which axes should be scrollable.\n  readonly scrollAxes?: 'none' | 'x' | 'y' | 'both';\n\n  // Called when the canvas needs to be repainted due to a layout shift or\n  // or resize.\n  onCanvasRedraw?(ctx: VirtualOverlayCanvasDrawContext): void;\n\n  // Called when the canvas is resized. This will immediately be followed by a\n  // call to onCanvasRedraw().\n  onCanvasResized?(size: Size2D): void;\n}\n\n// This mithril component acts as scrolling container for tall and/or wide\n// content. Adds a virtually scrolling canvas over the top of any child elements\n// rendered inside it.\nexport class VirtualOverlayCanvas\n  implements m.ClassComponent<VirtualOverlayCanvasAttrs>\n{\n  private readonly trash = new DisposableStack();\n  private ctx?: CanvasRenderingContext2D;\n  private virtualCanvas?: VirtualCanvas;\n  private attrs?: VirtualOverlayCanvasAttrs;\n\n  view({attrs, children}: m.CVnode<VirtualOverlayCanvasAttrs>) {\n    this.attrs = attrs;\n    return m(\n      '.pf-virtual-overlay-canvas', // The scrolling container\n      {\n        className: attrs.className,\n        style: {\n          overflowY:\n            attrs.scrollAxes === 'both' || attrs.scrollAxes === 'y'\n              ? 'auto'\n              : 'visible',\n          overflowX:\n            attrs.scrollAxes === 'both' || attrs.scrollAxes === 'x'\n              ? 'auto'\n              : 'visible',\n        },\n      },\n      m(\n        '.pf-virtual-overlay-canvas__content', // Container for scrolling element, used for sizing the canvas\n        children,\n        // Put canvas container after content so it appears on top. An actual\n        // canvas element will be created inside here by the\n        // VirtualCanvasHelper.\n        m('.pf-virtual-overlay-canvas__canvas-container', {\n          ref: CANVAS_CONTAINER_REF,\n        }),\n      ),\n    );\n  }\n\n  oncreate({attrs, dom}: m.CVnodeDOM<VirtualOverlayCanvasAttrs>) {\n    const canvasContainerElement = toHTMLElement(\n      assertExists(findRef(dom, CANVAS_CONTAINER_REF)),\n    );\n\n    // Create the virtual canvas inside the canvas container element. We assume\n    // the scrolling container is the root level element of this component so we\n    // can just use `dom`.\n    const virtualCanvas = new VirtualCanvas(canvasContainerElement, dom, {\n      overdrawPx: CANVAS_OVERDRAW_PX,\n      tolerancePx: CANVAS_TOLERANCE_PX,\n      overdrawAxes: attrs.scrollAxes,\n    });\n    this.trash.use(virtualCanvas);\n    this.virtualCanvas = virtualCanvas;\n\n    // Create the canvas rendering context\n    this.ctx = assertExists(virtualCanvas.canvasElement.getContext('2d'));\n\n    // When the container resizes, we might need to resize the canvas. This can\n    // be slow so we don't want to do it every render cycle. VirtualCanvas will\n    // tell us when we need to do this.\n    virtualCanvas.setCanvasResizeListener((canvas, width, height) => {\n      const dpr = window.devicePixelRatio;\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      assertExists(this.attrs).onCanvasResized?.(virtualCanvas.size);\n    });\n\n    // Whenever the canvas changes size or moves around (e.g. when scrolling),\n    // we'll need to trigger a re-render to keep canvas content aligned with the\n    // DOM elements underneath.\n    virtualCanvas.setLayoutShiftListener(() => {\n      this.redrawCanvas();\n    });\n  }\n\n  onremove() {\n    this.trash.dispose();\n  }\n\n  private redrawCanvas() {\n    const ctx = assertExists(this.ctx);\n    const virtualCanvas = assertExists(this.virtualCanvas);\n\n    // Reset & clear canvas\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Adjust scaling according pixel ratio. This makes sure the canvas remains\n    // sharp on high DPI screens.\n    const dpr = window.devicePixelRatio;\n    ctx.scale(dpr, dpr);\n\n    // Align canvas rendering offset with the canvas container, not the actual\n    // canvas. This means we can ignore the fact that we are using a virtual\n    // canvas and just render assuming (0, 0) is at the top left of the canvas\n    // container.\n    ctx.translate(\n      -virtualCanvas.canvasRect.left,\n      -virtualCanvas.canvasRect.top,\n    );\n\n    assertExists(this.attrs).onCanvasRedraw?.({\n      ctx,\n      virtualCanvasSize: virtualCanvas.size,\n      canvasRect: virtualCanvas.canvasRect,\n    });\n  }\n}\n"]}