{"version":3,"file":"virtual_table.js","sourceRoot":"","sources":["../../../src/widgets/virtual_table.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\nimport {findRef, toHTMLElement} from '../base/dom_utils';\nimport {assertExists} from '../base/logging';\nimport {Style} from './common';\nimport {scheduleFullRedraw} from './raf';\nimport {VirtualScrollHelper} from './virtual_scroll_helper';\nimport {DisposableStack} from '../base/disposable_stack';\n\n/**\n * The |VirtualTable| widget can be useful when attempting to render a large\n * amount of tabular data - i.e. dumping the entire contents of a database\n * table.\n *\n * A naive approach would be to load the entire dataset from the table and\n * render it into the DOM. However, this has a number of disadvantages:\n * - The query could potentially be very slow on large enough datasets.\n * - The amount of data pulled could be larger than the available memory.\n * - Rendering thousands of DOM elements using Mithril can get be slow.\n * - Asking the browser to create and update thousands of elements on the DOM\n *   can also be slow.\n *\n * This implementation takes advantage of the fact that computer monitors are\n * only so tall, so most will only be able to display a small subset of rows at\n * a given time, and the user will have to scroll to reveal more data.\n *\n * Thus, this widgets operates in such a way as to only render the DOM elements\n * that are visible within the given scrolling container's viewport. To avoid\n * spamming render updates, we render a few more rows above and below the\n * current viewport, and only trigger an update once the user scrolls too close\n * to the edge of the rendered data. These margins and tolerances are\n * configurable with the |renderOverdrawPx| and |renderTolerancePx| attributes.\n *\n * When it comes to loading data, it's often more performant to run fewer large\n * queries compared to more frequent smaller queries. Running a new query every\n * time we want to update the DOM is usually too frequent, and results in\n * flickering as the data is usually not loaded at the time the relevant row\n * scrolls into view.\n *\n * Thus, this implementation employs two sets of limits, one to refresh the DOM\n * and one larger one to re-query the data. The latter may be configured using\n * the |queryOverdrawPx| and |queryTolerancePx| attributes.\n *\n * The smaller DOM refreshes and handled internally, but the user must be called\n * to invoke a new query update. When new data is required, the |onReload|\n * callback is called with the row offset and count.\n *\n * The data must be passed in the |data| attribute which contains the offset of\n * the currently loaded data and a number of rows.\n *\n * Row and column content is flexible as m.Children are accepted and passed\n * straight to mithril.\n *\n * The widget is quite opinionated in terms of its styling, but the entire\n * widget and each row may be tweaked using |className| and |style| attributes\n * which behave in the same way as they do on other Mithril components.\n */\n\nexport interface VirtualTableAttrs {\n  // A list of columns containing the header row content and column widths\n  columns: VirtualTableColumn[];\n\n  // Row height in px (each row must have the same height)\n  rowHeight: number;\n\n  // Offset of the first row\n  firstRowOffset: number;\n\n  // Total number of rows\n  numRows: number;\n\n  // The row data to render\n  rows: VirtualTableRow[];\n\n  // Optional: Called when we need to reload data\n  onReload?: (rowOffset: number, rowCount: number) => void;\n\n  // Additional class name applied to the table container element\n  className?: string;\n\n  // Additional styles applied to the table container element\n  style?: Style;\n\n  // Optional: Called when a row is hovered, passing the hovered row's id\n  onRowHover?: (id: number) => void;\n\n  // Optional: Called when a row is un-hovered, passing the un-hovered row's id\n  onRowOut?: (id: number) => void;\n\n  // Optional: Number of pixels equivalent of rows to overdraw above and below\n  // the viewport\n  // Defaults to a sensible value\n  renderOverdrawPx?: number;\n\n  // Optional: How close we can get to the edge before triggering a DOM redraw\n  // Defaults to a sensible value\n  renderTolerancePx?: number;\n\n  // Optional: Number of pixels equivalent of rows to query above and below the\n  // viewport\n  // Defaults to a sensible value\n  queryOverdrawPx?: number;\n\n  // Optional: How close we can get to the edge if the loaded data before we\n  // trigger another query\n  // Defaults to a sensible value\n  queryTolerancePx?: number;\n}\n\nexport interface VirtualTableColumn {\n  // Content to render in the header row\n  header: m.Children;\n\n  // CSS width e.g. 12px, 4em, etc...\n  width: string;\n}\n\nexport interface VirtualTableRow {\n  // Id for this row (must be unique within this dataset)\n  // Used for callbacks and as a Mithril key.\n  id: number;\n\n  // Data for each column in this row - must match number of elements in columns\n  cells: m.Children[];\n\n  // Optional: Additional class name applied to the row element\n  className?: string;\n}\n\nexport class VirtualTable implements m.ClassComponent<VirtualTableAttrs> {\n  private readonly CONTAINER_REF = 'CONTAINER';\n  private readonly SLIDER_REF = 'SLIDER';\n  private readonly trash = new DisposableStack();\n  private renderBounds = {rowStart: 0, rowEnd: 0};\n\n  view({attrs}: m.Vnode<VirtualTableAttrs>): m.Children {\n    const {columns, className, numRows, rowHeight, style} = attrs;\n    return m(\n      '.pf-vtable',\n      {className, style, ref: this.CONTAINER_REF},\n      m(\n        '.pf-vtable-content',\n        m(\n          '.pf-vtable-header',\n          columns.map((col) =>\n            m('.pf-vtable-data', {style: {width: col.width}}, col.header),\n          ),\n        ),\n        m(\n          '.pf-vtable-slider',\n          {ref: this.SLIDER_REF, style: {height: `${rowHeight * numRows}px`}},\n          m(\n            '.pf-vtable-puck',\n            {\n              style: {\n                transform: `translateY(${\n                  this.renderBounds.rowStart * rowHeight\n                }px)`,\n              },\n            },\n            this.renderContent(attrs),\n          ),\n        ),\n      ),\n    );\n  }\n\n  private renderContent(attrs: VirtualTableAttrs): m.Children {\n    const rows: m.ChildArray = [];\n    for (\n      let i = this.renderBounds.rowStart;\n      i < this.renderBounds.rowEnd;\n      ++i\n    ) {\n      rows.push(this.renderRow(attrs, i));\n    }\n    return rows;\n  }\n\n  private renderRow(attrs: VirtualTableAttrs, i: number): m.Children {\n    const {rows, firstRowOffset, rowHeight, columns, onRowHover, onRowOut} =\n      attrs;\n    if (i >= firstRowOffset && i < firstRowOffset + rows.length) {\n      // Render the row...\n      const index = i - firstRowOffset;\n      const rowData = rows[index];\n      return m(\n        '.pf-vtable-row',\n        {\n          className: rowData.className,\n          style: {height: `${rowHeight}px`},\n          onmouseover: () => {\n            onRowHover?.(rowData.id);\n          },\n          onmouseout: () => {\n            onRowOut?.(rowData.id);\n          },\n        },\n        rowData.cells.map((data, colIndex) =>\n          m('.pf-vtable-data', {style: {width: columns[colIndex].width}}, data),\n        ),\n      );\n    } else {\n      // Render a placeholder div with the same height as a row but a\n      // transparent background\n      return m('', {style: {height: `${rowHeight}px`}});\n    }\n  }\n\n  oncreate({dom, attrs}: m.VnodeDOM<VirtualTableAttrs>) {\n    const {\n      renderOverdrawPx = 200,\n      renderTolerancePx = 100,\n      queryOverdrawPx = 10_000,\n      queryTolerancePx = 5_000,\n    } = attrs;\n\n    const sliderEl = toHTMLElement(assertExists(findRef(dom, this.SLIDER_REF)));\n    const containerEl = assertExists(findRef(dom, this.CONTAINER_REF));\n    const virtualScrollHelper = new VirtualScrollHelper(sliderEl, containerEl, [\n      {\n        overdrawPx: renderOverdrawPx,\n        tolerancePx: renderTolerancePx,\n        callback: (rect) => {\n          const rowStart = Math.floor(rect.top / attrs.rowHeight / 2) * 2;\n          const rowCount = Math.ceil(rect.height / attrs.rowHeight / 2) * 2;\n          this.renderBounds = {rowStart, rowEnd: rowStart + rowCount};\n          scheduleFullRedraw();\n        },\n      },\n      {\n        overdrawPx: queryOverdrawPx,\n        tolerancePx: queryTolerancePx,\n        callback: (rect) => {\n          const rowStart = Math.floor(rect.top / attrs.rowHeight / 2) * 2;\n          const rowEnd = Math.ceil(rect.bottom / attrs.rowHeight);\n          attrs.onReload?.(rowStart, rowEnd - rowStart);\n        },\n      },\n    ]);\n    this.trash.use(virtualScrollHelper);\n  }\n\n  onremove(_: m.VnodeDOM<VirtualTableAttrs>) {\n    this.trash.dispose();\n  }\n}\n"]}