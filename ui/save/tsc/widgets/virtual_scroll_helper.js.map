{"version":3,"file":"virtual_scroll_helper.js","sourceRoot":"","sources":["../../../src/widgets/virtual_scroll_helper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {DisposableStack} from '../base/disposable_stack';\nimport {Bounds2D, Rect2D} from '../base/geom';\nimport {scheduleFullRedraw} from './raf';\n\nexport interface VirtualScrollHelperOpts {\n  overdrawPx: number;\n\n  // How close we can get to undrawn regions before updating\n  tolerancePx: number;\n\n  callback: (r: Rect2D) => void;\n}\n\nexport interface Data {\n  opts: VirtualScrollHelperOpts;\n  rect?: Bounds2D;\n}\n\nexport class VirtualScrollHelper {\n  private readonly _trash = new DisposableStack();\n  private readonly _data: Data[] = [];\n\n  constructor(\n    sliderElement: HTMLElement,\n    containerElement: Element,\n    opts: VirtualScrollHelperOpts[] = [],\n  ) {\n    this._data = opts.map((opts) => {\n      return {opts};\n    });\n\n    const recalculateRects = () => {\n      this._data.forEach((data) =>\n        recalculatePuckRect(sliderElement, containerElement, data),\n      );\n      scheduleFullRedraw('force');\n    };\n\n    containerElement.addEventListener('scroll', recalculateRects, {\n      passive: true,\n    });\n    this._trash.defer(() =>\n      containerElement.removeEventListener('scroll', recalculateRects),\n    );\n\n    // Resize observer callbacks are called once immediately\n    const resizeObserver = new ResizeObserver(() => {\n      recalculateRects();\n    });\n\n    resizeObserver.observe(containerElement);\n    resizeObserver.observe(sliderElement);\n    this._trash.defer(() => {\n      resizeObserver.disconnect();\n    });\n  }\n\n  [Symbol.dispose]() {\n    this._trash.dispose();\n  }\n}\n\nfunction recalculatePuckRect(\n  sliderElement: HTMLElement,\n  containerElement: Element,\n  data: Data,\n): void {\n  const {tolerancePx, overdrawPx, callback} = data.opts;\n  if (!data.rect) {\n    const targetPuckRect = getTargetPuckRect(\n      sliderElement,\n      containerElement,\n      overdrawPx,\n    );\n    callback(targetPuckRect);\n    data.rect = targetPuckRect;\n  } else {\n    const viewportRect = new Rect2D(containerElement.getBoundingClientRect());\n\n    // Expand the viewportRect by the tolerance\n    const viewportExpandedRect = viewportRect.expand(tolerancePx);\n\n    const sliderClientRect = sliderElement.getBoundingClientRect();\n    const viewportClamped = viewportExpandedRect.intersect(sliderClientRect);\n\n    // Translate the puck rect into client space (currently in slider space)\n    const puckClientRect = viewportClamped.translate({\n      x: sliderClientRect.x,\n      y: sliderClientRect.y,\n    });\n\n    // Check if the tolerance rect entirely contains the expanded viewport rect\n    // If not, request an update\n    if (!puckClientRect.contains(viewportClamped)) {\n      const targetPuckRect = getTargetPuckRect(\n        sliderElement,\n        containerElement,\n        overdrawPx,\n      );\n      callback(targetPuckRect);\n      data.rect = targetPuckRect;\n    }\n  }\n}\n\n// Returns what the puck rect should look like\nfunction getTargetPuckRect(\n  sliderElement: HTMLElement,\n  containerElement: Element,\n  overdrawPx: number,\n) {\n  const sliderElementRect = sliderElement.getBoundingClientRect();\n  const containerRect = new Rect2D(containerElement.getBoundingClientRect());\n\n  // Calculate the intersection of the container's viewport and the target\n  const intersection = containerRect.intersect(sliderElementRect);\n\n  // Pad the intersection by the overdraw amount\n  const intersectionExpanded = intersection.expand(overdrawPx);\n\n  // Intersect with the original target rect unless we want to avoid resizes\n  const targetRect = intersectionExpanded.intersect(sliderElementRect);\n\n  return targetRect.reframe(sliderElementRect);\n}\n"]}