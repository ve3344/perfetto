{"version":3,"file":"wasm_bridge.js","sourceRoot":"","sources":["../../../src/engine/wasm_bridge.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2018 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer} from '../base/deferred';\nimport {assertExists, assertTrue} from '../base/logging';\nimport initTraceProcessor from '../gen/trace_processor';\n\n// The Initialize() call will allocate a buffer of REQ_BUF_SIZE bytes which\n// will be used to copy the input request data. This is to avoid passing the\n// input data on the stack, which has a limited (~1MB) size.\n// The buffer will be allocated by the C++ side and reachable at\n// HEAPU8[reqBufferAddr, +REQ_BUFFER_SIZE].\nconst REQ_BUF_SIZE = 32 * 1024 * 1024;\n\n// The end-to-end interaction between JS and Wasm is as follows:\n// - [JS] Inbound data received by the worker (onmessage() in engine/index.ts).\n//   - [JS] onRpcDataReceived() (this file)\n//     - [C++] trace_processor_on_rpc_request (wasm_bridge.cc)\n//       - [C++] some TraceProcessor::method()\n//         for (batch in result_rows)\n//           - [C++] RpcResponseFunction(bytes) (wasm_bridge.cc)\n//             - [JS] onReply() (this file)\n//               - [JS] postMessage() (this file)\nexport class WasmBridge {\n  // When this promise has resolved it is safe to call callWasm.\n  whenInitialized: Promise<void>;\n\n  private aborted: boolean;\n  private connection: initTraceProcessor.Module;\n  private reqBufferAddr = 0;\n  private lastStderr: string[] = [];\n  private messagePort?: MessagePort;\n\n  constructor() {\n    this.aborted = false;\n    const deferredRuntimeInitialized = defer<void>();\n    this.connection = initTraceProcessor({\n      locateFile: (s: string) => s,\n      print: (line: string) => console.log(line),\n      printErr: (line: string) => this.appendAndLogErr(line),\n      onRuntimeInitialized: () => deferredRuntimeInitialized.resolve(),\n    });\n    this.whenInitialized = deferredRuntimeInitialized.then(() => {\n      const fn = this.connection.addFunction(this.onReply.bind(this), 'vii');\n      this.reqBufferAddr =\n        this.connection.ccall(\n          'trace_processor_rpc_init',\n          /* return=*/ 'number',\n          /* args=*/ ['number', 'number'],\n          [fn, REQ_BUF_SIZE],\n        ) >>> 0; // >>> 0 = static_cast<uint32_t> (see comment in onReply()).\n    });\n  }\n\n  initialize(port: MessagePort) {\n    // Ensure that initialize() is called only once.\n    assertTrue(this.messagePort === undefined);\n    this.messagePort = port;\n    // Note: setting .onmessage implicitly calls port.start() and dispatches the\n    // queued messages. addEventListener('message') doesn't.\n    this.messagePort.onmessage = this.onMessage.bind(this);\n  }\n\n  onMessage(msg: MessageEvent) {\n    if (this.aborted) {\n      throw new Error('Wasm module crashed');\n    }\n    assertTrue(msg.data instanceof Uint8Array);\n    const data = msg.data as Uint8Array;\n    let wrSize = 0;\n    // If the request data is larger than our JS<>Wasm interop buffer, split it\n    // into multiple writes. The RPC channel is byte-oriented and is designed to\n    // deal with arbitrary fragmentations.\n    while (wrSize < data.length) {\n      const sliceLen = Math.min(data.length - wrSize, REQ_BUF_SIZE);\n      const dataSlice = data.subarray(wrSize, wrSize + sliceLen);\n      this.connection.HEAPU8.set(dataSlice, this.reqBufferAddr);\n      wrSize += sliceLen;\n      try {\n        this.connection.ccall(\n          'trace_processor_on_rpc_request', // C function name.\n          'void', // Return type.\n          ['number'], // Arg types.\n          [sliceLen], // Args.\n        );\n      } catch (err) {\n        this.aborted = true;\n        let abortReason = `${err}`;\n        if (err instanceof Error) {\n          abortReason = `${err.name}: ${err.message}\\n${err.stack}`;\n        }\n        abortReason += '\\n\\nstderr: \\n' + this.lastStderr.join('\\n');\n        throw new Error(abortReason);\n      }\n    } // while(wrSize < data.length)\n  }\n\n  // This function is bound and passed to Initialize and is called by the C++\n  // code while in the ccall(trace_processor_on_rpc_request).\n  private onReply(heapPtr: number, size: number) {\n    // Force heapPtr to be a positive using an unsigned right shift.\n    // The issue here is the following: the matching code in wasm_bridge.cc\n    // invokes this function passing  arguments as uint32_t. However, in the\n    // wasm<>JS interop bindings, the uint32 args become Js numbers. If the\n    // pointer is > 2GB, this number will be negative, which causes the wrong\n    // behaviour on slice().\n    heapPtr = heapPtr >>> 0; // This is static_cast<uint32_t>(heapPtr).\n    size = size >>> 0;\n    const data = this.connection.HEAPU8.slice(heapPtr, heapPtr + size);\n    assertExists(this.messagePort).postMessage(data, [data.buffer]);\n  }\n\n  private appendAndLogErr(line: string) {\n    console.warn(line);\n    // Keep the last N lines in the |lastStderr| buffer.\n    this.lastStderr.push(line);\n    if (this.lastStderr.length > 512) {\n      this.lastStderr.shift();\n    }\n  }\n}\n"]}