{"version":3,"file":"high_precision_time_span.js","sourceRoot":"","sources":["../../../src/base/high_precision_time_span.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {TimeSpan, time} from './time';\nimport {HighPrecisionTime} from './high_precision_time';\n\n/**\n * Represents a time span using a high precision time value to represent the\n * start of the span, and a number to represent the duration of the span.\n */\nexport class HighPrecisionTimeSpan {\n  static readonly ZERO = new HighPrecisionTimeSpan(HighPrecisionTime.ZERO, 0);\n\n  readonly start: HighPrecisionTime;\n  readonly duration: number;\n\n  constructor(start: HighPrecisionTime, duration: number) {\n    this.start = start;\n    this.duration = duration;\n  }\n\n  /**\n   * Create a new span from integral start and end points.\n   *\n   * @param start The start of the span.\n   * @param end The end of the span.\n   */\n  static fromTime(start: time, end: time): HighPrecisionTimeSpan {\n    return new HighPrecisionTimeSpan(\n      new HighPrecisionTime(start),\n      Number(end - start),\n    );\n  }\n\n  /**\n   * The center point of the span.\n   */\n  get midpoint(): HighPrecisionTime {\n    return this.start.addNumber(this.duration / 2);\n  }\n\n  /**\n   * The end of the span.\n   */\n  get end(): HighPrecisionTime {\n    return this.start.addNumber(this.duration);\n  }\n\n  /**\n   * Checks if this span exactly equals another.\n   */\n  equals(other: HighPrecisionTimeSpan): boolean {\n    return this.start.equals(other.start) && this.duration === other.duration;\n  }\n\n  /**\n   * Create a new span with the same duration but the start point moved through\n   * time by some amount of time.\n   */\n  translate(time: number): HighPrecisionTimeSpan {\n    return new HighPrecisionTimeSpan(this.start.addNumber(time), this.duration);\n  }\n\n  /**\n   * Create a new span with the the start of the span moved backward and the end\n   * of the span moved forward by a certain amount of time.\n   */\n  pad(time: number): HighPrecisionTimeSpan {\n    return new HighPrecisionTimeSpan(\n      this.start.subNumber(time),\n      this.duration + 2 * time,\n    );\n  }\n\n  /**\n   * Create a new span which is zoomed in or out centered on a specific point.\n   *\n   * @param ratio The scaling ratio, the new duration will be the current\n   * duration * ratio.\n   * @param center The center point as a normalized value between 0 and 1 where\n   * 0 is the start of the time window and 1 is the end.\n   * @param minDur Don't allow the time span to become shorter than this.\n   */\n  scale(ratio: number, center: number, minDur: number): HighPrecisionTimeSpan {\n    const currentDuration = this.duration;\n    const newDuration = Math.max(currentDuration * ratio, minDur);\n    // Delta between new and old duration\n    // +ve if new duration is shorter than old duration\n    const durationDeltaNanos = currentDuration - newDuration;\n    // If offset is 0, don't move the start at all\n    // If offset if 1, move the start by the amount the duration has changed\n    // If new duration is shorter - move start to right\n    // If new duration is longer - move start to left\n    const start = this.start.addNumber(durationDeltaNanos * center);\n    return new HighPrecisionTimeSpan(start, newDuration);\n  }\n\n  /**\n   * Create a new span that represents the intersection of this span with\n   * another.\n   *\n   * If the two spans do not overlap at all, the empty span is returned.\n   *\n   * @param start THe start of the other span.\n   * @param end The end of the other span.\n   */\n  intersect(start: time, end: time): HighPrecisionTimeSpan {\n    if (!this.overlaps(start, end)) {\n      return HighPrecisionTimeSpan.ZERO;\n    }\n    const newStart = this.start.clamp(start, end);\n    const newEnd = this.end.clamp(start, end);\n    const newDuration = newEnd.sub(newStart).toNumber();\n    return new HighPrecisionTimeSpan(newStart, newDuration);\n  }\n\n  /**\n   * Create a new timespan which fits within the specified bounds, preserving\n   * its duration if possible.\n   *\n   * This function moves the timespan forwards or backwards in time while\n   * keeping its duration unchanged, so that it fits entirely within the range\n   * defined by `start` and `end`.\n   *\n   * If the specified bounds are smaller than the current timespan's duration, a\n   * new timespan matching the bounds is returned.\n   *\n   * @param start The start of the bounds within which the timespan should fit.\n   * @param end The end of the bounds within which the timespan should fit.\n   *\n   * @example\n   * // assume `timespan` is defined as: [5, 8)\n   * timespan.fitWithin(10n, 20n); // -> [10, 13)\n   * timespan.fitWithin(-10n, -5n); // -> [-8, -5)\n   * timespan.fitWithin(1n, 2n); // -> [1, 2)\n   */\n  fitWithin(start: time, end: time): HighPrecisionTimeSpan {\n    if (this.duration > Number(end - start)) {\n      // Current span is greater than the limits\n      return HighPrecisionTimeSpan.fromTime(start, end);\n    }\n    if (this.start.integral < start) {\n      // Current span starts before limits\n      return new HighPrecisionTimeSpan(\n        new HighPrecisionTime(start),\n        this.duration,\n      );\n    }\n    if (this.end.gt(end)) {\n      // Current span ends after limits\n      return new HighPrecisionTimeSpan(\n        new HighPrecisionTime(end).subNumber(this.duration),\n        this.duration,\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Clamp duration to some minimum value. The start remains the same, just the\n   * duration is changed.\n   */\n  clampDuration(minDuration: number): HighPrecisionTimeSpan {\n    if (this.duration < minDuration) {\n      return new HighPrecisionTimeSpan(this.start, minDuration);\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * Checks whether this span completely contains a time instant.\n   */\n  contains(t: time): boolean {\n    return this.start.lte(t) && this.end.gt(t);\n  }\n\n  /**\n   * Checks whether this span entirely contains another span.\n   *\n   * @param start The start of the span to check.\n   * @param end The end of the span to check.\n   */\n  containsSpan(start: time, end: time): boolean {\n    return this.start.lte(start) && this.end.gte(end);\n  }\n\n  /**\n   * Checks if this span overlaps at all with another.\n   *\n   * @param start The start of the span to check.\n   * @param end The end of the span to check.\n   */\n  overlaps(start: time, end: time): boolean {\n    return !(this.start.gte(end) || this.end.lte(start));\n  }\n\n  /**\n   * Get the span of integer intervals values that overlap this span.\n   */\n  toTimeSpan(): TimeSpan {\n    return new TimeSpan(this.start.toTime('floor'), this.end.toTime('ceil'));\n  }\n}\n"]}