{"version":3,"file":"store.js","sourceRoot":"","sources":["../../../src/base/store.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {produce, Draft} from 'immer';\nimport {getPath, Path, setPath} from './object_utils';\n\nexport type Migrate<T> = (init: unknown) => T;\nexport type Edit<T> = (draft: Draft<T>) => void;\nexport type Callback<T> = (store: Store<T>, previous: T) => void;\n\n/**\n * Create a new root-level store.\n *\n * @template T The type of this store's state.\n * @param {T} initialState Initial state of the store.\n * @returns {Store<T>} The newly created store.\n */\nexport function createStore<T>(initialState: T): Store<T> {\n  return new RootStore<T>(initialState);\n}\n\nexport interface Store<T> extends Disposable {\n  /**\n   * Access the immutable state of this store.\n   */\n  get state(): T;\n\n  /**\n   * Mutate the store's state.\n   *\n   * @param edits The edit (or edits) to the store.\n   */\n  edit(edits: Edit<T> | Edit<T>[]): void;\n\n  /**\n   * Create a sub-store from a subtree of the state from this store.\n   *\n   * The returned store looks and feels like a regular store but acts only on a\n   * specific subtree of its parent store. Reads are writes are channelled\n   * through to the parent store via the |migrate| function.\n   *\n   * |migrate| is called the first time we access our sub-store's state and\n   * whenever the subtree changes in the root store.\n   * This migrate function takes the state of the subtree from the sub-store's\n   * parent store which has unknown type and is responsible for returning a\n   * value whose type matches that of the sub-store's state.\n   *\n   * Sub-stores may be created over the top of subtrees which are not yet fully\n   * defined. The state is written to the parent store on first edit. The\n   * sub-store can also deal with the underlying subtree becoming undefined\n   * again at some point in the future, and so is robust to unpredictable\n   * changes to the root store.\n   *\n   * @template U The type of the sub-store's state.\n   * @param path The path to the subtree this sub-store is based on.\n   * @example\n   * // Given a store whose state takes the form:\n   * {\n   *   foo: {\n   *     bar: [ {baz: 123}, {baz: 42} ],\n   *   },\n   * }\n   *\n   * // A sub-store crated on path: ['foo','bar', 1] would only see the state:\n   * {\n   *   baz: 42,\n   * }\n   * @param migrate A function used to migrate from the parent store's subtree\n   * to the sub-store's state.\n   * @example\n   * interface RootState {dict: {[key: string]: unknown}};\n   * interface SubState {foo: string};\n   *\n   * const store = createStore({dict: {}});\n   * const migrate = (init: unknown) => (init ?? {foo: 'bar'}) as SubState;\n   * const subStore = store.createSubStore(store, ['dict', 'foo'], migrate);\n   * // |dict['foo']| will be created the first time we edit our sub-store.\n   * Warning: Migration functions should properly validate the incoming state.\n   * Blindly using type assertions can lead to instability.\n   * @returns {Store<U>} The newly created sub-store.\n   */\n  createSubStore<U>(path: Path, migrate: Migrate<U>): Store<U>;\n\n  /**\n   * Subscribe for notifications when any edits are made to this store.\n   *\n   * @param callback The function to be called.\n   * @returns When this is disposed, the subscription is removed.\n   */\n  subscribe(callback: Callback<T>): Disposable;\n}\n\n/**\n * This class implements a standalone store (i.e. one that does not depend on a\n * subtree of another store).\n * @template T The type of the store's state.\n */\nclass RootStore<T> implements Store<T> {\n  private internalState: T;\n  private subscriptions = new Set<Callback<T>>();\n\n  constructor(initialState: T) {\n    // Run initial state through immer to take advantage of auto-freezing\n    this.internalState = produce(initialState, () => {});\n  }\n\n  get state() {\n    return this.internalState;\n  }\n\n  edit(edit: Edit<T> | Edit<T>[]): void {\n    if (Array.isArray(edit)) {\n      this.applyEdits(edit);\n    } else {\n      this.applyEdits([edit]);\n    }\n  }\n\n  private applyEdits(edits: Edit<T>[]): void {\n    const originalState = this.internalState;\n\n    const newState = edits.reduce((state, edit) => {\n      return produce(state, edit);\n    }, originalState);\n\n    this.internalState = newState;\n\n    // Notify subscribers\n    this.subscriptions.forEach((sub) => {\n      sub(this, originalState);\n    });\n  }\n\n  createSubStore<U>(path: Path, migrate: Migrate<U>): Store<U> {\n    return new SubStore(this, path, migrate);\n  }\n\n  subscribe(callback: Callback<T>): Disposable {\n    this.subscriptions.add(callback);\n    return {\n      [Symbol.dispose]: () => {\n        this.subscriptions.delete(callback);\n      },\n    };\n  }\n\n  [Symbol.dispose]() {\n    // No-op\n  }\n}\n\n/**\n * This class implements a sub-store, one that is based on a subtree of another\n * store. The parent store can be a root level store or another sub-store.\n *\n * This particular implementation of a sub-tree implements a write-through cache\n * style implementation. The sub-store's state is cached internally and all\n * edits are written through to the parent store as with a best-effort approach.\n * If the subtree does not exist in the parent store, an error is printed to\n * the console but the operation is still treated as a success.\n *\n * @template T The type of the sub-store's state.\n * @template ParentT The type of the parent store's state.\n */\nclass SubStore<T, ParentT> implements Store<T> {\n  private parentState: unknown;\n  private cachedState: T;\n  private parentStoreSubscription: Disposable;\n  private subscriptions = new Set<Callback<T>>();\n\n  constructor(\n    private readonly parentStore: Store<ParentT>,\n    private readonly path: Path,\n    private readonly migrate: (init: unknown) => T,\n  ) {\n    this.parentState = getPath<unknown>(this.parentStore.state, this.path);\n\n    // Run initial state through immer to take advantage of auto-freezing\n    this.cachedState = produce(migrate(this.parentState), () => {});\n\n    // Subscribe to parent store changes.\n    this.parentStoreSubscription = this.parentStore.subscribe(() => {\n      const newRootState = getPath<unknown>(this.parentStore.state, this.path);\n      if (newRootState !== this.parentState) {\n        this.subscriptions.forEach((callback) => {\n          callback(this, this.cachedState);\n        });\n      }\n    });\n  }\n\n  get state(): T {\n    const parentState = getPath<unknown>(this.parentStore.state, this.path);\n    if (this.parentState === parentState) {\n      return this.cachedState;\n    } else {\n      this.parentState = parentState;\n      return (this.cachedState = produce(this.cachedState, () => {\n        return this.migrate(parentState);\n      }));\n    }\n  }\n\n  edit(edit: Edit<T> | Edit<T>[]): void {\n    if (Array.isArray(edit)) {\n      this.applyEdits(edit);\n    } else {\n      this.applyEdits([edit]);\n    }\n  }\n\n  private applyEdits(edits: Edit<T>[]): void {\n    const originalState = this.cachedState;\n\n    const newState = edits.reduce((state, edit) => {\n      return produce(state, edit);\n    }, originalState);\n\n    this.parentState = newState;\n    try {\n      this.parentStore.edit((draft) => {\n        setPath(draft, this.path, newState);\n      });\n    } catch (error) {\n      if (error instanceof TypeError) {\n        console.warn('Failed to update parent store at ', this.path);\n      } else {\n        throw error;\n      }\n    }\n\n    this.cachedState = newState;\n\n    this.subscriptions.forEach((sub) => {\n      sub(this, originalState);\n    });\n  }\n\n  createSubStore<SubtreeState>(\n    path: Path,\n    migrate: Migrate<SubtreeState>,\n  ): Store<SubtreeState> {\n    return new SubStore(this, path, migrate);\n  }\n\n  subscribe(callback: Callback<T>): Disposable {\n    this.subscriptions.add(callback);\n    return {\n      [Symbol.dispose]: () => {\n        this.subscriptions.delete(callback);\n      },\n    };\n  }\n\n  [Symbol.dispose]() {\n    this.parentStoreSubscription[Symbol.dispose]();\n  }\n}\n"]}