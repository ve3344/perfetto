{"version":3,"file":"mithril_utils.js","sourceRoot":"","sources":["../../../src/base/mithril_utils.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AAKjC,kCAMC;AAoDD,4CAWC;;AAxED,8DAAwB;AAExB,kDAAkD;AAClD,SAAgB,WAAW,CAAI,EAAC,QAAQ,EAAa;IACnD,OAAO,CACL,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC;QACvB,QAAQ,CAAC,MAAM,GAAG,CAAC;QACnB,QAAQ,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,CAChC,CAAC;AACJ,CAAC;AAED,yDAAyD;AACzD,+EAA+E;AAC/E,2CAA2C;AAC9B,QAAA,WAAW,GAAG;IACzB,IAAI,CAAC,EAAC,QAAQ,EAAa;QACzB,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF,CAAC;AAMF,sEAAsE;AACtE,4EAA4E;AAC5E,yEAAyE;AACzE,4EAA4E;AAC5E,uCAAuC;AAC1B,QAAA,IAAI,GAAG;IAClB,IAAI,CAAC,EAAC,KAAK,EAAE,QAAQ,EAAwB;QAC3C,OAAO,IAAA,iBAAC,EACN,EAAE,EACF;YACE,KAAK,EAAE,EAAC,OAAO,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,EAAC;SACnD,EACD,QAAQ,CACT,CAAC;IACJ,CAAC;CACF,CAAC;AAEF;;;;;;;;;;;;;;;;;;;GAmBG;AACH,SAAgB,gBAAgB,CAC9B,SAAkC,EAClC,SAAuC;IAEvC,OAAO;QACL,IAAI,CAAC,KAAyB;YAC5B,MAAM,KAAK,GAAG,EAAC,GAAG,KAAK,CAAC,KAAK,EAAE,GAAG,SAAS,EAAU,CAAC;YACtD,MAAM,UAAU,GAAkC,EAAE,CAAC,CAAC,kBAAkB;YACxE,OAAO,IAAA,iBAAC,EAAY,SAAS,EAAE,EAAC,GAAG,KAAK,EAAE,GAAG,UAAU,EAAC,CAAC,CAAC;QAC5D,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\n\n// Check if a mithril component vnode has children\nexport function hasChildren<T>({children}: m.Vnode<T>): boolean {\n  return (\n    Array.isArray(children) &&\n    children.length > 0 &&\n    children.some((value) => value)\n  );\n}\n\n// A component which simply passes through it's children.\n// Can be used for having something to attach lifecycle hooks to without having\n// to add an extra HTML element to the DOM.\nexport const Passthrough = {\n  view({children}: m.VnodeDOM) {\n    return children;\n  },\n};\n\nexport interface GateAttrs {\n  open: boolean;\n}\n\n// The gate component is a wrapper which can either be open or closed.\n// - When open, children are rendered inside a div where display = contents.\n// - When closed, children are rendered inside a div where display = none\n// Use this component when we want to conditionally render certain children,\n// but we want to maintain their state.\nexport const Gate = {\n  view({attrs, children}: m.VnodeDOM<GateAttrs>) {\n    return m(\n      '',\n      {\n        style: {display: attrs.open ? 'contents' : 'none'},\n      },\n      children,\n    );\n  },\n};\n\n/**\n * Utility function to pre-bind some mithril attrs of a component, and leave\n * the others unbound and passed at run-time.\n * Example use case: the Page API Passes to the registered page a PageAttrs,\n * which is {subpage:string}. Imagine you write a MyPage component that takes\n * some extra input attrs (e.g. the App object) and you want to bind them\n * onActivate(). The results looks like this:\n *\n * interface MyPageAttrs extends PageAttrs { app: App; }\n *\n * class MyPage extends m.classComponent<MyPageAttrs> {... view() {...} }\n *\n * onActivate(app: App) {\n *   pages.register(... bindMithrilApps(MyPage, {app: app});\n * }\n *\n * The return value of bindMithrilApps is a mithril component that takes in\n * input only a {subpage: string} and passes down to MyPage the combination\n * of pre-bound and runtime attrs, that is {subpage, app}.\n */\nexport function bindMithrilAttrs<BaseAttrs, Attrs>(\n  component: m.ComponentTypes<Attrs>,\n  boundArgs: Omit<Attrs, keyof BaseAttrs>,\n): m.Component<BaseAttrs> {\n  return {\n    view(vnode: m.Vnode<BaseAttrs>) {\n      const attrs = {...vnode.attrs, ...boundArgs} as Attrs;\n      const emptyAttrs: m.CommonAttributes<Attrs, {}> = {}; // Keep tsc happy.\n      return m<Attrs, {}>(component, {...attrs, ...emptyAttrs});\n    },\n  };\n}\n"]}