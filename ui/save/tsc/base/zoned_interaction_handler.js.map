{"version":3,"file":"zoned_interaction_handler.js","sourceRoot":"","sources":["../../../src/base/zoned_interaction_handler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * This module provides an extensible, declarative interaction manager for\n * handling high level mouse and keyboard interactions within an HTML element,\n * using zones to define areas with different configurations.\n *\n * This is typically used on canvas, where we want to create draggable handles,\n * or area selections, but there are no fine-grained DOM elements we can attach\n * to.\n *\n * It supports:\n * - Specifying a list of zones, which can specify their own mouse event\n *   handlers.\n * - Changing the cursor when hovering over a zone.\n * - High level drag event handlers with customizable drag thresholds, 'while\n *   dragging' cursors and keyboard modifiers.\n * - Click event handlers, which integrate nicely with drag events (i.e. failed\n *   drag events turn into clicks).\n * - Mouse wheel events.\n *\n * How it works:\n *\n * For events that fire on the given target element, the list of zones is\n * searched from top to bottom until a zone that handles that event is found.\n *\n * The list of zones is declarative, and is designed to be updated frequently\n * i.e. every frame. This means that long running events such as drags can be\n * can outlive the a single update cycle. Each zone must specify an id which is\n * a unique string used to link up the new zones with ongoing drag events, and\n * thus use the new callbacks. This is important as new callbacks might capture\n * different data.\n */\n\nimport {removeFalsyValues} from './array_utils';\nimport {DisposableStack} from './disposable_stack';\nimport {bindEventListener, CSSCursor} from './dom_utils';\nimport {Point2D, Rect2D, Size2D, Vector2D} from './geom';\n\nexport interface DragEvent {\n  // The location of the mouse at the start of the drag action.\n  readonly dragStart: Vector2D;\n\n  // The location of the mouse currently.\n  readonly dragCurrent: Vector2D;\n\n  // The amount the mouse has moved by duration the drag.\n  // I.e. currentMousePosition - startingMousePosition\n  readonly dragDelta: Vector2D;\n\n  // The amount the mouse have moved by since the last drag event.\n  readonly deltaSinceLastEvent: Vector2D;\n}\n\nexport interface ClickEvent {\n  // Location of the mouse W.R.T the target element (not the current zone).\n  readonly position: Vector2D;\n}\n\nexport interface InteractionWheelEvent {\n  // Location of the mouse W.R.T the target element (not the current zone).\n  readonly position: Vector2D;\n\n  // Wheel deltaX directly from the DOM WheelEvent.\n  readonly deltaX: number;\n\n  // Wheel deltaY directly from the DOM WheelEvent.\n  readonly deltaY: number;\n}\n\nexport interface DragConfig {\n  // Optional: Switch to this cursor while dragging.\n  readonly cursorWhileDragging?: CSSCursor;\n\n  // The minimum distance the mouse must move before a drag is triggered.\n  // Default: 0 - drags start instantly.\n  readonly minDistance?: number;\n\n  // Optional: Called whenever the mouse is moved during a drag event.\n  onDrag?(e: DragEvent, element: HTMLElement): void;\n\n  // Optional: Called when the mouse button is released and the drag is complete.\n  onDragEnd?(e: DragEvent, element: HTMLElement): void;\n}\n\nexport interface Zone {\n  // Unique ID for this zone. This is used to coordinate long events such as\n  // drag event callbacks between update cycles.\n  readonly id: string;\n\n  // The area occupied by this zone.\n  readonly area: Point2D & Size2D;\n\n  // Optional: Which cursor to change the mouse to when hovering over this zone.\n  readonly cursor?: CSSCursor;\n\n  // Optional: If present, this keyboard modifier must be held otherwise this\n  // zone is effectively invisible to interactions.\n  readonly keyModifier?: 'shift';\n\n  // Optional: If present, this zone will respond to drag events.\n  readonly drag?: DragConfig;\n\n  // Optional: If present, this function will be called when this zone is\n  // clicked on.\n  onClick?(e: ClickEvent): void;\n\n  // Optional: If present, this function will be called when the wheel is\n  // scrolled while hovering over this zone.\n  onWheel?(e: InteractionWheelEvent): void;\n}\n\ninterface InProgressDrag {\n  readonly zoneId: string;\n  readonly startingMousePosition: Vector2D;\n  currentMousePosition: Vector2D;\n  previouslyNotifiedPosition: Vector2D;\n}\n\nexport class ZonedInteractionHandler implements Disposable {\n  private readonly trash = new DisposableStack();\n  private currentMousePosition?: Point2D;\n  private zones: ReadonlyArray<Zone> = [];\n  private currentDrag?: InProgressDrag;\n  private shiftHeld = false;\n\n  constructor(private readonly target: HTMLElement) {\n    this.bindEvent(this.target, 'mousedown', this.onMouseDown.bind(this));\n    this.bindEvent(document, 'mousemove', this.onMouseMove.bind(this));\n    this.bindEvent(document, 'mouseup', this.onMouseUp.bind(this));\n    this.bindEvent(document, 'keydown', this.onKeyDown.bind(this));\n    this.bindEvent(document, 'keyup', this.onKeyUp.bind(this));\n    this.bindEvent(this.target, 'wheel', this.handleWheel.bind(this));\n  }\n\n  [Symbol.dispose](): void {\n    this.trash.dispose();\n  }\n\n  /**\n   * Update the list of zones and their configurations. Each zone is processed\n   * from the start to the end of the list, so zones which appear earlier in the\n   * list will be chosen before those later in the list.\n   *\n   * Zones can be falsy, which allows the simple conditional zones to be defined\n   * using short circuits, similar to mithril. Falsy zones are simply ignored.\n   *\n   * @param zones - The list of zones to configure interactions areas and their\n   * configurations.\n   */\n  update(zones: ReadonlyArray<Zone | false | undefined | null>): void {\n    this.zones = removeFalsyValues(zones);\n    this.updateCursor();\n  }\n\n  // Utility function to bind an event listener to a DOM element and add it to\n  // the trash.\n  private bindEvent<K extends keyof HTMLElementEventMap>(\n    element: EventTarget,\n    event: K,\n    handler: (event: HTMLElementEventMap[K]) => void,\n  ) {\n    this.trash.use(bindEventListener(element, event, handler));\n  }\n\n  private onMouseDown(e: MouseEvent) {\n    const mousePositionClient = new Vector2D({x: e.clientX, y: e.clientY});\n    const mouse = mousePositionClient.sub(this.target.getBoundingClientRect());\n    const zone = this.findZone((z) => z.drag && this.hitTestZone(z, mouse));\n    if (zone) {\n      this.currentDrag = {\n        zoneId: zone.id,\n        startingMousePosition: mouse,\n        currentMousePosition: mouse,\n        previouslyNotifiedPosition: mouse,\n      };\n      this.updateCursor();\n    }\n  }\n\n  private onMouseMove(e: MouseEvent) {\n    const mousePositionClient = new Vector2D({x: e.clientX, y: e.clientY});\n    const mousePosition = mousePositionClient.sub(\n      this.target.getBoundingClientRect(),\n    );\n    this.currentMousePosition = mousePosition;\n    this.updateCursor();\n\n    const currentDrag = this.currentDrag;\n    if (currentDrag) {\n      currentDrag.currentMousePosition = mousePosition;\n      const delta = currentDrag.startingMousePosition.sub(mousePosition);\n      const dragConfig = this.findZoneById(currentDrag.zoneId)?.drag;\n      if (\n        dragConfig &&\n        delta.manhattanDistance >= (dragConfig?.minDistance ?? 0)\n      ) {\n        dragConfig.onDrag?.(\n          {\n            dragCurrent: mousePosition,\n            dragStart: currentDrag.startingMousePosition,\n            dragDelta: delta,\n            deltaSinceLastEvent: mousePosition.sub(\n              currentDrag.previouslyNotifiedPosition,\n            ),\n          },\n          this.target,\n        );\n        currentDrag.previouslyNotifiedPosition = mousePosition;\n      }\n    }\n  }\n\n  private onMouseUp(e: MouseEvent) {\n    const mousePositionClient = new Vector2D({x: e.clientX, y: e.clientY});\n    const mousePosition = mousePositionClient.sub(\n      this.target.getBoundingClientRect(),\n    );\n\n    const currentDrag = this.currentDrag;\n\n    if (currentDrag) {\n      const delta = currentDrag.startingMousePosition.sub(mousePosition);\n      const dragConfig = this.findZoneById(currentDrag.zoneId)?.drag;\n      if (\n        dragConfig &&\n        delta.manhattanDistance >= (dragConfig?.minDistance ?? 0)\n      ) {\n        this.handleDrag(this.target, currentDrag, mousePosition, e, dragConfig);\n      } else {\n        this.handleClick(this.target, e);\n      }\n\n      this.currentDrag = undefined;\n      this.updateCursor();\n    } else {\n      this.handleClick(this.target, e);\n    }\n  }\n\n  private onKeyDown(e: KeyboardEvent) {\n    this.shiftHeld = e.shiftKey;\n    this.updateCursor();\n  }\n\n  private onKeyUp(e: KeyboardEvent) {\n    this.shiftHeld = e.shiftKey;\n    this.updateCursor();\n  }\n\n  private handleWheel(e: WheelEvent) {\n    const mousePositionClient = new Vector2D({x: e.clientX, y: e.clientY});\n    const mouse = mousePositionClient.sub(this.target.getBoundingClientRect());\n    const zone = this.findZone((z) => z.onWheel && this.hitTestZone(z, mouse));\n    zone?.onWheel?.({\n      position: mouse,\n      deltaX: e.deltaX,\n      deltaY: e.deltaY,\n    });\n  }\n\n  private handleDrag(\n    element: HTMLElement,\n    currentDrag: InProgressDrag,\n    x: Vector2D,\n    e: MouseEvent,\n    dragConfig: DragConfig,\n  ) {\n    // Update the current position\n    currentDrag.currentMousePosition = x;\n\n    const dragEvent: DragEvent = {\n      dragStart: currentDrag.startingMousePosition,\n      dragCurrent: x,\n      dragDelta: new Vector2D({x: e.movementX, y: e.movementY}),\n      deltaSinceLastEvent: new Vector2D({x: e.movementX, y: e.movementY}),\n    };\n\n    dragConfig.onDragEnd?.(dragEvent, element);\n  }\n\n  private handleClick(element: HTMLElement, e: MouseEvent) {\n    const mousePositionClient = new Vector2D({x: e.clientX, y: e.clientY});\n    const mouse = mousePositionClient.sub(element.getBoundingClientRect());\n    const zone = this.findZone((z) => z.onClick && this.hitTestZone(z, mouse));\n    zone?.onClick?.({position: mouse});\n  }\n\n  private updateCursor() {\n    // If a drag is ongoing, use the drag cursor if available\n    const drag = this.currentDrag;\n    if (drag) {\n      const dragDelta = drag.currentMousePosition.sub(\n        drag.startingMousePosition,\n      );\n      const dragConfig = this.findZoneById(drag.zoneId)?.drag;\n      if (\n        dragConfig &&\n        dragConfig.cursorWhileDragging &&\n        dragDelta.manhattanDistance >= (dragConfig.minDistance ?? 0)\n      ) {\n        this.target.style.cursor = dragConfig.cursorWhileDragging;\n        return;\n      }\n    }\n\n    // Otherwise, find the hovered zone and set the cursor\n    const mouse = this.currentMousePosition;\n    const zone =\n      mouse && this.findZone((z) => z.cursor && this.hitTestZone(z, mouse));\n    this.target.style.cursor = zone?.cursor ?? 'default';\n  }\n\n  // Find a zone that matches a predicate.\n  private findZone(pred: (z: Zone) => boolean | undefined): Zone | undefined {\n    for (const zone of this.zones) {\n      if (pred(zone)) return zone;\n    }\n    return undefined;\n  }\n\n  // Find a zone by id.\n  private findZoneById(id: string): Zone | undefined {\n    for (const zone of this.zones) {\n      if (zone.id === id) return zone;\n    }\n    return undefined;\n  }\n\n  // Test whether a point hits a zone.\n  private hitTestZone(zone: Zone, x: Point2D): boolean {\n    const rect = Rect2D.fromPointAndSize(zone.area);\n    return rect.containsPoint(x) && (!zone.keyModifier || this.shiftHeld);\n  }\n}\n"]}