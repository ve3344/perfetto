{"version":3,"file":"fuzzy.js","sourceRoot":"","sources":["../../../src/base/fuzzy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {byLengthAsc, Fzf} from 'fzf';\nimport {SyncOptionsTuple} from 'fzf/dist/types/finders';\n\nexport interface FuzzySegment {\n  matching: boolean;\n  value: string;\n}\n\nexport interface FuzzyResult<T> {\n  item: T;\n  segments: FuzzySegment[];\n}\n\nexport type KeyLookup<T> = (x: T) => string;\n\n// Finds approx matching in arbitrary lists of items.\nexport class FuzzyFinder<T> {\n  private readonly fzf: Fzf<ReadonlyArray<T>>;\n  // Because we operate on arbitrary lists, a key lookup function is required to\n  // so we know which part of the list is to be be searched. It should return\n  // the relevant search string for each item.\n  constructor(\n    items: ReadonlyArray<T>,\n    private readonly keyLookup: KeyLookup<T>,\n  ) {\n    // NOTE(stevegolton): This type assertion because FZF appears to be very\n    // fussy about its input types.\n    const options = [\n      {selector: keyLookup, tiebreakers: [byLengthAsc]},\n    ] as SyncOptionsTuple<T>;\n    this.fzf = new Fzf<ReadonlyArray<T>>(items, ...options);\n  }\n\n  // Return a list of items that match any of the search terms.\n  find(searchTerm: string): FuzzyResult<T>[] {\n    return this.fzf.find(searchTerm).map((m) => {\n      const normalisedTerm = this.keyLookup(m.item);\n      return {\n        item: m.item,\n        segments: indiciesToSegments(\n          Array.from(m.positions).sort((a, b) => a - b),\n          normalisedTerm,\n        ),\n      };\n    });\n  }\n}\n\n// Given a list of indicies of matching chars, and the original value, produce\n// a list of match/nomatch segments.\nfunction indiciesToSegments(indicies: number[], text: string): FuzzySegment[] {\n  const segments: FuzzySegment[] = [];\n  let nextIndex = 0;\n  let match = '';\n  for (const i of indicies) {\n    if (nextIndex < i) {\n      // If we had a match segment from before, add it now.\n      if (match !== '') {\n        segments.push({matching: true, value: match});\n        match = '';\n      }\n      // Missed some indicies - wrap them up into a nomatch segment.\n      segments.push({matching: false, value: text.slice(nextIndex, i)});\n    }\n\n    // Append this matching char to the previous match.\n    match += text[i];\n    nextIndex = i + 1;\n  }\n\n  // Add any lingering match segment.\n  if (match !== '') {\n    segments.push({matching: true, value: match});\n  }\n\n  // Add final nomatch segment if there is anything left.\n  if (nextIndex < text.length) {\n    segments.push({matching: false, value: text.slice(nextIndex)});\n  }\n\n  return segments;\n}\n\n// Evaluate whether |searchTerm| is found in |text|.\n// |indicies| is an array of numbers the same length as |searchTerm|, into which\n// we place the indicies of the matching chars in |text|.\nfunction match(searchTerm: string, text: string, indicies: number[]): boolean {\n  let j = 0; // index into the searchTerm.\n  let success: boolean = true;\n\n  // For each char of the searchTerm...\n  for (let i = 0; i < searchTerm.length; ++i) {\n    const char = searchTerm[i].toLowerCase();\n    // ...advance the text index until we find the char.\n    for (; j < text.length; ++j) {\n      // If we find it add it to the segment and move on.\n      if (text[j].toLowerCase() === char) {\n        indicies[i] = j;\n        break;\n      }\n    }\n\n    // Failed to find searchTerm[i] in text: give up.\n    if (j === text.length) {\n      success = false;\n      break;\n    }\n\n    ++j;\n  }\n\n  return success;\n}\n\nexport interface FuzzyMatch {\n  matches: boolean;\n  segments: FuzzySegment[];\n}\n\n// Fuzzy match a single piece of text against several search terms.\n// If any of the terms match, the result of the match is true.\nexport function fuzzyMatch(\n  text: string,\n  ...searchTerms: ReadonlyArray<string>\n): FuzzyMatch {\n  for (const searchTerm of searchTerms) {\n    const indicies: number[] = new Array(searchTerm.length);\n    if (match(searchTerm, text, indicies)) {\n      const segments = indiciesToSegments(indicies, text);\n      return {\n        matches: true,\n        segments,\n      };\n    }\n  }\n\n  return {\n    matches: false,\n    segments: [],\n  };\n}\n"]}