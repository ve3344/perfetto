{"version":3,"file":"static_initializers.js","sourceRoot":"","sources":["../../../src/base/static_initializers.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AAEjC,iEAAiE;AACjE,oEAAoE;AACpE,sEAAsE;AACtE,oEAAoE;AACpE,kEAAkE;AAElE,yDAAyD;AACzD,sEAAsE;AACtE,sEAAsE;AACtE,uEAAuE;AACvE,sEAAsE;AACtE,0CAA0C;AAE1C,iCAAiE;AACjE,yEAA0C;AAE1C,SAAS,eAAe;IACtB,IAAA,qBAAa,GAAE,CAAC;IAChB,IAAA,oBAAY,GAAE,CAAC;IAEf,8EAA8E;IAC9E,6EAA6E;IAC7E,0EAA0E;IAC1E,8EAA8E;IAC9E,yEAAyE;IACzE,4BAA4B;IAC5B,IAAA,qBAAa,EAAC,IAAI,CAAC,CAAC;AACtB,CAAC;AAED,SAAS,kBAAkB;IACzB,8EAA8E;IAC9E,6EAA6E;IAC7E,kEAAkE;IAClE,0EAA0E;IAC1E,mEAAmE;IACnE,8DAA8D;IAC9D,iBAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,SAAgB,CAAC;IACtC,iBAAQ,CAAC,SAAS,EAAE,CAAC;AACvB,CAAC;AAED,IAAI,aAAa,GAAG,KAAK,CAAC;AAC1B,SAAS,UAAU;IACjB,IAAI,aAAa,EAAE,CAAC;QAClB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;IAChE,CAAC;IACD,eAAe,EAAE,CAAC;IAClB,kBAAkB,EAAE,CAAC;IACrB,aAAa,GAAG,IAAI,CAAC;AACvB,CAAC;AAED,wDAAwD;AACxD,UAAU,EAAE,CAAC","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Occasionally libraries require configuration code to be called\n// before that library is used. This can become troublesome when the\n// library is used in many places through out the code base. To ensure\n// a consistent initialization this file exists as a place such code\n// can live. It's the first import in the root file of the bundle.\n\n// We use 'static initializers' (e.g. first import causes\n// initialization) rather than allowing the importer control over when\n// it happens. This sounds worse on paper but it works a lot better in\n// tests where (in JS) there is no global main() you can edit to do the\n// initialization. Instead any test where this is a problem can easily\n// stick an import at the top of the file.\n\nimport {enableMapSet, enablePatches, setAutoFreeze} from 'immer';\nimport protobuf from 'protobufjs/minimal';\n\nfunction initializeImmer() {\n  enablePatches();\n  enableMapSet();\n\n  // TODO(primiano): re-enable this, requires fixing some bugs that this bubbles\n  // up. This is a new feature of immer which freezes object after a produce().\n  // Unfortunately we piled up a bunch of bugs where we shallow-copy objects\n  // from the global state (which is frozen) and later try to update the copies.\n  // By doing so, we  accidentally the local copy of global state, which is\n  // supposed to be immutable.\n  setAutoFreeze(true);\n}\n\nfunction initializeProtobuf() {\n  // Disable Long.js support in protobuf. This seems to be enabled only in tests\n  // but not in production code. In any case, for now we want casting to number\n  // accepting the 2**53 limitation. This is consistent with passing\n  // --force-number in the protobuf.js codegen invocation in //ui/BUILD.gn .\n  // See also https://github.com/protobufjs/protobuf.js/issues/1253 .\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protobuf.util.Long = undefined as any;\n  protobuf.configure();\n}\n\nlet isInitialized = false;\nfunction initialize() {\n  if (isInitialized) {\n    throw new Error('initialize() should be called exactly once');\n  }\n  initializeImmer();\n  initializeProtobuf();\n  isInitialized = true;\n}\n\n// JS module semantics ensure this is happens only once.\ninitialize();\n"]}