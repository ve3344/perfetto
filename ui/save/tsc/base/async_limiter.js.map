{"version":3,"file":"async_limiter.js","sourceRoot":"","sources":["../../../src/base/async_limiter.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AAEjC,yCAA2C;AAS3C;;;;;;;;GAQG;AACH,MAAa,YAAY;IACN,SAAS,GAAW,EAAE,CAAC;IAChC,SAAS,GAAY,KAAK,CAAC;IAEnC;;;;;;;OAOG;IACH,QAAQ,CAAC,IAAc;QACrB,MAAM,QAAQ,GAAG,IAAA,gBAAK,GAAQ,CAAC;QAC/B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAC,CAAC,CAAC;QAEtC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACpB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEO,KAAK,CAAC,YAAY;QACxB,IAAI,IAAsB,CAAC;QAE3B,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC;YACvC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;YAC1B,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC;oBACH,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;oBAClB,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;gBAC1B,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACX,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC1B,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAxCD,oCAwCC","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Deferred, defer} from './deferred';\n\ntype Callback = () => Promise<void>;\n\ninterface Task {\n  deferred: Deferred<void>;\n  work: Callback;\n}\n\n/**\n * A tiny task queue management utility that ensures async tasks are not\n * executed concurrently.\n *\n * If a task is run while a previous one is still running, it is enqueued and\n * run after the first task completes.\n *\n * If multiple tasks are enqueued, only the latest task is run.\n */\nexport class AsyncLimiter {\n  private readonly taskQueue: Task[] = [];\n  private isRunning: boolean = false;\n\n  /**\n   * Schedule a task to be run.\n   *\n   * @param work An async function to schedule.\n   * @returns A promise that resolves when either the task has finished\n   * executing, or after the task has silently been discarded because a newer\n   * task was scheduled.\n   */\n  schedule(work: Callback): Promise<void> {\n    const deferred = defer<void>();\n    this.taskQueue.push({work, deferred});\n\n    if (!this.isRunning) {\n      this.isRunning = true;\n      this.runTaskQueue().finally(() => (this.isRunning = false));\n    }\n\n    return deferred;\n  }\n\n  private async runTaskQueue(): Promise<void> {\n    let task: Task | undefined;\n\n    while ((task = this.taskQueue.shift())) {\n      if (this.taskQueue.length > 0) {\n        task.deferred.resolve();\n      } else {\n        try {\n          await task.work();\n          task.deferred.resolve();\n        } catch (e) {\n          task.deferred.reject(e);\n        }\n      }\n    }\n  }\n}\n"]}