{"version":3,"file":"shared_disposable.js","sourceRoot":"","sources":["../../../src/base/shared_disposable.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AAEjC,uCAAsC;AAEtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCG;AACH,MAAa,qBAAqB;IAGhC,0EAA0E;IAC1E,4BAA4B;IACX,UAAU,CAAqB;IAEhD,oCAAoC;IACnB,UAAU,CAAI;IAE/B,0EAA0E;IAC1E,wBAAwB;IAChB,WAAW,GAAG,KAAK,CAAC;IAE5B;;;;;OAKG;IACH,MAAM,CAAC,IAAI,CACT,UAAa;QAEb,OAAO,IAAI,qBAAqB,CAAC,UAAU,CAAC,CAAC;IAC/C,CAAC;IAED,YAAoB,UAAa,EAAE,UAA+B;QAChE,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,IAAI,CAAC,UAAU,GAAG,EAAC,QAAQ,EAAE,CAAC,EAAC,CAAC;QAClC,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC/B,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,GAAG;QACD,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED;;;;OAIG;IACH,KAAK;QACH,sDAAsD;QACtD,IAAA,qBAAW,EAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAE9B,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;QAC3B,OAAO,IAAI,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;IACrE,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC;QACzB,mDAAmD;QACnD,IAAA,qBAAW,EAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAE9B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;QAE3B,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC;YACnC,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC;QAC/C,CAAC;IACH,CAAC;CACF;AA/ED,sDA+EC","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assertFalse} from './logging';\n\n/**\n * Adds reference counting to an AsyncDisposable.\n *\n * Allows you to share a disposable amongst multiple different entities which\n * may have differing lifecycles, and only have the resource cleared up once all\n * components have called dispose on it.\n *\n * @example\n * ```ts\n * {\n *   // Create a shared disposable around an arbitrary disposable resource\n *   await using sharedResource = SharedAsyncDisposable.wrap(resource);\n *\n *   // Pass a the shared resource somewhere else (notice we don't await here,\n *   // which detaches their lifecycle from ours - i.e. we don't know which task\n *   // will finish first, us or them)\n *   doStuff(sharedResource);\n *\n *   // Do something with the resource\n *   await sharedResource.get().doStuff(...);\n *\n *   // Our shard resource is disposed here, but the underlying resource will\n *   // only be disposed once doStuff() is done with it too\n * }\n *\n * // --cut--\n *\n * async function doStuff(shared) {\n *   await using res = shared.clone();\n *\n *   // Do stuff with the resource\n *   await res.get().doStuff(...);\n *\n *   // res is automatically disposed here\n * }\n * ```\n */\nexport class SharedAsyncDisposable<T extends AsyncDisposable>\n  implements AsyncDisposable\n{\n  // A shared core which is referenced by al instances of this class used to\n  // store the reference count\n  private readonly sharedCore: {refCount: number};\n\n  // This is our underlying disposable\n  private readonly disposable: T;\n\n  // Record of whether this instance is disposed (not whether the underlying\n  // instance is disposed)\n  private _isDisposed = false;\n\n  /**\n   * Create a new shared disposable object from an arbitrary disposable.\n   *\n   * @param disposable The disposable object to wrap.\n   * @returns A new SharedAsyncDisposable object.\n   */\n  static wrap<T extends AsyncDisposable>(\n    disposable: T,\n  ): SharedAsyncDisposable<T> {\n    return new SharedAsyncDisposable(disposable);\n  }\n\n  private constructor(disposable: T, sharedCore?: {refCount: number}) {\n    this.disposable = disposable;\n    if (!sharedCore) {\n      this.sharedCore = {refCount: 1};\n    } else {\n      this.sharedCore = sharedCore;\n    }\n  }\n\n  /**\n   * Check whether this is disposed. If true, clone() and\n   * [Symbol.asyncDispose]() will return throw. Can be used to check state\n   * before cloning.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * @returns The underlying disposable.\n   */\n  get(): T {\n    return this.disposable;\n  }\n\n  /**\n   * Create a clone of this object, incrementing the reference count.\n   *\n   * @returns A new shared disposable instance.\n   */\n  clone(): SharedAsyncDisposable<T> {\n    // Cloning again after dispose indicates invalid usage\n    assertFalse(this._isDisposed);\n\n    this.sharedCore.refCount++;\n    return new SharedAsyncDisposable(this.disposable, this.sharedCore);\n  }\n\n  /**\n   * Dispose of this object, decrementing the reference count. If the reference\n   * count drops to 0, the underlying disposable is disposed.\n   */\n  async [Symbol.asyncDispose](): Promise<void> {\n    // Disposing multiple times indicates invalid usage\n    assertFalse(this._isDisposed);\n\n    this._isDisposed = true;\n    this.sharedCore.refCount--;\n\n    if (this.sharedCore.refCount === 0) {\n      await this.disposable[Symbol.asyncDispose]();\n    }\n  }\n}\n"]}