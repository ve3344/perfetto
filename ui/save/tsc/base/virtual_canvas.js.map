{"version":3,"file":"virtual_canvas.js","sourceRoot":"","sources":["../../../src/base/virtual_canvas.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Canvases have limits on their maximum size (which is determined by the\n * system). Usually, this limit is fairly large, but can be as small as\n * 4096x4096px on some machines.\n *\n * If we need a super large canvas, we need to use a different approach.\n *\n * Unless the user has a huge monitor, most of the time any sufficiently large\n * canvas will overflow it's container, so we assume this container is set to\n * scroll so that the user can actually see all of the canvas. We can take\n * advantage of the fact that users may only see a small portion of the canvas\n * at a time. So, if we position a small floating canvas element over the\n * viewport of the scrolling container, we can approximate a huge canvas using a\n * much smaller one.\n *\n * Given a target element and it's scrolling container, VirtualCanvas turns an\n * empty HTML element into a \"virtual\" canvas with virtually unlimited size\n * using the \"floating\" canvas technique described above.\n */\n\nimport {DisposableStack} from './disposable_stack';\nimport {Bounds2D, Rect2D, Size2D} from './geom';\n\nexport type LayoutShiftListener = (\n  canvas: HTMLCanvasElement,\n  rect: Rect2D,\n) => void;\n\nexport type CanvasResizeListener = (\n  canvas: HTMLCanvasElement,\n  width: number,\n  height: number,\n) => void;\n\nexport interface VirtualCanvasOpts {\n  // How much buffer to add around the visible window in the scrollable axes.\n  // The larger this number, the more we can scroll before triggering a move and\n  // update which reduces thrashing when scrolling quickly, but the more canvas\n  // will need to be drawn each render cycle.\n  readonly overdrawPx: number;\n\n  // This figure controls how close we can get to the edge of the drawn canvas\n  // before moving it and triggering a redraw. If 0, we can get all the way to\n  // the edge of the canvas before moving it. Larger values will result in more\n  // frequent redraws but less chance of seeing blank bits of canvas when\n  // scrolling quickly.\n  readonly tolerancePx?: number;\n\n  // Which axes should we overdraw? Typically we only want to overdraw in the\n  // axes we expect to scroll in. So if we only expect the container to be\n  // vertically scrolled, choose 'y'.\n  readonly overdrawAxes?: 'none' | 'x' | 'y' | 'both';\n}\n\nexport class VirtualCanvas implements Disposable {\n  private readonly _trash = new DisposableStack();\n  private readonly _canvasElement: HTMLCanvasElement;\n  private readonly _targetElement: HTMLElement;\n\n  // Describes the offset of the canvas w.r.t. the \"target\" container\n  private _canvasRect: Rect2D;\n  private _viewportLimits: Rect2D;\n  private _layoutShiftListener?: LayoutShiftListener;\n  private _canvasResizeListener?: CanvasResizeListener;\n  private _dpr?: number;\n\n  /**\n   * @param targetElement The element to turn into a virtual canvas. The\n   * dimensions of this element are used to size the canvas, so ensure this\n   * element is sized appropriately.\n   * @param containerElement The scrolling container to be used for determining\n   * the size and position of the canvas. The targetElement should be a child of\n   * this element.\n   * @param opts Setup options for the VirtualCanvas.\n   */\n  constructor(\n    targetElement: HTMLElement,\n    containerElement: Element,\n    opts?: Partial<VirtualCanvasOpts>,\n  ) {\n    const {\n      overdrawPx = 200,\n      tolerancePx = 100,\n      overdrawAxes: scrollAxes = 'none',\n    } = opts ?? {};\n\n    const viewportOversize = overdrawPx - tolerancePx;\n\n    // Returns the rect of the container's viewport W.R.T the target element.\n    function getViewportRect() {\n      const containerRect = new Rect2D(\n        containerElement.getBoundingClientRect(),\n      );\n      const targetElementRect = targetElement.getBoundingClientRect();\n\n      // Calculate the intersection of the container's viewport and the target\n      const intersection = containerRect.intersect(targetElementRect);\n\n      return intersection.reframe(targetElementRect);\n    }\n\n    const getCanvasRect = () => {\n      const viewport = getViewportRect();\n\n      if (this._viewportLimits.contains(viewport)) {\n        return this._canvasRect;\n      } else {\n        const canvasRect = viewport.expand({\n          height: scrollAxes === 'both' || scrollAxes === 'y' ? overdrawPx : 0,\n          width: scrollAxes === 'both' || scrollAxes === 'x' ? overdrawPx : 0,\n        });\n\n        this._viewportLimits = viewport.expand({\n          height:\n            scrollAxes === 'both' || scrollAxes === 'y' ? viewportOversize : 0,\n          width:\n            scrollAxes === 'both' || scrollAxes === 'x' ? viewportOversize : 0,\n        });\n\n        return canvasRect;\n      }\n    };\n\n    const updateCanvas = () => {\n      let repaintRequired = false;\n\n      const canvasRect = getCanvasRect();\n      const canvasRectPrev = this._canvasRect;\n      this._canvasRect = canvasRect;\n\n      if (\n        canvasRectPrev.width !== canvasRect.width ||\n        canvasRectPrev.height !== canvasRect.height ||\n        devicePixelRatio !== this._dpr\n      ) {\n        this._dpr = devicePixelRatio;\n\n        // Canvas needs to change size, update its size\n        canvas.style.width = `${canvasRect.width}px`;\n        canvas.style.height = `${canvasRect.height}px`;\n        this._canvasResizeListener?.(\n          canvas,\n          canvasRect.width,\n          canvasRect.height,\n        );\n        repaintRequired = true;\n      }\n\n      if (\n        canvasRectPrev.left !== canvasRect.left ||\n        canvasRectPrev.top !== canvasRect.top\n      ) {\n        // Canvas needs to move, update the transform\n        canvas.style.transform = `translate(${canvasRect.left}px, ${canvasRect.top}px)`;\n        repaintRequired = true;\n      }\n\n      repaintRequired && this._layoutShiftListener?.(canvas, canvasRect);\n    };\n\n    containerElement.addEventListener('scroll', updateCanvas, {\n      passive: true,\n    });\n    this._trash.defer(() =>\n      containerElement.removeEventListener('scroll', updateCanvas),\n    );\n\n    // Resize observer callbacks are called once immediately after registration\n    const resizeObserver = new ResizeObserver((_cb) => {\n      updateCanvas();\n    });\n\n    resizeObserver.observe(containerElement);\n    resizeObserver.observe(targetElement);\n    this._trash.defer(() => {\n      resizeObserver.disconnect();\n    });\n\n    // Ensures the canvas doesn't change the size of the target element\n    targetElement.style.overflow = 'hidden';\n\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    targetElement.appendChild(canvas);\n    this._trash.defer(() => {\n      targetElement.removeChild(canvas);\n    });\n\n    this._canvasElement = canvas;\n    this._targetElement = targetElement;\n    this._canvasRect = new Rect2D({\n      left: 0,\n      top: 0,\n      bottom: 0,\n      right: 0,\n    });\n    this._viewportLimits = this._canvasRect;\n  }\n\n  /**\n   * Set the callback that gets called when the canvas element is moved or\n   * resized, thus, invalidating the contents, and should be re-painted.\n   *\n   * @param cb The new callback.\n   */\n  setLayoutShiftListener(cb: LayoutShiftListener) {\n    this._layoutShiftListener = cb;\n  }\n\n  /**\n   * Set the callback that gets called when the canvas element is resized. This\n   * might be a good opportunity to update the size of the canvas' draw buffer.\n   *\n   * @param cb The new callback.\n   */\n  setCanvasResizeListener(cb: CanvasResizeListener) {\n    this._canvasResizeListener = cb;\n  }\n\n  /**\n   * The floating canvas element.\n   */\n  get canvasElement(): HTMLCanvasElement {\n    return this._canvasElement;\n  }\n\n  /**\n   * The target element, i.e. the one passed to our constructor.\n   */\n  get targetElement(): HTMLElement {\n    return this._targetElement;\n  }\n\n  /**\n   * The size of the target element, aka the size of the virtual canvas.\n   */\n  get size(): Size2D {\n    return {\n      width: this._targetElement.clientWidth,\n      height: this._targetElement.clientHeight,\n    };\n  }\n\n  /**\n   * Returns the rect of the floating canvas with respect to the target element.\n   * This will need to be subtracted from any drawing operations to get the\n   * right alignment within the virtual canvas.\n   */\n  get canvasRect(): Rect2D {\n    return this._canvasRect;\n  }\n\n  /**\n   * Stop listening to DOM events.\n   */\n  [Symbol.dispose]() {\n    this._trash.dispose();\n  }\n\n  /**\n   * Return true if a rect overlaps the floating canvas.\n   * @param rect The rect to test.\n   * @returns true if rect overlaps, false otherwise.\n   */\n  overlapsCanvas(rect: Bounds2D): boolean {\n    const c = this._canvasRect;\n    const y = rect.top < c.bottom && rect.bottom > c.top;\n    const x = rect.left < c.right && rect.right > c.left;\n    return x && y;\n  }\n}\n"]}