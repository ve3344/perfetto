{"version":3,"file":"trace_stream.js","sourceRoot":"","sources":["../../../src/core/trace_stream.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2019 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {defer, Deferred} from '../base/deferred';\nimport {assertExists, assertTrue} from '../base/logging';\nimport {exists} from '../base/utils';\n\nconst SLICE_SIZE = 32 * 1024 * 1024;\n\n// The object returned by TraceStream.readChunk() promise.\nexport interface TraceChunk {\n  data: Uint8Array;\n  eof: boolean;\n  bytesRead: number;\n  bytesTotal: number;\n}\n\n// Base interface for loading trace data in chunks.\n// The caller has to call readChunk() until TraceChunk.eof == true.\nexport interface TraceStream {\n  readChunk(): Promise<TraceChunk>;\n}\n\n// Loads a trace from a File object. For the \"open file\" use case.\nexport class TraceFileStream implements TraceStream {\n  private traceFile: Blob;\n  private reader: FileReader;\n  private pendingRead?: Deferred<TraceChunk>;\n  private bytesRead = 0;\n\n  constructor(traceFile: Blob) {\n    this.traceFile = traceFile;\n    this.reader = new FileReader();\n    this.reader.onloadend = () => this.onLoad();\n  }\n\n  private onLoad() {\n    const pendingRead = assertExists(this.pendingRead);\n    this.pendingRead = undefined;\n    if (this.reader.error) {\n      pendingRead.reject(this.reader.error);\n      return;\n    }\n    const res = assertExists(this.reader.result) as ArrayBuffer;\n    this.bytesRead += res.byteLength;\n    pendingRead.resolve({\n      data: new Uint8Array(res),\n      eof: this.bytesRead >= this.traceFile.size,\n      bytesRead: this.bytesRead,\n      bytesTotal: this.traceFile.size,\n    });\n  }\n\n  readChunk(): Promise<TraceChunk> {\n    const sliceEnd = Math.min(this.bytesRead + SLICE_SIZE, this.traceFile.size);\n    const slice = this.traceFile.slice(this.bytesRead, sliceEnd);\n    this.pendingRead = defer<TraceChunk>();\n    this.reader.readAsArrayBuffer(slice);\n    return this.pendingRead;\n  }\n}\n\n// Loads a trace from an ArrayBuffer. For the window.open() + postMessage\n// use-case, used by other dashboards (see post_message_handler.ts).\nexport class TraceBufferStream implements TraceStream {\n  private traceBuf: ArrayBuffer;\n  private bytesRead = 0;\n\n  constructor(traceBuf: ArrayBuffer) {\n    this.traceBuf = traceBuf;\n  }\n\n  readChunk(): Promise<TraceChunk> {\n    assertTrue(this.bytesRead <= this.traceBuf.byteLength);\n    const len = Math.min(SLICE_SIZE, this.traceBuf.byteLength - this.bytesRead);\n    const data = new Uint8Array(this.traceBuf, this.bytesRead, len);\n    this.bytesRead += len;\n    return Promise.resolve({\n      data,\n      eof: this.bytesRead >= this.traceBuf.byteLength,\n      bytesRead: this.bytesRead,\n      bytesTotal: this.traceBuf.byteLength,\n    });\n  }\n}\n\n// Loads a stream from a URL via fetch(). For the permalink (?s=UUID) and\n// open url (?url=http://...) cases.\nexport class TraceHttpStream implements TraceStream {\n  private bytesRead = 0;\n  private bytesTotal = 0;\n  private uri: string;\n  private httpStream?: ReadableStreamDefaultReader<Uint8Array>;\n\n  constructor(uri: string) {\n    assertTrue(uri.startsWith('http://') || uri.startsWith('https://'));\n    this.uri = uri;\n  }\n\n  async readChunk(): Promise<TraceChunk> {\n    // Initialize the fetch() job on the first read request.\n    if (this.httpStream === undefined) {\n      const response = await fetch(this.uri);\n      if (response.status !== 200) {\n        throw new Error(`HTTP ${response.status} - ${response.statusText}`);\n      }\n      const len = response.headers.get('Content-Length');\n      this.bytesTotal = exists(len) ? Number.parseInt(len, 10) : 0;\n      this.httpStream = response.body!.getReader();\n    }\n\n    let eof = false;\n    let bytesRead = 0;\n    const chunks = [];\n\n    // httpStream can return very small chunks which can slow down\n    // TraceProcessor. Here we accumulate chunks until we get at least 32mb\n    // or hit EOF.\n    while (!eof && bytesRead < 32 * 1024 * 1024) {\n      const res = await this.httpStream.read();\n      if (res.value) {\n        chunks.push(res.value);\n        bytesRead += res.value.length;\n      }\n      eof = res.done;\n    }\n\n    let data;\n    if (chunks.length === 1) {\n      data = chunks[0];\n    } else {\n      // Stitch all the chunks into one big array:\n      data = new Uint8Array(bytesRead);\n      let offset = 0;\n      for (const chunk of chunks) {\n        data.set(chunk, offset);\n        offset += chunk.length;\n      }\n    }\n\n    this.bytesRead += data.length;\n\n    return {\n      data,\n      eof,\n      bytesRead: this.bytesRead,\n      bytesTotal: this.bytesTotal,\n    };\n  }\n}\n"]}