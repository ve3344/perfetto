{"version":3,"file":"pivot_table_types.js","sourceRoot":"","sources":["../../../src/core/pivot_table_types.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {SortDirection} from '../base/comparison_utils';\nimport {AreaSelection} from '../public/selection';\nimport {ColumnType} from '../trace_processor/query_result';\n\n// Auxiliary metadata needed to parse the query result, as well as to render it\n// correctly. Generated together with the text of query and passed without the\n// change to the query response.\n\nexport interface PivotTableQueryMetadata {\n  pivotColumns: TableColumn[];\n  aggregationColumns: Aggregation[];\n  countIndex: number;\n}\n// Everything that's necessary to run the query for pivot table\n\nexport interface PivotTableQuery {\n  text: string;\n  metadata: PivotTableQueryMetadata;\n}\n// Pivot table query result\n\nexport interface PivotTableResult {\n  // Hierarchical pivot structure on top of rows\n  tree: PivotTree;\n  // Copy of the query metadata from the request, bundled up with the query\n  // result to ensure the correct rendering.\n  metadata: PivotTableQueryMetadata;\n}\n// Input parameters to check whether the pivot table needs to be re-queried.\n\nexport interface PivotTableState {\n  // Currently selected area, if null, pivot table is not going to be visible.\n  selectionArea?: AreaSelection;\n\n  // Query response\n  queryResult: PivotTableResult | undefined;\n\n  // Selected pivots for tables other than slice.\n  // Because of the query generation, pivoting happens first on non-slice\n  // pivots; therefore, those can't be put after slice pivots. In order to\n  // maintain the separation more clearly, slice and non-slice pivots are\n  // located in separate arrays.\n  selectedPivots: TableColumn[];\n\n  // Selected aggregation columns. Stored same way as pivots.\n  selectedAggregations: Aggregation[];\n\n  // Whether the pivot table results should be constrained to the selected area.\n  constrainToArea: boolean;\n}\n\n// Node in the hierarchical pivot tree. Only leaf nodes contain data from the\n// query result.\n\nexport interface PivotTree {\n  // Whether the node should be collapsed in the UI, false by default and can\n  // be toggled with the button.\n  isCollapsed: boolean;\n\n  // Non-empty only in internal nodes.\n  children: Map<ColumnType, PivotTree>;\n  aggregates: ColumnType[];\n\n  // Non-empty only in leaf nodes.\n  rows: ColumnType[][];\n}\n\nexport type AggregationFunction = 'COUNT' | 'SUM' | 'MIN' | 'MAX' | 'AVG';\n// Queried \"table column\" is either:\n// 1. A real one, represented as object with table and column name.\n// 2. Pseudo-column 'count' that's rendered as '1' in SQL to use in queries like\n// `select sum(1), name from slice group by name`.\n\nexport interface RegularColumn {\n  kind: 'regular';\n  table: string;\n  column: string;\n}\n\nexport interface ArgumentColumn {\n  kind: 'argument';\n  argument: string;\n}\n\nexport type TableColumn = RegularColumn | ArgumentColumn;\n\nexport function tableColumnEquals(t1: TableColumn, t2: TableColumn): boolean {\n  switch (t1.kind) {\n    case 'argument': {\n      return t2.kind === 'argument' && t1.argument === t2.argument;\n    }\n    case 'regular': {\n      return (\n        t2.kind === 'regular' &&\n        t1.table === t2.table &&\n        t1.column === t2.column\n      );\n    }\n  }\n}\n\nexport function toggleEnabled<T>(\n  compare: (fst: T, snd: T) => boolean,\n  arr: T[],\n  column: T,\n  enabled: boolean,\n): void {\n  if (enabled && arr.find((value) => compare(column, value)) === undefined) {\n    arr.push(column);\n  }\n  if (!enabled) {\n    const index = arr.findIndex((value) => compare(column, value));\n    if (index !== -1) {\n      arr.splice(index, 1);\n    }\n  }\n}\n\nexport interface Aggregation {\n  aggregationFunction: AggregationFunction;\n  column: TableColumn;\n\n  // If the aggregation is sorted, the field contains a sorting direction.\n  sortDirection?: SortDirection;\n}\n\nexport function aggregationEquals(agg1: Aggregation, agg2: Aggregation) {\n  return new EqualsBuilder(agg1, agg2)\n    .comparePrimitive((agg) => agg.aggregationFunction)\n    .compare(tableColumnEquals, (agg) => agg.column)\n    .equals();\n}\n\n// Used to convert TableColumn to a string in order to store it in a Map, as\n// ES6 does not support compound Set/Map keys. This function should only be used\n// for interning keys, and does not have any requirements beyond different\n// TableColumn objects mapping to different strings.\n\nexport function columnKey(tableColumn: TableColumn): string {\n  switch (tableColumn.kind) {\n    case 'argument': {\n      return `argument:${tableColumn.argument}`;\n    }\n    case 'regular': {\n      return `${tableColumn.table}.${tableColumn.column}`;\n    }\n  }\n}\n\nexport function aggregationKey(aggregation: Aggregation): string {\n  return `${aggregation.aggregationFunction}:${columnKey(aggregation.column)}`;\n}\n\nexport const COUNT_AGGREGATION: Aggregation = {\n  aggregationFunction: 'COUNT',\n  // Exact column is ignored for count aggregation because it does not matter\n  // what to count, use empty strings.\n  column: {kind: 'regular', table: '', column: ''},\n};\n\n// Simple builder-style class to implement object equality more succinctly.\nclass EqualsBuilder<T> {\n  result = true;\n  first: T;\n  second: T;\n\n  constructor(first: T, second: T) {\n    this.first = first;\n    this.second = second;\n  }\n\n  comparePrimitive(getter: (arg: T) => string | number): EqualsBuilder<T> {\n    if (this.result) {\n      this.result = getter(this.first) === getter(this.second);\n    }\n    return this;\n  }\n\n  compare<S>(\n    comparator: (first: S, second: S) => boolean,\n    getter: (arg: T) => S,\n  ): EqualsBuilder<T> {\n    if (this.result) {\n      this.result = comparator(getter(this.first), getter(this.second));\n    }\n    return this;\n  }\n\n  equals(): boolean {\n    return this.result;\n  }\n}\n"]}