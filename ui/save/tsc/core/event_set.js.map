{"version":3,"file":"event_set.js","sourceRoot":"","sources":["../../../src/core/event_set.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {arrayEquals, isArrayOf} from '../base/array_utils';\nimport {isString} from '../base/object_utils';\nimport {intersect} from '../base/set_utils';\n\n// Contents:\n// CORE_TYPES - The main types for using EventSet.\n// EVENT_SET_IMPLS - Impl of {Concreate, Empty, Sql, Naive{...}}EventSet\n// EXPR - Expression logic which can be lowered to either JS or SQL\n// STUPID_TYPE_MAGIC\n// HELPERS - Random helpers.\n\n// CORE_TYPES =========================================================\n\n// A single value. These are often retrieved from trace_processor so\n// need to map to the related sqlite type:\n// null = NULL, string = TEXT, number = INTEGER/REAL,\n// boolean = INTEGER, bigint = INTEGER\nexport type Primitive = null | string | boolean | number | bigint;\n\nexport const Null = 'null' as const;\nexport const Num = 'num' as const;\nexport const BigInt = 'bigint' as const;\nexport const Str = 'str' as const;\nexport const Id = 'id' as const;\nexport const Bool = 'bool' as const;\n\n// Values may be of any of the above types:\nexport type KeyType =\n  | typeof Num\n  | typeof Str\n  | typeof Null\n  | typeof Id\n  | typeof Bool\n  | typeof BigInt;\n\n// KeySet is a specification for the key/value pairs on an Event.\n// - Every event must have a string ID.\n// - In addition Events may have 1 or more key/value pairs.\n// The *specification* for the key/value pair has to be *precisely* one\n// of the KeySet constants above. So:\n// const thisTypeChecks: KeySet = { foo: Str };\n// const thisDoesNot: KeySet = { foo: \"bar\" };\n// Since although 'bar' is a string it's not a KeyType.\nexport type KeySet = {\n  readonly [key: string]: KeyType;\n};\n\n// The empty keyset. Events from this KeySet will only have ids.\nexport interface EmptyKeySet extends KeySet {}\n\nexport type UntypedKeySet = KeySet;\n\n// A single trace Event.\n// Events have:\n// - A globally unique identifier `id`.\n// - Zero or more key/value pairs.\n// Note: Events do *not* have to have all possible keys/value pairs for\n// the given id. It is expected that users will only materialise the\n// key/value pairs relevant to the specific use case at hand.\nexport type WritableUntypedEvent = {\n  id: string;\n  [key: string]: Primitive;\n};\n\nexport type UntypedEvent = Readonly<WritableUntypedEvent>;\n\nexport type Event<K extends KeySet> = {\n  readonly [Property in Exclude<keyof K, 'id'>]: ConformingValue<K[Property]>;\n} & {\n  readonly id: string;\n};\n\n// An EventSet is a:\n// - ordered\n// - immutable\n// - subset\n// of events in the trace.\nexport interface EventSet<P extends KeySet> {\n  // All possible keys for Events in this EventSet.\n  readonly keys: P;\n\n  // Methods for refining the set.\n  // Note: these are all synchronous - we expect the cost (and hence\n  // any asynchronous queries) to be deferred to analysis time.\n  filter(...filters: Filter[]): EventSet<P>;\n  sort(...sorts: Sort[]): EventSet<P>;\n  union<Q extends KeySet>(other: EventSet<Q>): Merged<P, Q>;\n  intersect<Q extends KeySet>(other: EventSet<Q>): Merged<P, Q>;\n\n  // Methods for analysing the set.\n  // Note: these are all asynchronous - it's expected that these will\n  // often have to do queries.\n  count(): Promise<number>;\n  isEmpty(): Promise<boolean>;\n  materialise<T extends KeySet>(\n    keys: T,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<T, P>>;\n}\n\ninterface UnionEventSet<T extends KeySet> extends EventSet<T> {\n  readonly parents: EventSet<T>[];\n  readonly isUnion: true;\n  create(...events: EventSet<KeySet>[]): UnionEventSet<T>;\n}\n\ninterface IntersectionEventSet<T extends KeySet> extends EventSet<T> {\n  readonly parents: EventSet<T>[];\n  readonly isIntersection: true;\n  create(...events: EventSet<KeySet>[]): IntersectionEventSet<T>;\n}\n\ninterface FilterEventSet<T extends KeySet> extends EventSet<T> {\n  readonly parent: EventSet<T>;\n  readonly filters: Filter[];\n  readonly isFilter: true;\n}\n\ninterface SortEventSet<T extends KeySet> extends EventSet<T> {\n  readonly parent: EventSet<T>;\n  readonly sorts: Sort[];\n  readonly isSort: true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type UntypedEventSet = EventSet<any>;\n\n// An expression that operates on an Event and produces a Primitive as\n// output. Expressions have to work both in JavaScript and in SQL.\n// In SQL users can use buildQueryFragment to convert the expression\n// into a snippet of SQL. For JavaScript they call execute(). In both\n// cases you need to know which keys the expression uses, for this call\n// `freeVariables`.\n// TODO(hjd): These should also be paramatised by KeySet and final\n// type.\nexport interface Expr {\n  // Return a fragment of SQL that can be used to evaluate the\n  // expression. `binding` maps key names to column names in the\n  // resulting SQL. The caller must ensure that binding includes at\n  // least all the keys from `freeVariables`.\n  buildQueryFragment(binding: Map<string, string>): string;\n\n  // Run the expression on an Event. The caller must ensure that event\n  // has all the keys from `freeVariables` materialised.\n  execute(event: UntypedEvent): Primitive;\n\n  // Returns the set of keys used in this expression.\n  // For example in an expression representing `(foo + 4) * bar`\n  // freeVariables would return the set {foo: Num, bar: Num}.\n  freeVariables(): KeySet;\n}\n\n// A filter is a (normally boolean) expression.\nexport type Filter = Expr;\n\n// Sorting direction.\nexport enum Direction {\n  ASC,\n  DESC,\n}\n\n// A sort is an expression combined with a direction:\nexport interface Sort {\n  direction: Direction;\n  expression: Expr;\n}\n\n// EVENT_SET_IMPLS ====================================================\n\n// OptimisingEventSet is what makes it a) tractable to write EventSet\n// implementations and b) have those implementations be fast.\n// The EventSet interface has two kinds of methods:\n// 1. Synchronous refinement methods which produce an EventSet and\n//    often take a second EventSet as an argument\n// 2. Asynchronous 'analysis' methods\n//\n// Together this means in the minimal case subclasses only *have* to\n// implement the single abstract method: materialise(). Everything else\n// is handled for you.\nexport abstract class OptimisingEventSet<P extends KeySet>\n  implements EventSet<P>\n{\n  abstract readonly keys: P;\n\n  // OptimisingEventSet provides the synchronous refinement methods.\n  // The basic pattern is to construct a 'NaiveFoo' EventSet which will\n  // do the given operation (filter, sort, union, intersection) in\n  // JavaScript then call optimise(). Optimse then tries to improve the\n  // EventSet tree - and avoid having to use the fallback naive\n  // implementaion.\n  // Optimise does 'tree rewriting' of the EventSet tree. For example\n  // considering a tree: 'union(A, 0)' where 0 is the empty set and\n  // A is some arbitrary EventSet, optimise(union(A, 0)) returns A.\n  // For more detail see optimise() below.\n\n  filter(...filters: Filter[]): EventSet<P> {\n    const result = new NaiveFilterEventSet(this, filters);\n    const optimised = optimise(result);\n    return optimised;\n  }\n\n  sort(...sorts: Sort[]): EventSet<P> {\n    const result = new NaiveSortEventSet(this, sorts);\n    const optimised = optimise(result);\n    return optimised;\n  }\n\n  union<Q extends KeySet>(other: EventSet<Q>): Merged<P, Q> {\n    const merged = mergeKeys(this.keys, other.keys);\n    const result = new NaiveUnionEventSet<MergedKeys<P, Q>>(\n      merged,\n      this as UntypedEventSet,\n      other as UntypedEventSet,\n    );\n    const optimised = optimise(result);\n    return optimised;\n  }\n\n  intersect<Q extends KeySet>(other: EventSet<Q>): Merged<P, Q> {\n    const merged = mergeKeys(this.keys, other.keys);\n    const result = new NaiveIntersectionEventSet<MergedKeys<P, Q>>(\n      merged,\n      this as UntypedEventSet,\n      other as UntypedEventSet,\n    );\n    const optimised = optimise(result);\n    return optimised;\n  }\n\n  // Analysis methods should be implemented by the subclass.\n  // Materialise is abstract and must be implemented by the subclass.\n  abstract materialise<Q extends KeySet>(\n    keys: Q,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<Q, P>>;\n\n  // We provide a default implementation of count() on top of\n  // materialise(). It's likely the subclass can provide a more\n  // performant implementation.\n  async count(): Promise<number> {\n    const materialised = await this.materialise({});\n    return materialised.events.length;\n  }\n\n  // We provide a default implementation of empty() on top of\n  // materialise(). It's likely the subclass can provide a more\n  // performant implementation.\n  async isEmpty(): Promise<boolean> {\n    const materialised = await this.materialise(\n      {},\n      0 /* offset */,\n      1 /* limit */,\n    );\n    return materialised.events.length === 0;\n  }\n}\n\nclass NaiveFilterEventSet<P extends KeySet>\n  extends OptimisingEventSet<P>\n  implements FilterEventSet<P>\n{\n  readonly isFilter = true;\n  readonly parent: EventSet<P>;\n  readonly filters: Filter[];\n  readonly keys: P;\n\n  constructor(parent: EventSet<P>, filters: Filter[]) {\n    super();\n    this.parent = parent;\n    this.keys = this.parent.keys;\n    this.filters = filters;\n  }\n\n  async count(): Promise<number> {\n    const keys = freeVariablesFromFilters(this.filters);\n    const concreteParent = await this.parent.materialise(keys);\n    const events = concreteParent.events;\n    let total = 0;\n    for (const e of events) {\n      if (this.filters.every((f) => f.execute(e))) {\n        total += 1;\n      }\n    }\n    return total;\n  }\n\n  async isEmpty(): Promise<boolean> {\n    const keys = freeVariablesFromFilters(this.filters);\n    const concreateParent = await this.parent.materialise(keys);\n    const events = concreateParent.events;\n    for (const e of events) {\n      if (this.filters.every((f) => f.execute(e))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  async materialise<Q extends KeySet>(\n    keys: Q,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<Q, P>> {\n    const combined = freeVariablesFromFilters(this.filters, keys);\n    const concreateParent = await this.parent.materialise(combined);\n    let events = concreateParent.events;\n    for (const filter of this.filters) {\n      events = events.filter((e) => filter.execute(e));\n    }\n    return new ConcreteEventSet(combined, events).materialise(\n      keys,\n      offset,\n      limit,\n    );\n  }\n}\n\nclass NaiveSortEventSet<P extends KeySet>\n  extends OptimisingEventSet<P>\n  implements SortEventSet<P>\n{\n  readonly isSort = true;\n  readonly parent: EventSet<P>;\n  readonly sorts: Sort[];\n  readonly keys: P;\n\n  constructor(parent: EventSet<P>, sorts: Sort[]) {\n    super();\n    this.parent = parent;\n    this.keys = this.parent.keys;\n    this.sorts = sorts;\n  }\n\n  async count(): Promise<number> {\n    return this.parent.count();\n  }\n\n  async isEmpty(): Promise<boolean> {\n    return this.parent.isEmpty();\n  }\n\n  async materialise<Q extends KeySet>(\n    keys: Q,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<Q, P>> {\n    const combined = freeVariablesFromSorts(this.sorts, keys);\n    const concreateParent = await this.parent.materialise(combined);\n    let events = concreateParent.events;\n    for (const sort of this.sorts) {\n      events = events.sort(cmpFromSort(sort));\n    }\n    return new ConcreteEventSet(combined, events).materialise(\n      keys,\n      offset,\n      limit,\n    );\n  }\n}\n\nexport class NaiveUnionEventSet<T extends KeySet>\n  extends OptimisingEventSet<T>\n  implements UnionEventSet<T>\n{\n  readonly isUnion = true;\n  readonly parents: EventSet<T>[];\n  readonly keys: T;\n\n  constructor(keys: T, ...parents: EventSet<T>[]) {\n    super();\n    this.keys = keys;\n    this.parents = parents;\n  }\n\n  create(...parents: EventSet<T>[]): NaiveUnionEventSet<T> {\n    return new NaiveUnionEventSet(this.keys, ...parents);\n  }\n\n  // TODO(hjd): We could implement a more efficient dedicated count().\n  // TODO(hjd): We could implement a more efficient dedicated isEmpty().\n\n  async materialise<Q extends KeySet>(\n    keys: Q,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<Q, T>> {\n    const promises = this.parents.map((p) => p.materialise(keys));\n    const materialisedParents = (await Promise.all(\n      promises,\n    )) as ConcreteEventSet<Q>[];\n    const seen = new Set<string>();\n    let events = [];\n\n    // TODO(hjd): There are various options for doing this in faster\n    // way and we should do one of them.\n    for (const parent of materialisedParents) {\n      for (const e of parent.events) {\n        if (!seen.has(e.id)) {\n          events.push(e);\n          seen.add(e.id);\n        }\n      }\n    }\n\n    events = applyLimitOffset(events, limit, offset);\n    return ConcreteEventSet.from(keys, events) as unknown as Materialised<Q, T>;\n  }\n}\n\nexport class NaiveIntersectionEventSet<T extends KeySet>\n  extends OptimisingEventSet<T>\n  implements IntersectionEventSet<T>\n{\n  readonly isIntersection = true;\n  readonly parents: EventSet<T>[];\n  readonly keys: T;\n\n  constructor(keys: T, ...parents: EventSet<T>[]) {\n    super();\n    this.keys = keys;\n    this.parents = parents;\n  }\n\n  create(...parents: EventSet<T>[]): NaiveIntersectionEventSet<T> {\n    return new NaiveIntersectionEventSet(this.keys, ...parents);\n  }\n\n  // TODO(hjd): We could implement a more efficient dedicated count().\n  // TODO(hjd): We could implement a more efficient dedicated isEmpty().\n\n  async materialise<Q extends KeySet>(\n    keys: Q,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<Q, T>> {\n    if (this.parents.length === 0) {\n      return ConcreteEventSet.from(keys, []) as Materialised<Q, T>;\n    }\n\n    const parents = this.parents.slice();\n    const firstParent = parents.pop()!;\n\n    const promises = parents.map((p) => p.materialise({}));\n    const firstPromise = firstParent.materialise(\n      keys,\n    ) as unknown as ConcreteEventSet<Q>;\n\n    const materialised = await Promise.all(promises);\n    const firstMaterialised = await firstPromise;\n\n    let ids = new Set<string>();\n    for (const e of firstMaterialised.events) {\n      ids.add(e.id);\n    }\n    for (const m of materialised) {\n      const newIds = new Set<string>();\n      for (const e of m.events) {\n        newIds.add(e.id);\n      }\n      ids = intersect(ids, newIds);\n    }\n\n    let events = firstMaterialised.events.filter((e) => ids.has(e.id));\n    events = applyLimitOffset(events, limit, offset);\n    return ConcreteEventSet.from(keys, events) as unknown as Materialised<Q, T>;\n  }\n}\n\n// A completely empty EventSet.\nexport class EmptyEventSet<T extends KeySet>\n  extends OptimisingEventSet<T>\n  implements EventSet<T>\n{\n  readonly isEmptyEventSet = true;\n  readonly keys: T;\n\n  constructor(keys: T) {\n    super();\n    this.keys = keys;\n  }\n\n  static get(): EmptyEventSet<EmptyKeySet> {\n    return new EmptyEventSet<EmptyKeySet>({});\n  }\n\n  count(): Promise<number> {\n    return Promise.resolve(0);\n  }\n\n  isEmpty(): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n\n  async materialise<Q extends KeySet>(\n    keys: Q,\n    _offset?: number,\n    _limit?: number,\n  ): Promise<Materialised<Q, T>> {\n    return Promise.resolve(\n      new ConcreteEventSet<Q>(keys, []) as unknown as Materialised<Q, T>,\n    );\n  }\n}\n\nexport class ConcreteEventSet<P extends KeySet>\n  extends OptimisingEventSet<P>\n  implements EventSet<P>\n{\n  readonly isConcreteEventSet = true;\n  readonly events: Event<P>[];\n  readonly keys: P;\n\n  static from<Q extends KeySet>(\n    keys: Q,\n    events: Event<Q>[],\n  ): ConcreteEventSet<Q> {\n    return new ConcreteEventSet<Q>(keys, events);\n  }\n\n  constructor(keys: P, events: Event<P>[]) {\n    super();\n    // TODO(hjd): Add some paranoid mode where we crash here if\n    // `events` and `keys` mismatch?\n    this.events = events;\n    this.keys = keys;\n  }\n\n  count(): Promise<number> {\n    return Promise.resolve(this.events.length);\n  }\n\n  isEmpty(): Promise<boolean> {\n    return Promise.resolve(this.events.length === 0);\n  }\n\n  materialise<Q extends KeySet>(\n    keys: Q,\n    offset?: number,\n    limit?: number,\n  ): Promise<Materialised<Q, P>> {\n    const actualOffset = offset === undefined ? 0 : offset;\n    const actualEnd =\n      limit === undefined ? this.events.length : actualOffset + limit;\n\n    const shouldFilter = !isEqualKeySet(keys, this.keys);\n    const shouldSlice = actualOffset !== 0 || actualEnd !== this.events.length;\n\n    if (!shouldFilter && !shouldSlice) {\n      return Promise.resolve(this as unknown as Materialised<Q, P>);\n    }\n\n    let events = this.events as Event<Q>[];\n\n    if (shouldFilter) {\n      events = events.map((e) => {\n        const result: WritableUntypedEvent = {\n          id: e.id,\n        };\n        for (const [k, v] of Object.entries(keys)) {\n          // While the static typing prevents folks from hitting\n          // this in the common case people can still on purpose pass\n          // keysets and lie about the types.\n          result[k] = (e as UntypedEvent)[k] ?? getKeyDefault(k, v);\n        }\n        return result as Event<Q>;\n      });\n    }\n\n    if (shouldSlice) {\n      events = events.slice(actualOffset, actualEnd);\n    }\n\n    return Promise.resolve(\n      new ConcreteEventSet<Q>(keys, events) as unknown as Materialised<Q, P>,\n    );\n  }\n}\n\n// Optimse:\n// We have a couple major kinds of optimisation:\n// 1. Pushing down filters.\n// 2. Set optimisations (e.g union(empty, A) == A)\n// 3. Merging EventSets of the same kind\n//\n// In more detail:\n// 1. Pushing down filters. For example:\n//    filter(union(A, B), pred) ==\n//      union(filter(A, pred), filter(B, pred))\n//    This is more useful than it seems since if we manage to push down\n//    filters all the may to SQL they can be implemented very\n//    efficiently in C++.\n// 2. Classic set optimisations. e.g.\n//      union(A, empty) == A\n//      union(A, A) == A\n//      intersect(A, empty) == empty\n//      etc\n// 3. Merging EventSets of the same type. For example:\n//    union(concrete(a, b), concrete(b, c)) == concrete(a, b, c)\n//    Similarly the combinations of two SQL EventSets can be converted\n//    into a single SQL EventSet with a more complicated query -\n//    avoiding doing the processing in TypeScript.\n//\n// A critical pre-condition of this function is that EventSets are\n// immutable - this allows us to reuse parts of the input event set tree\n// in the output.\nexport function optimise<T extends KeySet>(eventSet: EventSet<T>): EventSet<T> {\n  // Empty EventSet can't be futher optimised.\n  if (isEmptyEventSet(eventSet)) {\n    return eventSet;\n  }\n\n  if (isConcreteEventSet(eventSet)) {\n    // A concrete events with zero elements is the empty events.\n    if (eventSet.events.length === 0) {\n      return new EmptyEventSet(eventSet.keys);\n    }\n    // ...but otherwise can not be optimised further.\n    return eventSet;\n  }\n\n  if (isUnionEventSet(eventSet)) {\n    const keys = eventSet.keys;\n\n    let newParents: EventSet<T>[] = eventSet.parents.slice();\n\n    // Empty sets don't contribute to the union.\n    newParents = newParents.filter((p) => !isEmptyEventSet(p));\n\n    // union([]) is empty.\n    if (newParents.length === 0) {\n      return new EmptyEventSet(keys);\n    }\n\n    if (newParents.length === 1) {\n      return newParents[0];\n    }\n\n    // The union of concrete EventSets is a concrete EventSets with all\n    // the events in.\n    if (\n      isArrayOf<ConcreteEventSet<T>, EventSet<T>>(\n        isConcreteEventSet,\n        newParents,\n      )\n    ) {\n      const seen = new Set<string>();\n      const events = [];\n      for (const p of newParents) {\n        for (const e of p.events) {\n          if (!seen.has(e.id)) {\n            events.push(e);\n            seen.add(e.id);\n          }\n        }\n      }\n      return ConcreteEventSet.from(eventSet.keys, events);\n    }\n\n    if (arrayEquals(newParents, eventSet.parents)) {\n      return eventSet;\n    } else {\n      return eventSet.create(...newParents);\n    }\n  }\n\n  if (isIntersectionEventSet(eventSet)) {\n    // For any x: intersect([x, 0]) is 0\n    for (const parent of eventSet.parents) {\n      if (isEmptyEventSet(parent)) {\n        return parent;\n      }\n    }\n    return eventSet;\n  }\n\n  if (isFilterEventSet(eventSet)) {\n    const parent = eventSet.parent;\n\n    if (isEmptyEventSet(parent)) {\n      return parent;\n    }\n\n    return eventSet;\n  }\n\n  if (isSortEventSet(eventSet)) {\n    const parent = eventSet.parent;\n\n    if (isEmptyEventSet(parent)) {\n      return parent;\n    }\n\n    return eventSet;\n  }\n\n  // TODO(hjd): Re-add the optimisations from the prototype.\n  // TODO(hjd): Union([a, a]) === a but maybe not worth optimising.\n\n  return eventSet;\n}\n\n// EXPR ===============================================================\n\nabstract class BinOp implements Expr {\n  readonly left: Expr;\n  readonly right: Expr;\n\n  constructor(left: Expr, right: Expr) {\n    this.left = left;\n    this.right = right;\n  }\n\n  buildQueryFragment(binding: Map<string, string>): string {\n    const a = this.left.buildQueryFragment(binding);\n    const b = this.right.buildQueryFragment(binding);\n    const op = this.sqlOp();\n    return `(${a} ${op} ${b})`;\n  }\n\n  execute(event: UntypedEvent): Primitive {\n    const a = this.left.execute(event);\n    const b = this.right.execute(event);\n    return this.evaluate(a, b);\n  }\n\n  freeVariables(): KeySet {\n    const a = this.left.freeVariables();\n    const b = this.right.freeVariables();\n    return mergeKeys(a, b);\n  }\n\n  abstract sqlOp(): string;\n  abstract evaluate(lhs: Primitive, rhs: Primitive): Primitive;\n}\n\nclass Le extends BinOp implements Expr {\n  sqlOp(): string {\n    return '<=';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    return lhs! <= rhs!;\n  }\n}\n\nclass Lt extends BinOp implements Expr {\n  sqlOp(): string {\n    return '<';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    return lhs! < rhs!;\n  }\n}\n\nclass Ge extends BinOp implements Expr {\n  sqlOp(): string {\n    return '>=';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    return lhs! >= rhs!;\n  }\n}\n\nclass Gt extends BinOp implements Expr {\n  sqlOp(): string {\n    return '>';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    return lhs! > rhs!;\n  }\n}\n\nclass Eq extends BinOp implements Expr {\n  sqlOp(): string {\n    return '=';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    return lhs === rhs;\n  }\n}\n\nclass And extends BinOp implements Expr {\n  sqlOp(): string {\n    return 'AND';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return lhs && rhs;\n  }\n}\n\nclass Or extends BinOp implements Expr {\n  sqlOp(): string {\n    return 'OR';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return lhs || rhs;\n  }\n}\n\nclass Ne extends BinOp implements Expr {\n  sqlOp(): string {\n    return '!=';\n  }\n\n  evaluate(lhs: Primitive, rhs: Primitive): Primitive {\n    return lhs !== rhs;\n  }\n}\n\nclass Var implements Expr {\n  readonly name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  buildQueryFragment(binding: Map<string, string>): string {\n    // TODO(hjd): wrap in try catch?\n    return binding.get(this.name)!;\n  }\n\n  execute(event: UntypedEvent): Primitive {\n    return event[this.name]!;\n  }\n\n  freeVariables(): KeySet {\n    return {\n      [this.name]: Null,\n    };\n  }\n}\n\nclass Constant implements Expr {\n  readonly value: Primitive;\n\n  constructor(value: Primitive) {\n    this.value = value;\n  }\n\n  buildQueryFragment(_: Map<string, string>): string {\n    const value = this.value;\n    if (value === null) {\n      return 'NULL';\n    } else if (isString(value)) {\n      return `'${value}'`;\n    } else if (typeof value === 'boolean') {\n      return value ? 'TRUE' : 'FALSE';\n    } else {\n      return `${value}`;\n    }\n  }\n\n  execute(_: UntypedEvent): Primitive {\n    return this.value;\n  }\n\n  freeVariables(): EmptyKeySet {\n    return {};\n  }\n}\n\nexport function eq(left: Expr, right: Expr): Eq {\n  return new Eq(left, right);\n}\nexport function ne(left: Expr, right: Expr): Ne {\n  return new Ne(left, right);\n}\n\nexport function gt(left: Expr, right: Expr): Gt {\n  return new Gt(left, right);\n}\n\nexport function ge(left: Expr, right: Expr): Ge {\n  return new Ge(left, right);\n}\n\nexport function lt(left: Expr, right: Expr): Lt {\n  return new Lt(left, right);\n}\n\nexport function le(left: Expr, right: Expr): Le {\n  return new Le(left, right);\n}\n\nexport function and(left: Expr, right: Expr): And {\n  return new And(left, right);\n}\n\nexport function or(left: Expr, right: Expr): Or {\n  return new Or(left, right);\n}\n\nexport function c(value: Primitive): Constant {\n  return new Constant(value);\n}\n\nexport function v(name: string): Var {\n  return new Var(name);\n}\n\n// Type guards:\nexport function isEmptyEventSet<T extends KeySet>(\n  s: EventSet<T> | EmptyEventSet<T>,\n): s is EmptyEventSet<T> {\n  return !!(s as EmptyEventSet<T>).isEmptyEventSet;\n}\n\nexport function isConcreteEventSet<T extends KeySet>(\n  s: EventSet<T> | ConcreteEventSet<T>,\n): s is ConcreteEventSet<T> {\n  return !!(s as ConcreteEventSet<T>).isConcreteEventSet;\n}\n\nexport function isUnionEventSet<T extends KeySet>(\n  s: EventSet<T> | UnionEventSet<T>,\n): s is UnionEventSet<T> {\n  return (\n    (s as UnionEventSet<T>).isUnion &&\n    Array.isArray((s as UnionEventSet<T>).parents)\n  );\n}\n\nexport function isIntersectionEventSet<T extends KeySet>(\n  s: EventSet<T> | IntersectionEventSet<T>,\n): s is IntersectionEventSet<T> {\n  return (\n    (s as IntersectionEventSet<T>).isIntersection &&\n    Array.isArray((s as IntersectionEventSet<T>).parents)\n  );\n}\n\nexport function isFilterEventSet<T extends KeySet>(\n  s: EventSet<T> | FilterEventSet<T>,\n): s is FilterEventSet<T> {\n  return (\n    (s as FilterEventSet<T>).isFilter &&\n    Array.isArray((s as FilterEventSet<T>).filters)\n  );\n}\n\nexport function isSortEventSet<T extends KeySet>(\n  s: EventSet<T> | SortEventSet<T>,\n): s is SortEventSet<T> {\n  return (\n    (s as SortEventSet<T>).isSort && Array.isArray((s as SortEventSet<T>).sorts)\n  );\n}\n\n// STUPID_TYPE_MAGIC ==================================================\ntype ErrorBrand<T extends string> = {\n  [k in T]: void;\n};\n\n// A particular key/value pair on an Event matches the relevant entry\n// on the KeySet if the KeyType and the value type 'match':\n// Id => string\n// Str => string\n// Bool => boolean\n// Null => null\n// Num => number\ntype KeyToType = {\n  num: number;\n  str: string;\n  bool: boolean;\n  null: null;\n  bigint: bigint;\n  id: string;\n};\n\ntype ConformingValue<T> = T extends keyof KeyToType ? KeyToType[T] : void;\n\ntype Materialised<\n  Concrete extends KeySet,\n  Parent extends KeySet,\n> = Parent extends Concrete\n  ? ConcreteEventSet<Concrete>\n  : ErrorBrand<`Very bad!`>;\n\ntype MergedKeys<Left extends KeySet, Right extends KeySet> = Left & Right;\n\ntype Merged<Left extends KeySet, Right extends KeySet> = EventSet<\n  MergedKeys<Left, Right>\n>;\n\n// HELPERS ============================================================\nfunction applyLimitOffset<T>(arr: T[], limit?: number, offset?: number): T[] {\n  const actualOffset = offset === undefined ? 0 : offset;\n  const actualEnd = limit === undefined ? arr.length : actualOffset + limit;\n  const shouldSlice = actualOffset !== 0 || actualEnd !== arr.length;\n  return shouldSlice ? arr.slice(actualOffset, actualEnd) : arr;\n}\n\nfunction mergeKeys<P extends KeySet, Q extends KeySet>(\n  left: P,\n  right: Q,\n): MergedKeys<P, Q> {\n  return Object.assign({}, left, right);\n}\n\nfunction getKeyDefault(keyName: string, keyType: KeyType): Primitive {\n  switch (keyType) {\n    case Id:\n      throw new Error(\n        `Can't create default for key '${keyName}' with type '${keyType}'`,\n      );\n    case Num:\n      return 0;\n    case Null:\n      return null;\n    case Str:\n      return '';\n    case Bool:\n      return false;\n    case BigInt:\n      return 0n;\n    default:\n      const _exhaustiveCheck: never = keyType;\n      return _exhaustiveCheck;\n  }\n}\n\nfunction isEqualKeySet(a: UntypedKeySet, b: UntypedKeySet): boolean {\n  for (const k in a) {\n    if (a[k] !== b[k]) {\n      return false;\n    }\n  }\n  for (const k in b) {\n    if (b[k] !== a[k]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction freeVariablesFromFilters(\n  filters: Filter[],\n  initialKeySet?: KeySet,\n): KeySet {\n  let result = {};\n\n  if (initialKeySet !== undefined) {\n    result = mergeKeys(result, initialKeySet);\n  }\n\n  for (const filter of filters) {\n    result = mergeKeys(result, filter.freeVariables());\n  }\n\n  return result;\n}\n\nfunction freeVariablesFromSorts(sorts: Sort[], initialKeySet?: KeySet): KeySet {\n  let result = {};\n\n  if (initialKeySet !== undefined) {\n    result = mergeKeys(result, initialKeySet);\n  }\n\n  for (const sort of sorts) {\n    result = mergeKeys(result, sort.expression.freeVariables());\n  }\n\n  return result;\n}\n\nfunction primativeToRank(p: Primitive) {\n  if (p === null) {\n    return 0;\n  } else if (isString(p)) {\n    return 2;\n  } else {\n    return 1;\n  }\n}\n\n// TODO(hjd): test for bignums\n// Convert an expression into a sort style comparison function.\n// Exported for testing.\nexport function cmpFromExpr<T extends KeySet>(\n  expr: Expr,\n): (l: Event<T>, r: Event<T>) => number {\n  return (l: Event<T>, r: Event<T>) => {\n    const lhs = expr.execute(l);\n    const rhs = expr.execute(r);\n    const lhsRank = primativeToRank(lhs);\n    const rhsRank = primativeToRank(rhs);\n    if (lhsRank < rhsRank) {\n      return -1;\n    } else if (lhsRank > rhsRank) {\n      return 1;\n    } else {\n      // Double equals on purpose so 0 == false and 1 == true are true\n      if (lhs == rhs) {\n        return 0;\n      } else if (lhs! < rhs!) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n  };\n}\n\n// Convert a 'sort' into a sort() style comparison function.\n// Exported for testing.\nexport function cmpFromSort<T extends KeySet>(\n  sort: Sort,\n): (l: Event<T>, r: Event<T>) => number {\n  const cmp = cmpFromExpr<T>(sort.expression);\n  if (sort.direction === Direction.ASC) {\n    return cmp;\n  } else {\n    // cmp(r, l) is better than -cmp(l, r) since JS distinguishes\n    // between -0 and 0.\n    return (l: Event<T>, r: Event<T>) => cmp(r, l);\n  }\n}\n"]}