{"version":3,"file":"raf_scheduler.js","sourceRoot":"","sources":["../../../src/core/raf_scheduler.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;;AAEjC,6CAAuC;AACvC,8DAAwB;AACxB,mDAA6C;AAKhC,QAAA,eAAe,GAAG,4BAAY,CAAC,QAAQ,CAAC;IACnD,EAAE,EAAE,mBAAmB;IACvB,IAAI,EAAE,2BAA2B;IACjC,WAAW,EAAE,6CAA6C;IAC1D,YAAY,EAAE,IAAI;CACnB,CAAC,CAAC;AAEH,4EAA4E;AAC5E,uEAAuE;AACvE,4DAA4D;AAC5D,oEAAoE;AACpE,wEAAwE;AACxE,iDAAiD;AACjD,+EAA+E;AAC/E,wBAAwB;AACxB,MAAa,YAAY;IACvB,2EAA2E;IACnE,kBAAkB,GAAG,IAAI,GAAG,EAAqB,CAAC;IAE1D,2EAA2E;IACnE,qBAAqB,GAAG,IAAI,GAAG,EAAkB,CAAC;IAE1D,0DAA0D;IAClD,mBAAmB,GAAG,IAAI,KAAK,EAAkB,CAAC;IAClD,qBAAqB,GAAG,KAAK,CAAC;IAC9B,mBAAmB,GAAG,KAAK,CAAC;IAC5B,WAAW,GAAG,KAAK,CAAC;IACpB,SAAS,GAAG,KAAK,CAAC;IAClB,eAAe,GAAG,KAAK,CAAC;IACxB,MAAM,GAAG,IAAI,GAAG,EAA6B,CAAC;IAE7C,SAAS,GAAG;QACnB,UAAU,EAAE,IAAI,sBAAS,EAAE;QAC3B,SAAS,EAAE,IAAI,sBAAS,EAAE;QAC1B,MAAM,EAAE,IAAI,sBAAS,EAAE;QACvB,QAAQ,EAAE,IAAI,sBAAS,EAAE;QACzB,SAAS,EAAE,IAAI,sBAAS,EAAE;KAC3B,CAAC;IAEF;QACE,2CAA2C;QAC3C,MAAM,QAAQ,GAAG,iBAAC,CAAC,MAAM,CAAC,IAAI,CAAC;QAC/B,MAAM,QAAQ,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QACxD,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC;QACzB,iBAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAEpB,iBAAC,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAED,mDAAmD;IACnD,uEAAuE;IACvE,aAAa;IACb,kBAAkB,CAAC,KAAe,EAAE,EAAmB;QACrD,qEAAqE;QACrE,qBAAqB;QACrB,IAAI,uBAAe,CAAC,GAAG,EAAE,IAAI,KAAK,KAAK,OAAO;YAAE,OAAO;QACvD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAChC,EAAE,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACxC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;IACzC,CAAC;IAED,wCAAwC;IACxC,oBAAoB;QAClB,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;IACzC,CAAC;IAED,cAAc,CAAC,EAAqB;QAClC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAChC,IAAI,CAAC,2BAA2B,EAAE,CAAC;IACrC,CAAC;IAED,aAAa,CAAC,EAAqB;QACjC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC,CAAC;IAED,uBAAuB,CAAC,EAAkB;QACxC,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACnC,MAAM,qBAAqB,GAAG,IAAI,CAAC,qBAAqB,CAAC;QACzD,OAAO;YACL,CAAC,MAAM,CAAC,OAAO,CAAC;gBACd,qBAAqB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACnC,CAAC;SACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,OAAgB,EAAE,SAAkC;QACxD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;YACvB,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACzB,CAAC;aAAM,CAAC;YACN,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACjC,CAAC;QACD,IAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IACnD,CAAC;IAED,QAAQ;QACN,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED,mBAAmB,CAAC,OAAgB;QAClC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;QAC/B,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAC5B,CAAC;IAED,IAAI,iBAAiB;QACnB,OAAO,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,qBAAqB,CAAC;IACxD,CAAC;IAEO,aAAa;QACnB,MAAM,WAAW,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QAEtC,KAAK,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;YACzD,IAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACnD,CAAC;QAED,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,CAAC;QACrE,CAAC;IACH,CAAC;IAEO,uBAAuB,CAC7B,OAAgB,EAChB,SAAkC;QAElC,yEAAyE;QACzE,4EAA4E;QAC5E,wEAAwE;QACxE,4EAA4E;QAC5E,MAAM,aAAa,GAAG,iBAAC,CAAC,MAIf,CAAC;QAEV,aAAa,CACX,OAAO,EACP,SAAS,KAAK,IAAI,CAAC,CAAC,CAAC,IAAA,iBAAC,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EACxC,uBAAe,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,WAAG,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAC1E,CAAC;IACJ,CAAC;IAEO,gBAAgB;QACtB,MAAM,WAAW,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QACtC,IAAI,IAAI,CAAC,WAAW;YAAE,OAAO;QAC7B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;QACjD,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QACzB,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,CAAC;QACrE,CAAC;IACH,CAAC;IAEO,2BAA2B,CAAC,KAAK,GAAG,KAAK;QAC/C,IAAI,IAAI,CAAC,qBAAqB;YAAE,OAAO;QACvC,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,KAAK,CAAC,IAAI,KAAK,EAAE,CAAC;YAChD,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;YAClC,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACjE,CAAC;IACH,CAAC;IAEO,gBAAgB,CAAC,WAAmB;QAC1C,IAAI,IAAI,CAAC,SAAS;YAAE,OAAO;QAC3B,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;QACnC,MAAM,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC;QAC9C,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;QAEjC,MAAM,MAAM,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QACjC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC;QACzD,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QAChC,YAAY,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;QACrC,MAAM,IAAI,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,MAAM,OAAO,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QAElC,MAAM,QAAQ,GAAG,KAAK,GAAG,MAAM,CAAC;QAChC,MAAM,OAAO,GAAG,IAAI,GAAG,KAAK,CAAC;QAC7B,MAAM,UAAU,GAAG,OAAO,GAAG,IAAI,CAAC;QAClC,MAAM,SAAS,GAAG,OAAO,GAAG,MAAM,CAAC;QACnC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;QAC/D,IAAI,CAAC,2BAA2B,EAAE,CAAC;QAEnC,IAAI,YAAY,IAAI,IAAI,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxD,MAAM,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB;YACzE,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAEO,eAAe,CACrB,WAAmB,EACnB,OAAe,EACf,UAAkB,EAClB,YAAoB;QAEpB,IAAI,CAAC,IAAI,CAAC,eAAe;YAAE,OAAO;QAClC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACxC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC9C,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;IACjD,CAAC;CACF;AAxLD,oCAwLC;AAEY,QAAA,GAAG,GAAG,IAAI,YAAY,EAAE,CAAC","sourcesContent":["// Copyright (C) 2018 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {PerfStats} from './perf_stats';\nimport m from 'mithril';\nimport {featureFlags} from './feature_flags';\n\nexport type AnimationCallback = (lastFrameMs: number) => void;\nexport type RedrawCallback = () => void;\n\nexport const AUTOREDRAW_FLAG = featureFlags.register({\n  id: 'mithrilAutoredraw',\n  name: 'Enable Mithril autoredraw',\n  description: 'Turns calls to schedulefullRedraw() a no-op',\n  defaultValue: true,\n});\n\n// This class orchestrates all RAFs in the UI. It ensures that there is only\n// one animation frame handler overall and that callbacks are called in\n// predictable order. There are two types of callbacks here:\n// - actions (e.g. pan/zoon animations), which will alter the \"fast\"\n//  (main-thread-only) state (e.g. update visible time bounds @ 60 fps).\n// - redraw callbacks that will repaint canvases.\n// This class guarantees that, on each frame, redraw callbacks are called after\n// all action callbacks.\nexport class RafScheduler {\n  // These happen at the beginning of any animation frame. Used by Animation.\n  private animationCallbacks = new Set<AnimationCallback>();\n\n  // These happen during any animaton frame, after the (optional) DOM redraw.\n  private canvasRedrawCallbacks = new Set<RedrawCallback>();\n\n  // These happen at the end of full (DOM) animation frames.\n  private postRedrawCallbacks = new Array<RedrawCallback>();\n  private hasScheduledNextFrame = false;\n  private requestedFullRedraw = false;\n  private isRedrawing = false;\n  private _shutdown = false;\n  private recordPerfStats = false;\n  private mounts = new Map<Element, m.ComponentTypes>();\n\n  readonly perfStats = {\n    rafActions: new PerfStats(),\n    rafCanvas: new PerfStats(),\n    rafDom: new PerfStats(),\n    rafTotal: new PerfStats(),\n    domRedraw: new PerfStats(),\n  };\n\n  constructor() {\n    // Patch m.redraw() to our RAF full redraw.\n    const origSync = m.redraw.sync;\n    const redrawFn = () => this.scheduleFullRedraw('force');\n    redrawFn.sync = origSync;\n    m.redraw = redrawFn;\n\n    m.mount = this.mount.bind(this);\n  }\n\n  // Schedule re-rendering of virtual DOM and canvas.\n  // If a callback is passed it will be executed after the DOM redraw has\n  // completed.\n  scheduleFullRedraw(force?: 'force', cb?: RedrawCallback) {\n    // If we are using autoredraw mode, make this function a no-op unless\n    // 'force' is passed.\n    if (AUTOREDRAW_FLAG.get() && force !== 'force') return;\n    this.requestedFullRedraw = true;\n    cb && this.postRedrawCallbacks.push(cb);\n    this.maybeScheduleAnimationFrame(true);\n  }\n\n  // Schedule re-rendering of canvas only.\n  scheduleCanvasRedraw() {\n    this.maybeScheduleAnimationFrame(true);\n  }\n\n  startAnimation(cb: AnimationCallback) {\n    this.animationCallbacks.add(cb);\n    this.maybeScheduleAnimationFrame();\n  }\n\n  stopAnimation(cb: AnimationCallback) {\n    this.animationCallbacks.delete(cb);\n  }\n\n  addCanvasRedrawCallback(cb: RedrawCallback): Disposable {\n    this.canvasRedrawCallbacks.add(cb);\n    const canvasRedrawCallbacks = this.canvasRedrawCallbacks;\n    return {\n      [Symbol.dispose]() {\n        canvasRedrawCallbacks.delete(cb);\n      },\n    };\n  }\n\n  mount(element: Element, component: m.ComponentTypes | null): void {\n    const mounts = this.mounts;\n    if (component === null) {\n      mounts.delete(element);\n    } else {\n      mounts.set(element, component);\n    }\n    this.syncDomRedrawMountEntry(element, component);\n  }\n\n  shutdown() {\n    this._shutdown = true;\n  }\n\n  setPerfStatsEnabled(enabled: boolean) {\n    this.recordPerfStats = enabled;\n    this.scheduleFullRedraw();\n  }\n\n  get hasPendingRedraws(): boolean {\n    return this.isRedrawing || this.hasScheduledNextFrame;\n  }\n\n  private syncDomRedraw() {\n    const redrawStart = performance.now();\n\n    for (const [element, component] of this.mounts.entries()) {\n      this.syncDomRedrawMountEntry(element, component);\n    }\n\n    if (this.recordPerfStats) {\n      this.perfStats.domRedraw.addValue(performance.now() - redrawStart);\n    }\n  }\n\n  private syncDomRedrawMountEntry(\n    element: Element,\n    component: m.ComponentTypes | null,\n  ) {\n    // Mithril's render() function takes a third argument which tells us if a\n    // further redraw is needed (e.g. due to managed event handler). This allows\n    // us to implement auto-redraw. The redraw argument is documented in the\n    // official Mithril docs but is just not part of the @types/mithril package.\n    const mithrilRender = m.render as (\n      el: Element,\n      vnodes: m.Children,\n      redraw?: () => void,\n    ) => void;\n\n    mithrilRender(\n      element,\n      component !== null ? m(component) : null,\n      AUTOREDRAW_FLAG.get() ? () => raf.scheduleFullRedraw('force') : undefined,\n    );\n  }\n\n  private syncCanvasRedraw() {\n    const redrawStart = performance.now();\n    if (this.isRedrawing) return;\n    this.isRedrawing = true;\n    this.canvasRedrawCallbacks.forEach((cb) => cb());\n    this.isRedrawing = false;\n    if (this.recordPerfStats) {\n      this.perfStats.rafCanvas.addValue(performance.now() - redrawStart);\n    }\n  }\n\n  private maybeScheduleAnimationFrame(force = false) {\n    if (this.hasScheduledNextFrame) return;\n    if (this.animationCallbacks.size !== 0 || force) {\n      this.hasScheduledNextFrame = true;\n      window.requestAnimationFrame(this.onAnimationFrame.bind(this));\n    }\n  }\n\n  private onAnimationFrame(lastFrameMs: number) {\n    if (this._shutdown) return;\n    this.hasScheduledNextFrame = false;\n    const doFullRedraw = this.requestedFullRedraw;\n    this.requestedFullRedraw = false;\n\n    const tStart = performance.now();\n    this.animationCallbacks.forEach((cb) => cb(lastFrameMs));\n    const tAnim = performance.now();\n    doFullRedraw && this.syncDomRedraw();\n    const tDom = performance.now();\n    this.syncCanvasRedraw();\n    const tCanvas = performance.now();\n\n    const animTime = tAnim - tStart;\n    const domTime = tDom - tAnim;\n    const canvasTime = tCanvas - tDom;\n    const totalTime = tCanvas - tStart;\n    this.updatePerfStats(animTime, domTime, canvasTime, totalTime);\n    this.maybeScheduleAnimationFrame();\n\n    if (doFullRedraw && this.postRedrawCallbacks.length > 0) {\n      const pendingCbs = this.postRedrawCallbacks.splice(0); // splice = clear.\n      pendingCbs.forEach((cb) => cb());\n    }\n  }\n\n  private updatePerfStats(\n    actionsTime: number,\n    domTime: number,\n    canvasTime: number,\n    totalRafTime: number,\n  ) {\n    if (!this.recordPerfStats) return;\n    this.perfStats.rafActions.addValue(actionsTime);\n    this.perfStats.rafDom.addValue(domTime);\n    this.perfStats.rafCanvas.addValue(canvasTime);\n    this.perfStats.rafTotal.addValue(totalRafTime);\n  }\n}\n\nexport const raf = new RafScheduler();\n"]}