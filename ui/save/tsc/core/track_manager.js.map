{"version":3,"file":"track_manager.js","sourceRoot":"","sources":["../../../src/core/track_manager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Registry} from '../base/registry';\nimport {Track, TrackDescriptor, TrackManager} from '../public/track';\nimport {AsyncLimiter} from '../base/async_limiter';\nimport {TrackRenderContext} from '../public/track';\n\nexport interface TrackRenderer {\n  readonly track: Track;\n  desc: TrackDescriptor;\n  render(ctx: TrackRenderContext): void;\n  getError(): Error | undefined;\n}\n\n/**\n * TrackManager is responsible for managing the registry of tracks and their\n * lifecycle of tracks over render cycles.\n *\n * Example usage:\n * function render() {\n *   const trackCache = new TrackCache();\n *   const foo = trackCache.getTrackRenderer('foo', 'exampleURI', {});\n *   const bar = trackCache.getTrackRenderer('bar', 'exampleURI', {});\n *   trackCache.flushOldTracks(); // <-- Destroys any unused cached tracks\n * }\n *\n * Example of how flushing works:\n * First cycle\n *   getTrackRenderer('foo', ...) <-- new track 'foo' created\n *   getTrackRenderer('bar', ...) <-- new track 'bar' created\n *   flushTracks()\n * Second cycle\n *   getTrackRenderer('foo', ...) <-- returns cached 'foo' track\n *   flushTracks() <-- 'bar' is destroyed, as it was not resolved this cycle\n * Third cycle\n *   flushTracks() <-- 'foo' is destroyed.\n */\nexport class TrackManagerImpl implements TrackManager {\n  private tracks = new Registry<TrackFSM>((x) => x.desc.uri);\n\n  // This property is written by scroll_helper.ts and read&cleared by the\n  // track_panel.ts. This exist for the following use case: the user wants to\n  // scroll to track X, but X is not visible because it's in a collapsed group.\n  // So we want to stash this information in a place that track_panel.ts can\n  // access when creating dom elements.\n  //\n  // Note: this is the node id of the track node to scroll to, not the track\n  // uri, as this allows us to scroll to tracks that have no uri.\n  scrollToTrackNodeId?: string;\n\n  registerTrack(trackDesc: TrackDescriptor): Disposable {\n    return this.tracks.register(new TrackFSM(trackDesc));\n  }\n\n  findTrack(\n    predicate: (desc: TrackDescriptor) => boolean | undefined,\n  ): TrackDescriptor | undefined {\n    for (const t of this.tracks.values()) {\n      if (predicate(t.desc)) return t.desc;\n    }\n    return undefined;\n  }\n\n  getAllTracks(): TrackDescriptor[] {\n    return Array.from(this.tracks.valuesAsArray().map((t) => t.desc));\n  }\n\n  // Look up track into for a given track's URI.\n  // Returns |undefined| if no track can be found.\n  getTrack(uri: string): TrackDescriptor | undefined {\n    return this.tracks.tryGet(uri)?.desc;\n  }\n\n  // This is only called by the viewer_page.ts.\n  getTrackRenderer(uri: string): TrackRenderer | undefined {\n    // Search for a cached version of this track,\n    const trackFsm = this.tracks.tryGet(uri);\n    trackFsm?.markUsed();\n    return trackFsm;\n  }\n\n  // Destroys all tracks that didn't recently get a getTrackRenderer() call.\n  flushOldTracks() {\n    for (const trackFsm of this.tracks.values()) {\n      trackFsm.tick();\n    }\n  }\n}\n\nconst DESTROY_IF_NOT_SEEN_FOR_TICK_COUNT = 1;\n\n/**\n * Owns all runtime information about a track and manages its lifecycle,\n * ensuring lifecycle hooks are called synchronously and in the correct order.\n *\n * There are quite some subtle properties that this class guarantees:\n * - It make sure that lifecycle methods don't overlap with each other.\n * - It prevents a chain of onCreate > onDestroy > onCreate if the first\n *   onCreate() is still oustanding. This is by virtue of using AsyncLimiter\n *   which under the hoods holds only the most recent task and skips the\n *   intermediate ones.\n * - Ensures that a track never sees two consecutive onCreate, or onDestroy or\n *   an onDestroy without an onCreate.\n * - Ensures that onUpdate never overlaps or follows with onDestroy. This is\n *   particularly important because tracks often drop tables/views onDestroy\n *   and they shouldn't try to fetch more data onUpdate past that point.\n */\nclass TrackFSM implements TrackRenderer {\n  public readonly desc: TrackDescriptor;\n\n  private readonly limiter = new AsyncLimiter();\n  private error?: Error;\n  private tickSinceLastUsed = 0;\n  private created = false;\n\n  constructor(desc: TrackDescriptor) {\n    this.desc = desc;\n  }\n\n  markUsed(): void {\n    this.tickSinceLastUsed = 0;\n  }\n\n  // Increment the lastUsed counter, and maybe call onDestroy().\n  tick(): void {\n    if (this.tickSinceLastUsed++ === DESTROY_IF_NOT_SEEN_FOR_TICK_COUNT) {\n      // Schedule an onDestroy\n      this.limiter.schedule(async () => {\n        // Don't enter the track again once an error is has occurred\n        if (this.error !== undefined) {\n          return;\n        }\n\n        try {\n          if (this.created) {\n            await Promise.resolve(this.track.onDestroy?.());\n            this.created = false;\n          }\n        } catch (e) {\n          this.error = e;\n        }\n      });\n    }\n  }\n\n  render(ctx: TrackRenderContext): void {\n    this.limiter.schedule(async () => {\n      // Don't enter the track again once an error has occurred\n      if (this.error !== undefined) {\n        return;\n      }\n\n      try {\n        // Call onCreate() if this is our first call\n        if (!this.created) {\n          await this.track.onCreate?.(ctx);\n          this.created = true;\n        }\n        await Promise.resolve(this.track.onUpdate?.(ctx));\n      } catch (e) {\n        this.error = e;\n      }\n    });\n    this.track.render(ctx);\n  }\n\n  getError(): Error | undefined {\n    return this.error;\n  }\n\n  get track(): Track {\n    return this.desc.track;\n  }\n}\n"]}