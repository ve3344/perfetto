{"version":3,"file":"flow_manager.js","sourceRoot":"","sources":["../../../src/core/flow_manager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use size file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Time} from '../base/time';\nimport {featureFlags} from './feature_flags';\nimport {FlowDirection, Flow} from './flow_types';\nimport {asSliceSqlId} from '../components/sql_utils/core_types';\nimport {LONG, NUM, STR_NULL} from '../trace_processor/query_result';\nimport {\n  ACTUAL_FRAMES_SLICE_TRACK_KIND,\n  SLICE_TRACK_KIND,\n} from '../public/track_kinds';\nimport {TrackDescriptor, TrackManager} from '../public/track';\nimport {AreaSelection, Selection, SelectionManager} from '../public/selection';\nimport {raf} from './raf_scheduler';\nimport {Engine} from '../trace_processor/engine';\n\nconst SHOW_INDIRECT_PRECEDING_FLOWS_FLAG = featureFlags.register({\n  id: 'showIndirectPrecedingFlows',\n  name: 'Show indirect preceding flows',\n  description:\n    'Show indirect preceding flows (connected through ancestor ' +\n    'slices) when a slice is selected.',\n  defaultValue: false,\n});\n\nexport class FlowManager {\n  private _connectedFlows: Flow[] = [];\n  private _selectedFlows: Flow[] = [];\n  private _curSelection?: Selection;\n  private _focusedFlowIdLeft = -1;\n  private _focusedFlowIdRight = -1;\n  private _visibleCategories = new Map<string, boolean>();\n  private _initialized = false;\n\n  constructor(\n    private engine: Engine,\n    private trackMgr: TrackManager,\n    private selectionMgr: SelectionManager,\n  ) {}\n\n  // TODO(primiano): the only reason why this is not done in the constructor is\n  // because when loading the UI with no trace, we initialize globals with a\n  // FakeTraceImpl with a FakeEngine, which crashes when issuing queries.\n  // This can be moved in the ctor once globals go away.\n  private initialize() {\n    if (this._initialized) return;\n    this._initialized = true;\n    // Create |CHROME_CUSTOME_SLICE_NAME| helper, which combines slice name\n    // and args for some slices (scheduler tasks and mojo messages) for more\n    // helpful messages.\n    // In the future, it should be replaced with this a more scalable and\n    // customisable solution.\n    // Note that a function here is significantly faster than a join.\n    this.engine.query(`\n      SELECT CREATE_FUNCTION(\n        'CHROME_CUSTOM_SLICE_NAME(slice_id LONG)',\n        'STRING',\n        'select case\n           when name=\"Receive mojo message\" then\n            printf(\"Receive mojo message (interface=%s, hash=%s)\",\n              EXTRACT_ARG(arg_set_id,\n                          \"chrome_mojo_event_info.mojo_interface_tag\"),\n              EXTRACT_ARG(arg_set_id, \"chrome_mojo_event_info.ipc_hash\"))\n           when name=\"ThreadControllerImpl::RunTask\" or\n                name=\"ThreadPool_RunTask\" then\n            printf(\"RunTask(posted_from=%s:%s)\",\n             EXTRACT_ARG(arg_set_id, \"task.posted_from.file_name\"),\n             EXTRACT_ARG(arg_set_id, \"task.posted_from.function_name\"))\n         end\n         from slice where id=$slice_id'\n    );`);\n  }\n\n  async queryFlowEvents(query: string): Promise<Flow[]> {\n    const result = await this.engine.query(query);\n    const flows: Flow[] = [];\n\n    const it = result.iter({\n      beginSliceId: NUM,\n      beginTrackId: NUM,\n      beginSliceName: STR_NULL,\n      beginSliceChromeCustomName: STR_NULL,\n      beginSliceCategory: STR_NULL,\n      beginSliceStartTs: LONG,\n      beginSliceEndTs: LONG,\n      beginDepth: NUM,\n      beginThreadName: STR_NULL,\n      beginProcessName: STR_NULL,\n      endSliceId: NUM,\n      endTrackId: NUM,\n      endSliceName: STR_NULL,\n      endSliceChromeCustomName: STR_NULL,\n      endSliceCategory: STR_NULL,\n      endSliceStartTs: LONG,\n      endSliceEndTs: LONG,\n      endDepth: NUM,\n      endThreadName: STR_NULL,\n      endProcessName: STR_NULL,\n      name: STR_NULL,\n      category: STR_NULL,\n      id: NUM,\n      flowToDescendant: NUM,\n    });\n\n    const nullToStr = (s: null | string): string => {\n      return s === null ? 'NULL' : s;\n    };\n\n    const nullToUndefined = (s: null | string): undefined | string => {\n      return s === null ? undefined : s;\n    };\n\n    const nodes = [];\n\n    for (; it.valid(); it.next()) {\n      // Category and name present only in version 1 flow events\n      // It is most likelly NULL for all other versions\n      const category = nullToUndefined(it.category);\n      const name = nullToUndefined(it.name);\n      const id = it.id;\n\n      const begin = {\n        trackId: it.beginTrackId,\n        sliceId: asSliceSqlId(it.beginSliceId),\n        sliceName: nullToStr(it.beginSliceName),\n        sliceChromeCustomName: nullToUndefined(it.beginSliceChromeCustomName),\n        sliceCategory: nullToStr(it.beginSliceCategory),\n        sliceStartTs: Time.fromRaw(it.beginSliceStartTs),\n        sliceEndTs: Time.fromRaw(it.beginSliceEndTs),\n        depth: it.beginDepth,\n        threadName: nullToStr(it.beginThreadName),\n        processName: nullToStr(it.beginProcessName),\n      };\n\n      const end = {\n        trackId: it.endTrackId,\n        sliceId: asSliceSqlId(it.endSliceId),\n        sliceName: nullToStr(it.endSliceName),\n        sliceChromeCustomName: nullToUndefined(it.endSliceChromeCustomName),\n        sliceCategory: nullToStr(it.endSliceCategory),\n        sliceStartTs: Time.fromRaw(it.endSliceStartTs),\n        sliceEndTs: Time.fromRaw(it.endSliceEndTs),\n        depth: it.endDepth,\n        threadName: nullToStr(it.endThreadName),\n        processName: nullToStr(it.endProcessName),\n      };\n\n      nodes.push(begin);\n      nodes.push(end);\n\n      flows.push({\n        id,\n        begin,\n        end,\n        dur: it.endSliceStartTs - it.beginSliceEndTs,\n        category,\n        name,\n        flowToDescendant: !!it.flowToDescendant,\n      });\n    }\n\n    // Everything below here is a horrible hack to support flows for\n    // async slice tracks.\n    // In short the issue is this:\n    // - For most slice tracks there is a one-to-one mapping between\n    //   the track in the UI and the track in the TP. n.b. Even in this\n    //   case the UI 'trackId' and the TP 'track.id' may not be the\n    //   same. In this case 'depth' in the TP is the exact depth in the\n    //   UI.\n    // - In the case of aysnc tracks however the mapping is\n    //   one-to-many. Each async slice track in the UI is 'backed' but\n    //   multiple TP tracks. In order to render this track we need\n    //   to adjust depth to avoid overlapping slices. In the render\n    //   path we use experimental_slice_layout for this purpose. This\n    //   is a virtual table in the TP which, for an arbitrary collection\n    //   of TP trackIds, computes for each slice a 'layout_depth'.\n    // - Everything above in this function and its callers doesn't\n    //   know anything about layout_depth.\n    //\n    // So if we stopped here we would have incorrect rendering for\n    // async slice tracks. Instead we want to 'fix' depth for these\n    // cases. We do this in two passes.\n    // - First we collect all the information we need in 'Info' POJOs\n    // - Secondly we loop over those Infos querying\n    //   the database to find the layout_depth for each sliceId\n    // TODO(hjd): This should not be needed after TracksV2 lands.\n\n    // We end up with one Info POJOs for each UI async slice track\n    // which has at least  one flow {begin,end}ing in one of its slices.\n    interface Info {\n      siblingTrackIds: number[];\n      sliceIds: number[];\n      nodes: Array<{\n        sliceId: number;\n        depth: number;\n      }>;\n    }\n\n    const trackUriToInfo = new Map<string, null | Info>();\n    const trackIdToInfo = new Map<number, null | Info>();\n\n    const trackIdToTrack = new Map<number, TrackDescriptor>();\n    this.trackMgr\n      .getAllTracks()\n      .forEach((trackDescriptor) =>\n        trackDescriptor.tags?.trackIds?.forEach((trackId) =>\n          trackIdToTrack.set(trackId, trackDescriptor),\n        ),\n      );\n\n    const getInfo = (trackId: number): null | Info => {\n      let info = trackIdToInfo.get(trackId);\n      if (info !== undefined) {\n        return info;\n      }\n\n      const trackDescriptor = trackIdToTrack.get(trackId);\n      if (trackDescriptor === undefined) {\n        trackIdToInfo.set(trackId, null);\n        return null;\n      }\n\n      info = trackUriToInfo.get(trackDescriptor.uri);\n      if (info !== undefined) {\n        return info;\n      }\n\n      // If 'trackIds' is undefined this is not an async slice track so\n      // we don't need to do anything. We also don't need to do\n      // anything if there is only one TP track in this async track. In\n      // that case experimental_slice_layout is just an expensive way\n      // to find out depth === layout_depth.\n      const trackIds = trackDescriptor?.tags?.trackIds;\n      if (trackIds === undefined || trackIds.length <= 1) {\n        trackUriToInfo.set(trackDescriptor.uri, null);\n        trackIdToInfo.set(trackId, null);\n        return null;\n      }\n\n      const newInfo = {\n        siblingTrackIds: [...trackIds],\n        sliceIds: [],\n        nodes: [],\n      };\n\n      trackUriToInfo.set(trackDescriptor.uri, newInfo);\n      trackIdToInfo.set(trackId, newInfo);\n\n      return newInfo;\n    };\n\n    // First pass, collect:\n    // - all slices that belong to async slice track\n    // - grouped by the async slice track in question\n    for (const node of nodes) {\n      const info = getInfo(node.trackId);\n      if (info !== null) {\n        info.sliceIds.push(node.sliceId);\n        info.nodes.push(node);\n      }\n    }\n\n    // Second pass, for each async track:\n    // - Query to find the layout_depth for each relevant sliceId\n    // - Iterate through the nodes updating the depth in place\n    for (const info of trackUriToInfo.values()) {\n      if (info === null) {\n        continue;\n      }\n      const r = await this.engine.query(`\n        SELECT\n          id,\n          layout_depth as depth\n        FROM\n          experimental_slice_layout\n        WHERE\n          filter_track_ids = '${info.siblingTrackIds.join(',')}'\n          AND id in (${info.sliceIds.join(', ')})\n      `);\n\n      // Create the sliceId -> new depth map:\n      const it = r.iter({\n        id: NUM,\n        depth: NUM,\n      });\n      const sliceIdToDepth = new Map<number, number>();\n      for (; it.valid(); it.next()) {\n        sliceIdToDepth.set(it.id, it.depth);\n      }\n\n      // For each begin/end from an async track update the depth:\n      for (const node of info.nodes) {\n        const newDepth = sliceIdToDepth.get(node.sliceId);\n        if (newDepth !== undefined) {\n          node.depth = newDepth;\n        }\n      }\n    }\n\n    // Fill in the track uris if available\n    flows.forEach((flow) => {\n      flow.begin.trackUri = trackIdToTrack.get(flow.begin.trackId)?.uri;\n      flow.end.trackUri = trackIdToTrack.get(flow.end.trackId)?.uri;\n    });\n\n    return flows;\n  }\n\n  sliceSelected(sliceId: number) {\n    const connectedFlows = SHOW_INDIRECT_PRECEDING_FLOWS_FLAG.get()\n      ? `(\n           select * from directly_connected_flow(${sliceId})\n           union\n           select * from preceding_flow(${sliceId})\n         )`\n      : `directly_connected_flow(${sliceId})`;\n\n    const query = `\n    -- Include slices.flow to initialise indexes on 'flow.slice_in' and 'flow.slice_out'.\n    INCLUDE PERFETTO MODULE slices.flow;\n\n    select\n      f.slice_out as beginSliceId,\n      t1.track_id as beginTrackId,\n      t1.name as beginSliceName,\n      CHROME_CUSTOM_SLICE_NAME(t1.slice_id) as beginSliceChromeCustomName,\n      t1.category as beginSliceCategory,\n      t1.ts as beginSliceStartTs,\n      (t1.ts+t1.dur) as beginSliceEndTs,\n      t1.depth as beginDepth,\n      (thread_out.name || ' ' || thread_out.tid) as beginThreadName,\n      (process_out.name || ' ' || process_out.pid) as beginProcessName,\n      f.slice_in as endSliceId,\n      t2.track_id as endTrackId,\n      t2.name as endSliceName,\n      CHROME_CUSTOM_SLICE_NAME(t2.slice_id) as endSliceChromeCustomName,\n      t2.category as endSliceCategory,\n      t2.ts as endSliceStartTs,\n      (t2.ts+t2.dur) as endSliceEndTs,\n      t2.depth as endDepth,\n      (thread_in.name || ' ' || thread_in.tid) as endThreadName,\n      (process_in.name || ' ' || process_in.pid) as endProcessName,\n      extract_arg(f.arg_set_id, 'cat') as category,\n      extract_arg(f.arg_set_id, 'name') as name,\n      f.id as id,\n      slice_is_ancestor(t1.slice_id, t2.slice_id) as flowToDescendant\n    from ${connectedFlows} f\n    join slice t1 on f.slice_out = t1.slice_id\n    join slice t2 on f.slice_in = t2.slice_id\n    left join thread_track track_out on track_out.id = t1.track_id\n    left join thread thread_out on thread_out.utid = track_out.utid\n    left join thread_track track_in on track_in.id = t2.track_id\n    left join thread thread_in on thread_in.utid = track_in.utid\n    left join process process_out on process_out.upid = thread_out.upid\n    left join process process_in on process_in.upid = thread_in.upid\n    `;\n    this.queryFlowEvents(query).then((flows) => this.setConnectedFlows(flows));\n  }\n\n  private areaSelected(area: AreaSelection) {\n    const trackIds: number[] = [];\n\n    for (const trackInfo of area.tracks) {\n      const kind = trackInfo?.tags?.kind;\n      if (\n        kind === SLICE_TRACK_KIND ||\n        kind === ACTUAL_FRAMES_SLICE_TRACK_KIND\n      ) {\n        if (trackInfo?.tags?.trackIds) {\n          for (const trackId of trackInfo.tags.trackIds) {\n            trackIds.push(trackId);\n          }\n        }\n      }\n    }\n\n    const tracks = `(${trackIds.join(',')})`;\n\n    const startNs = area.start;\n    const endNs = area.end;\n\n    const query = `\n    select\n      f.slice_out as beginSliceId,\n      t1.track_id as beginTrackId,\n      t1.name as beginSliceName,\n      CHROME_CUSTOM_SLICE_NAME(t1.slice_id) as beginSliceChromeCustomName,\n      t1.category as beginSliceCategory,\n      t1.ts as beginSliceStartTs,\n      (t1.ts+t1.dur) as beginSliceEndTs,\n      t1.depth as beginDepth,\n      NULL as beginThreadName,\n      NULL as beginProcessName,\n      f.slice_in as endSliceId,\n      t2.track_id as endTrackId,\n      t2.name as endSliceName,\n      CHROME_CUSTOM_SLICE_NAME(t2.slice_id) as endSliceChromeCustomName,\n      t2.category as endSliceCategory,\n      t2.ts as endSliceStartTs,\n      (t2.ts+t2.dur) as endSliceEndTs,\n      t2.depth as endDepth,\n      NULL as endThreadName,\n      NULL as endProcessName,\n      extract_arg(f.arg_set_id, 'cat') as category,\n      extract_arg(f.arg_set_id, 'name') as name,\n      f.id as id,\n      slice_is_ancestor(t1.slice_id, t2.slice_id) as flowToDescendant\n    from flow f\n    join slice t1 on f.slice_out = t1.slice_id\n    join slice t2 on f.slice_in = t2.slice_id\n    where\n      (t1.track_id in ${tracks}\n        and (t1.ts+t1.dur <= ${endNs} and t1.ts+t1.dur >= ${startNs}))\n      or\n      (t2.track_id in ${tracks}\n        and (t2.ts <= ${endNs} and t2.ts >= ${startNs}))\n    `;\n    this.queryFlowEvents(query).then((flows) => this.setSelectedFlows(flows));\n  }\n\n  private setConnectedFlows(connectedFlows: Flow[]) {\n    this._connectedFlows = connectedFlows;\n    // If a chrome slice is selected and we have any flows in connectedFlows\n    // we will find the flows on the right and left of that slice to set a default\n    // focus. In all other cases the focusedFlowId(Left|Right) will be set to -1.\n    this._focusedFlowIdLeft = -1;\n    this._focusedFlowIdRight = -1;\n    if (this._curSelection?.kind === 'track_event') {\n      const sliceId = this._curSelection.eventId;\n      for (const flow of connectedFlows) {\n        if (flow.begin.sliceId === sliceId) {\n          this._focusedFlowIdRight = flow.id;\n        }\n        if (flow.end.sliceId === sliceId) {\n          this._focusedFlowIdLeft = flow.id;\n        }\n      }\n    }\n    raf.scheduleFullRedraw();\n  }\n\n  private setSelectedFlows(selectedFlows: Flow[]) {\n    this._selectedFlows = selectedFlows;\n    raf.scheduleFullRedraw();\n  }\n\n  updateFlows(selection: Selection) {\n    this.initialize();\n    this._curSelection = selection;\n\n    if (selection.kind === 'empty') {\n      this.setConnectedFlows([]);\n      this.setSelectedFlows([]);\n      return;\n    }\n\n    // TODO(b/155483804): This is a hack as annotation slices don't contain\n    // flows. We should tidy this up when fixing this bug.\n    if (selection.kind === 'track_event' && selection.tableName === 'slice') {\n      this.sliceSelected(selection.eventId);\n    } else {\n      this.setConnectedFlows([]);\n    }\n\n    if (selection.kind === 'area') {\n      this.areaSelected(selection);\n    } else {\n      this.setConnectedFlows([]);\n    }\n  }\n\n  // Change focus to the next flow event (matching the direction)\n  focusOtherFlow(direction: FlowDirection) {\n    const currentSelection = this._curSelection;\n    if (!currentSelection || currentSelection.kind !== 'track_event') {\n      return;\n    }\n    const sliceId = currentSelection.eventId;\n    if (sliceId === -1) {\n      return;\n    }\n\n    const boundFlows = this._connectedFlows.filter(\n      (flow) =>\n        (flow.begin.sliceId === sliceId && direction === 'Forward') ||\n        (flow.end.sliceId === sliceId && direction === 'Backward'),\n    );\n\n    if (direction === 'Backward') {\n      const nextFlowId = findAnotherFlowExcept(\n        boundFlows,\n        this._focusedFlowIdLeft,\n      );\n      this._focusedFlowIdLeft = nextFlowId;\n    } else {\n      const nextFlowId = findAnotherFlowExcept(\n        boundFlows,\n        this._focusedFlowIdRight,\n      );\n      this._focusedFlowIdRight = nextFlowId;\n    }\n    raf.scheduleFullRedraw();\n  }\n\n  // Select the slice connected to the flow in focus\n  moveByFocusedFlow(direction: FlowDirection): void {\n    const currentSelection = this._curSelection;\n    if (!currentSelection || currentSelection.kind !== 'track_event') {\n      return;\n    }\n\n    const sliceId = currentSelection.eventId;\n    const flowId =\n      direction === 'Backward'\n        ? this._focusedFlowIdLeft\n        : this._focusedFlowIdRight;\n\n    if (sliceId === -1 || flowId === -1) {\n      return;\n    }\n\n    // Find flow that is in focus and select corresponding slice\n    for (const flow of this._connectedFlows) {\n      if (flow.id === flowId) {\n        const flowPoint = direction === 'Backward' ? flow.begin : flow.end;\n        this.selectionMgr.selectSqlEvent('slice', flowPoint.sliceId, {\n          scrollToSelection: true,\n        });\n      }\n    }\n  }\n\n  get connectedFlows() {\n    return this._connectedFlows;\n  }\n\n  get selectedFlows() {\n    return this._selectedFlows;\n  }\n\n  get focusedFlowIdLeft() {\n    return this._focusedFlowIdLeft;\n  }\n  get focusedFlowIdRight() {\n    return this._focusedFlowIdRight;\n  }\n\n  get visibleCategories(): ReadonlyMap<string, boolean> {\n    return this._visibleCategories;\n  }\n\n  setCategoryVisible(name: string, value: boolean) {\n    this._visibleCategories.set(name, value);\n    raf.scheduleFullRedraw();\n  }\n}\n\n// Search |boundFlows| for |flowId| and return the id following it.\n// Returns the first flow id if nothing was found or |flowId| was the last flow\n// in |boundFlows|, and -1 if |boundFlows| is empty\nfunction findAnotherFlowExcept(boundFlows: Flow[], flowId: number): number {\n  let selectedFlowFound = false;\n\n  if (boundFlows.length === 0) {\n    return -1;\n  }\n\n  for (const flow of boundFlows) {\n    if (selectedFlowFound) {\n      return flow.id;\n    }\n\n    if (flow.id === flowId) {\n      selectedFlowFound = true;\n    }\n  }\n  return boundFlows[0].id;\n}\n"]}