{"version":3,"file":"page_manager.js","sourceRoot":"","sources":["../../../src/core/page_manager.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;;AAEjC,8DAAwB;AACxB,6CAAyD;AACzD,+CAA0C;AAE1C,qCAAgC;AAchC,MAAa,eAAe;IACT,QAAQ,GAAG,IAAI,mBAAQ,CAAsB,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAE9E,YAAY,CAAC,WAAgC;QAC3C,IAAA,oBAAU,EAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;QACvD,2EAA2E;QAC3E,wEAAwE;QACxE,IAAA,sBAAY,EAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACnC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;IAC7C,CAAC;IAED,0DAA0D;IAC1D,yBAAyB,CACvB,KAA4B;QAE5B,MAAM,KAAK,GAAG,eAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAClD,MAAM,GAAG,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;QACtE,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;YACtB,OAAO,GAAG,CAAC;QACb,CAAC;QACD,yEAAyE;QACzE,gDAAgD;QAChD,OAAO,IAAA,sBAAY,EAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;IAC/D,CAAC;IAED,yEAAyE;IACzE,mEAAmE;IAC3D,kBAAkB,CACxB,SAAgC,EAChC,IAAY,EACZ,OAAe;QAEf,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;YAC1B,OAAO,SAAS,CAAC;QACnB,CAAC;QACD,MAAM,QAAQ,GAAG,IAAA,sBAAY,EAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QACjD,MAAM,KAAK,GAAG,SAAS,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;QACjD,MAAM,aAAa,GAAG,CAAC,OAAO,EAAE,SAAS,CAAC;QAC1C,IAAI,aAAa,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACzC,OAAO,SAAS,CAAC;QACnB,CAAC;QACD,IAAI,aAAa,EAAE,CAAC;YAClB,OAAO,IAAA,iBAAC,EAAC,OAAO,CAAC,IAAgD,EAAE;gBACjE,OAAO;gBACP,KAAK,EAAE,IAAA,sBAAY,EAAC,KAAK,CAAC;aAC3B,CAAC,CAAC;QACL,CAAC;QACD,OAAO,IAAA,iBAAC,EAAC,OAAO,CAAC,IAAI,EAAE,EAAC,OAAO,EAAE,KAAK,EAAC,CAAC,CAAC;IAC3C,CAAC;CACF;AAlDD,0CAkDC","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\nimport {assertExists, assertTrue} from '../base/logging';\nimport {Registry} from '../base/registry';\nimport {PageAttrs, PageHandler, PageWithTraceAttrs} from '../public/page';\nimport {Router} from './router';\nimport {TraceImpl} from './trace_impl';\n\nexport interface PageWithTraceImplAttrs extends PageAttrs {\n  trace: TraceImpl;\n}\n\n// This is to allow internal core classes to get a TraceImpl injected rather\n// than just a Trace.\ntype PageHandlerInternal = PageHandler<\n  | m.ComponentTypes<PageWithTraceAttrs>\n  | m.ComponentTypes<PageWithTraceImplAttrs>\n>;\n\nexport class PageManagerImpl {\n  private readonly registry = new Registry<PageHandlerInternal>((x) => x.route);\n\n  registerPage(pageHandler: PageHandlerInternal): Disposable {\n    assertTrue(/^\\/\\w*$/.exec(pageHandler.route) !== null);\n    // The pluginId is injected by the proxy in AppImpl / TraceImpl. If this is\n    // undefined somebody (tests) managed to call this method without proxy.\n    assertExists(pageHandler.pluginId);\n    return this.registry.register(pageHandler);\n  }\n\n  // Called by index.ts upon the main frame redraw callback.\n  renderPageForCurrentRoute(\n    trace: TraceImpl | undefined,\n  ): m.Vnode<PageAttrs> | m.Vnode<PageWithTraceImplAttrs> {\n    const route = Router.parseFragment(location.hash);\n    const res = this.renderPageForRoute(trace, route.page, route.subpage);\n    if (res !== undefined) {\n      return res;\n    }\n    // If either the route doesn't exist or requires a trace but the trace is\n    // not loaded, fall back on the default route /.\n    return assertExists(this.renderPageForRoute(trace, '/', ''));\n  }\n\n  // Will return undefined if either: (1) the route does not exist; (2) the\n  // route exists, it requires a trace, but there is no trace loaded.\n  private renderPageForRoute(\n    coreTrace: TraceImpl | undefined,\n    page: string,\n    subpage: string,\n  ) {\n    const handler = this.registry.tryGet(page);\n    if (handler === undefined) {\n      return undefined;\n    }\n    const pluginId = assertExists(handler?.pluginId);\n    const trace = coreTrace?.forkForPlugin(pluginId);\n    const traceRequired = !handler?.traceless;\n    if (traceRequired && trace === undefined) {\n      return undefined;\n    }\n    if (traceRequired) {\n      return m(handler.page as m.ComponentTypes<PageWithTraceImplAttrs>, {\n        subpage,\n        trace: assertExists(trace),\n      });\n    }\n    return m(handler.page, {subpage, trace});\n  }\n}\n"]}