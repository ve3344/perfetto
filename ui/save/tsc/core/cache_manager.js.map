{"version":3,"file":"cache_manager.js","sourceRoot":"","sources":["../../../src/core/cache_manager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * This file deals with caching traces in the browser's Cache storage. The\n * traces are cached so that the UI can gracefully reload a trace when the tab\n * containing it is discarded by Chrome (e.g. because the tab was not used for\n * a long time) or when the user accidentally hits reload.\n */\nimport {TraceArrayBufferSource, TraceSource} from './trace_source';\n\nconst TRACE_CACHE_NAME = 'cached_traces';\nconst TRACE_CACHE_SIZE = 10;\n\nlet LAZY_CACHE: Cache | undefined = undefined;\n\nasync function getCache(): Promise<Cache | undefined> {\n  if (self.caches === undefined) {\n    // The browser doesn't support cache storage or the page is opened from\n    // a non-secure origin.\n    return undefined;\n  }\n  if (LAZY_CACHE !== undefined) {\n    return LAZY_CACHE;\n  }\n  LAZY_CACHE = await caches.open(TRACE_CACHE_NAME);\n  return LAZY_CACHE;\n}\n\nasync function cacheDelete(key: Request): Promise<boolean> {\n  try {\n    const cache = await getCache();\n    if (cache === undefined) return false; // Cache storage not supported.\n    return await cache.delete(key);\n  } catch (_) {\n    // TODO(288483453): Reinstate:\n    // return ignoreCacheUnactionableErrors(e, false);\n    return false;\n  }\n}\n\nasync function cachePut(key: string, value: Response): Promise<void> {\n  try {\n    const cache = await getCache();\n    if (cache === undefined) return; // Cache storage not supported.\n    await cache.put(key, value);\n  } catch (_) {\n    // TODO(288483453): Reinstate:\n    // ignoreCacheUnactionableErrors(e, undefined);\n  }\n}\n\nasync function cacheMatch(\n  key: Request | string,\n): Promise<Response | undefined> {\n  try {\n    const cache = await getCache();\n    if (cache === undefined) return undefined; // Cache storage not supported.\n    return await cache.match(key);\n  } catch (_) {\n    // TODO(288483453): Reinstate:\n    // ignoreCacheUnactionableErrors(e, undefined);\n    return undefined;\n  }\n}\n\nasync function cacheKeys(): Promise<readonly Request[]> {\n  try {\n    const cache = await getCache();\n    if (cache === undefined) return []; // Cache storage not supported.\n    return await cache.keys();\n  } catch (e) {\n    // TODO(288483453): Reinstate:\n    // return ignoreCacheUnactionableErrors(e, []);\n    return [];\n  }\n}\n\nexport async function cacheTrace(\n  traceSource: TraceSource,\n  traceUuid: string,\n): Promise<boolean> {\n  let trace;\n  let title = '';\n  let fileName = '';\n  let url = '';\n  let contentLength = 0;\n  let localOnly = false;\n  switch (traceSource.type) {\n    case 'ARRAY_BUFFER':\n      trace = traceSource.buffer;\n      title = traceSource.title;\n      fileName = traceSource.fileName ?? '';\n      url = traceSource.url ?? '';\n      contentLength = traceSource.buffer.byteLength;\n      localOnly = traceSource.localOnly || false;\n      break;\n    case 'FILE':\n      trace = await traceSource.file.arrayBuffer();\n      title = traceSource.file.name;\n      contentLength = traceSource.file.size;\n      break;\n    default:\n      return false;\n  }\n\n  const headers = new Headers([\n    ['x-trace-title', encodeURI(title)],\n    ['x-trace-url', url],\n    ['x-trace-filename', fileName],\n    ['x-trace-local-only', `${localOnly}`],\n    ['content-type', 'application/octet-stream'],\n    ['content-length', `${contentLength}`],\n    [\n      'expires',\n      // Expires in a week from now (now = upload time)\n      new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 7).toUTCString(),\n    ],\n  ]);\n  await deleteStaleEntries();\n  await cachePut(\n    `/_${TRACE_CACHE_NAME}/${traceUuid}`,\n    new Response(trace, {headers}),\n  );\n  return true;\n}\n\nexport async function tryGetTrace(\n  traceUuid: string,\n): Promise<TraceArrayBufferSource | undefined> {\n  await deleteStaleEntries();\n  const response = await cacheMatch(`/_${TRACE_CACHE_NAME}/${traceUuid}`);\n\n  if (!response) return undefined;\n  return {\n    type: 'ARRAY_BUFFER',\n    buffer: await response.arrayBuffer(),\n    title: decodeURI(response.headers.get('x-trace-title') ?? ''),\n    fileName: response.headers.get('x-trace-filename') ?? undefined,\n    url: response.headers.get('x-trace-url') ?? undefined,\n    uuid: traceUuid,\n    localOnly: response.headers.get('x-trace-local-only') === 'true',\n  };\n}\n\nasync function deleteStaleEntries() {\n  // Loop through stored traces and invalidate all but the most recent\n  // TRACE_CACHE_SIZE.\n  const keys = await cacheKeys();\n  const storedTraces: Array<{key: Request; date: Date}> = [];\n  const now = new Date();\n  const deletions = [];\n  for (const key of keys) {\n    const existingTrace = await cacheMatch(key);\n    if (existingTrace === undefined) {\n      continue;\n    }\n    const expires = existingTrace.headers.get('expires');\n    if (expires === undefined || expires === null) {\n      // Missing `expires`, so give up and delete which is better than\n      // keeping it around forever.\n      deletions.push(cacheDelete(key));\n      continue;\n    }\n    const expiryDate = new Date(expires);\n    if (expiryDate < now) {\n      deletions.push(cacheDelete(key));\n    } else {\n      storedTraces.push({key, date: expiryDate});\n    }\n  }\n\n  // Sort the traces descending by time, such that most recent ones are placed\n  // at the beginning. Then, take traces from TRACE_CACHE_SIZE onwards and\n  // delete them from cache.\n  const oldTraces = storedTraces\n    .sort((a, b) => b.date.getTime() - a.date.getTime())\n    .slice(TRACE_CACHE_SIZE);\n  for (const oldTrace of oldTraces) {\n    deletions.push(cacheDelete(oldTrace.key));\n  }\n\n  // TODO(hjd): Wrong Promise.all here, should use the one that\n  // ignores failures but need to upgrade TypeScript for that.\n  await Promise.all(deletions);\n}\n"]}