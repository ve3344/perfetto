{"version":3,"file":"service_worker.js","sourceRoot":"","sources":["../../../src/service_worker/service_worker.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2020 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This script handles the caching of the UI resources, allowing it to work\n// offline (as long as the UI site has been visited at least once).\n// Design doc: http://go/perfetto-offline.\n\n// When a new version of the UI is released (e.g. v1 -> v2), the following\n// happens on the next visit:\n// 1. The v1 (old) service worker is activated. At this point we don't know yet\n//    that v2 is released.\n// 2. /index.html is requested. The SW intercepts the request and serves it from\n//    the network.\n// 3a If the request fails (offline / server unreachable) or times out, the old\n//    v1 is served.\n// 3b If the request succeeds, the browser receives the index.html for v2. That\n//    will try to fetch resources from /v2/frontend_bundle.ts.\n// 4. When the SW sees the /v2/ request, will have a cache miss and will issue\n//    a network fetch(), returning the fresh /v2/ content.\n// 4. The v2 site will call serviceWorker.register('service_worker.js?v=v2').\n//    This (i.e. the different querystring) will cause a re-installation of the\n//    service worker (even if the service_worker.js script itself is unchanged).\n// 5. In the \"install\" step, the service_worker.js script will fetch the newer\n//    version (v2).\n//    Note: the v2 will be fetched twice, once upon the first request that\n//    causes causes a cache-miss, the second time while re-installing the SW.\n//    The  latter though will hit a HTTP 304 (Not Changed) and will be served\n//    from the browser cache after the revalidation request.\n// 6. The 'activate' handler is triggered. The old v1 cache is deleted at this\n//    point.\n\ndeclare let self: ServiceWorkerGlobalScope;\nexport {};\n\nconst LOG_TAG = `ServiceWorker: `;\nconst CACHE_NAME = 'ui-perfetto-dev';\nconst OPEN_TRACE_PREFIX = '/_open_trace'\n\n// If the fetch() for the / doesn't respond within 3s, return a cached version.\n// This is to avoid that a user waits too much if on a flaky network.\nconst INDEX_TIMEOUT_MS = 3000;\n\n// Use more relaxed timeouts when caching the subresources for the new version\n// in the background.\nconst INSTALL_TIMEOUT_MS = 30000;\n\n// Files passed to POST /_open_trace/NNNN.\nlet postedFiles = new Map<string, File>();\n\n// The install() event is fired:\n// 1. On the first visit, when there is no SW installed.\n// 2. Every time the user opens the site and the version has been updated (they\n//    will get the newer version regardless, unless we hit INDEX_TIMEOUT_MS).\n// The latter happens because:\n// - / (index.html) is always served from the network (% timeout) and it pulls\n//   /v1.2-sha/frontend_bundle.js.\n// - /v1.2-sha/frontend_bundle.js will register /service_worker.js?v=v1.2-sha.\n// The service_worker.js script itself never changes, but the browser\n// re-installs it because the version in the V? query-string argument changes.\n// The reinstallation will cache the new files from the v.1.2-sha/manifest.json.\nself.addEventListener('install', (event) => {\n  const doInstall = async () => {\n    // If we can not access the cache we must give up on the service\n    // worker:\n    let bypass = true;\n    try {\n      bypass = await caches.has('BYPASS_SERVICE_WORKER');\n    } catch (_) {\n      // TODO(288483453)\n    }\n    if (bypass) {\n      // Throw will prevent the installation.\n      throw new Error(LOG_TAG + 'skipping installation, bypass enabled');\n    }\n\n    // Delete old cache entries from the pre-feb-2021 service worker.\n    try {\n      for (const key of await caches.keys()) {\n        if (key.startsWith('dist-')) {\n          await caches.delete(key);\n        }\n      }\n    } catch (_) {\n      // TODO(288483453)\n      // It's desirable to delete the old entries but it's not actually\n      // damaging to keep them around so don't give up on the\n      // installation if this fails.\n    }\n\n    // The UI should register this as service_worker.js?v=v1.2-sha. Extract the\n    // version number and pre-fetch all the contents for the version.\n    const match = /\\bv=([\\w.-]*)/.exec(location.search);\n    if (!match) {\n      throw new Error(\n          'Failed to install. Was epecting a query string like ' +\n          `?v=v1.2-sha query string, got \"${location.search}\" instead`);\n    }\n    await installAppVersionIntoCache(match[1]);\n\n    // skipWaiting() still waits for the install to be complete. Without this\n    // call, the new version would be activated only when all tabs are closed.\n    // Instead, we ask to activate it immediately. This is safe because the\n    // subresources are versioned (e.g. /v1.2-sha/frontend_bundle.js). Even if\n    // there is an old UI tab opened while we activate() a newer version, the\n    // activate() would just cause cache-misses, hence fetch from the network,\n    // for the old tab.\n    self.skipWaiting();\n  };\n  event.waitUntil(doInstall());\n});\n\nself.addEventListener('activate', (event) => {\n  console.info(LOG_TAG + 'activated');\n  const doActivate = async () => {\n    // This makes a difference only for the very first load, when no service\n    // worker is present. In all the other cases the skipWaiting() will hot-swap\n    // the active service worker anyways.\n    await self.clients.claim();\n  };\n  event.waitUntil(doActivate());\n});\n\nself.addEventListener('fetch', (event) => {\n\n  // The early return here will cause the browser to fall back on standard\n  // network-based fetch.\n  if (!shouldHandleHttpRequest(event.request)) {\n    console.debug(LOG_TAG + `serving ${event.request.url} from network`);\n    return;\n  }\n\n  event.respondWith(handleHttpRequest(event.request));\n});\n\n\nfunction shouldHandleHttpRequest(req: Request): boolean {\n  // Suppress warning: 'only-if-cached' can be set only with 'same-origin' mode.\n  // This seems to be a chromium bug. An internal code search suggests this is a\n  // socially acceptable workaround.\n  if (req.cache === 'only-if-cached' && req.mode !== 'same-origin') {\n    return false;\n  }\n\n  const url = new URL(req.url);\n  if (url.pathname === '/live_reload') return false;\n  if (url.pathname.startsWith(OPEN_TRACE_PREFIX)) return true;\n\n  return req.method === 'GET' && url.origin === self.location.origin;\n}\n\nasync function handleHttpRequest(req: Request): Promise<Response> {\n  if (!shouldHandleHttpRequest(req)) {\n    throw new Error(LOG_TAG + `${req.url} shouldn't have been handled`);\n  }\n\n  // We serve from the cache even if req.cache == 'no-cache'. It's a bit\n  // contra-intuitive but it's the most consistent option. If the user hits the\n  // reload button*, the browser requests the \"/\" index with a 'no-cache' fetch.\n  // However all the other resources (css, js, ...) are requested with a\n  // 'default' fetch (this is just how Chrome works, it's not us). If we bypass\n  // the service worker cache when we get a 'no-cache' request, we can end up in\n  // an inconsistent state where the index.html is more recent than the other\n  // resources, which is undesirable.\n  // * Only Ctrl+R. Ctrl+Shift+R will always bypass service-worker for all the\n  // requests (index.html and the rest) made in that tab.\n\n  const cacheOps = {cacheName: CACHE_NAME} as CacheQueryOptions;\n  const url = new URL(req.url);\n  if (url.pathname === '/') {\n    try {\n      console.debug(LOG_TAG + `Fetching live ${req.url}`);\n      // The await bleow is needed to fall through in case of an exception.\n      return await fetchWithTimeout(req, INDEX_TIMEOUT_MS);\n    } catch (err) {\n      console.warn(LOG_TAG + `Failed to fetch ${req.url}, using cache.`, err);\n      // Fall through the code below.\n    }\n  } else if (url.pathname === '/offline') {\n    // Escape hatch to force serving the offline version without attempting the\n    // network fetch.\n    const cachedRes = await caches.match(new Request('/'), cacheOps);\n    if (cachedRes) return cachedRes;\n  } else if (url.pathname.startsWith(OPEN_TRACE_PREFIX)) {\n    return await handleOpenTraceRequest(req);\n  }\n\n  const cachedRes = await caches.match(req, cacheOps);\n  if (cachedRes) {\n    console.debug(LOG_TAG + `serving ${req.url} from cache`);\n    return cachedRes;\n  }\n\n  // In any other case, just propagate the fetch on the network, which is the\n  // safe behavior.\n  console.warn(LOG_TAG + `cache miss on ${req.url}, using live network`);\n  return fetch(req);\n}\n\n// Handles GET and POST requests to /_open_trace/NNNN, where NNNN is typically a\n// random token generated by the client.\n// This works as follows:\n// - The client does a POST request to /_open_trace/NNNN passing the trace blob\n//   as multipart-data, alongside other options like hideSidebar & co that we\n//   support in the usual querystring (see router.ts)\n// - The SW takes the file and puts it in the global variable `postedFiles`.\n// - The SW responds to the POST request with a redirect to\n//   ui.perfetto.dev/#!/?url=https://ui.perfetto.dev/_open_trace/NNNN&other_args\n// - When the new ui.perfetto.dev is reloaded, it will naturally try to fetch\n//   the trace from /_open_trace/NNNN, this time via a GET request.\n// - The SW intercepts the GET request and returns the file previosly stored in\n//   `postedFiles`.\n// We use postedFiles here to handle the case of progammatically POST-ing to >1\n// instances of ui.perfetto.dev simultaneously, to avoid races.\n// Note that we should not use a global variable for `postedFiles` but we should\n// use the CacheAPI because, technically speaking, the SW could be disposed\n// and respawned in between the POST and the GET request. In practice, however,\n// SWs are disposed only after 30s seconds of idleness. The POST->GET requests\n// happen back-to-back..\nasync function handleOpenTraceRequest(req: Request): Promise<Response> {\n  const url = new URL(req.url);\n  console.assert(url.pathname.startsWith(OPEN_TRACE_PREFIX));\n  const fileKey = url.pathname.substring(OPEN_TRACE_PREFIX.length);\n  if (req.method === 'POST') {\n    const formData = await req.formData();\n    const qsParams = new URLSearchParams();\n    // Iterate over the POST fields and copy them over the querystring in\n    // the hash, with the exception of the trace file. The trace file is\n    // kept in the serviceworker and passed as a url= argument.\n    formData.forEach((value, key) => {\n      if (key === 'trace') {\n        if (value instanceof File) {\n          postedFiles.set(fileKey, value);\n          qsParams.set('url', req.url);\n        }\n        return;\n      }\n      qsParams.set(key, `${value}`);\n    });  // formData.forEach()\n    return Response.redirect(`${url.protocol}//${url.host}/#!/?${qsParams}`);\n  }\n\n  // else... method == 'GET'\n  const file = postedFiles.get(fileKey);\n  if (file !== undefined) {\n    postedFiles.delete(fileKey);\n    return new Response(file);\n  }\n\n  // The file /_open_trace/NNNN does not exist.\n  return Response.error();\n}\n\nasync function installAppVersionIntoCache(version: string) {\n  const manifestUrl = `${version}/manifest.json`;\n  try {\n    console.log(LOG_TAG + `Starting installation of ${manifestUrl}`);\n    await caches.delete(CACHE_NAME);\n    const resp = await fetchWithTimeout(manifestUrl, INSTALL_TIMEOUT_MS);\n    const manifest = await resp.json();\n    const manifestResources = manifest['resources'];\n    if (!manifestResources || !(manifestResources instanceof Object)) {\n      throw new Error(`Invalid manifest ${manifestUrl} : ${manifest}`);\n    }\n\n    const cache = await caches.open(CACHE_NAME);\n    const urlsToCache: RequestInfo[] = [];\n\n    // We use cache:reload to make sure that the index is always current and we\n    // don't end up in some cycle where we keep re-caching the index coming from\n    // the service worker itself.\n    urlsToCache.push(new Request('/', {cache: 'reload', mode: 'same-origin'}));\n\n    for (const [resource, integrity] of Object.entries(manifestResources)) {\n      // We use cache: no-cache rather then reload here because the versioned\n      // sub-resources are expected to be immutable and should never be\n      // ambiguous. A revalidation request is enough.\n      const reqOpts: RequestInit = {\n        cache: 'no-cache',\n        mode: 'same-origin',\n        integrity: `${integrity}`,\n      };\n      urlsToCache.push(new Request(`${version}/${resource}`, reqOpts));\n    }\n    await cache.addAll(urlsToCache);\n    console.log(LOG_TAG + 'installation completed for ' + version);\n  } catch (err) {\n    console.error(LOG_TAG + `Installation failed for ${manifestUrl}`, err);\n    await caches.delete(CACHE_NAME);\n    throw err;\n  }\n}\n\nfunction fetchWithTimeout(req: Request|string, timeoutMs: number) {\n  const url = (req as {url?: string}).url || `${req}`;\n  return new Promise<Response>((resolve, reject) => {\n    const timerId = setTimeout(() => {\n      reject(new Error(`Timed out while fetching ${url}`));\n    }, timeoutMs);\n    fetch(req).then((resp) => {\n      clearTimeout(timerId);\n      if (resp.ok) {\n        resolve(resp);\n      } else {\n        reject(new Error(\n            `Fetch failed for ${url}: ${resp.status} ${resp.statusText}`));\n      }\n    }, reject);\n  });\n}\n"]}