{"version":3,"file":"workspace.js","sourceRoot":"","sources":["../../../src/public/workspace.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assertTrue} from '../base/logging';\n\nexport interface WorkspaceManager {\n  // This is the same of ctx.workspace, exposed for consistency also here.\n  readonly currentWorkspace: Workspace;\n  readonly all: ReadonlyArray<Workspace>;\n  createEmptyWorkspace(displayName: string): Workspace;\n  switchWorkspace(workspace: Workspace): void;\n}\n\nlet sessionUniqueIdCounter = 0;\n\n/**\n * Creates a short ID which is unique to this instance of the UI.\n *\n * The advantage of using this over uuidv4() is that the ids produced are\n * significantly shorter, saving memory and making them more human\n * read/write-able which helps when debugging.\n *\n * Note: The ID range will reset every time the UI is restarted, so be careful\n * not rely on these IDs in any medium that can survive between UI instances.\n *\n * TODO(stevegolton): We could possibly move this into its own module and use it\n * everywhere where session-unique ids are required.\n */\nfunction createSessionUniqueId(): string {\n  // Return the counter in base36 (0-z) to keep the string as short as possible\n  // but still human readable.\n  return (sessionUniqueIdCounter++).toString(36);\n}\n\n/**\n * Describes generic parent track node functionality - i.e. any entity that can\n * contain child TrackNodes, providing methods to add, remove, and access child\n * nodes.\n *\n * This class is abstract because, while it can technically be instantiated on\n * its own (no abstract methods/properties), it can't and shouldn't be\n * instantiated anywhere in practice - all APIs require either a TrackNode or a\n * Workspace.\n *\n * Thus, it serves two purposes:\n * 1. Avoiding duplication between Workspace and TrackNode, which is an internal\n *    implementation detail of this module.\n * 2. Providing a typescript interface for a generic TrackNode container class,\n *    which otherwise you might have to achieve using `Workspace | TrackNode`\n *    which is uglier.\n *\n * If you find yourself using this as a Javascript class in external code, e.g.\n * `instance of TrackNodeContainer`, you're probably doing something wrong.\n */\n\nexport interface TrackNodeArgs {\n  title: string;\n  id: string;\n  uri: string;\n  headless: boolean;\n  sortOrder: number;\n  collapsed: boolean;\n  isSummary: boolean;\n  removable: boolean;\n}\n\n/**\n * A base class for any node with children (i.e. a group or a workspace).\n */\nexport class TrackNode {\n  // Immutable unique (within the workspace) ID of this track node. Used for\n  // efficiently retrieving this node object from a workspace. Note: This is\n  // different to |uri| which is used to reference a track to render on the\n  // track. If this means nothing to you, don't bother using it.\n  public readonly id: string;\n\n  // A human readable string for this track - displayed in the track shell.\n  // TODO(stevegolton): Make this optional, so that if we implement a string for\n  // this track then we can implement it here as well.\n  public title: string;\n\n  // The URI of the track content to display here.\n  public uri?: string;\n\n  // Optional sort order, which workspaces may or may not take advantage of for\n  // sorting when displaying the workspace.\n  public sortOrder?: number;\n\n  // Don't show the header at all for this track, just show its un-nested\n  // children. This is helpful to group together tracks that logically belong to\n  // the same group (e.g. all ftrace cpu tracks) and ease the job of\n  // sorting/grouping plugins.\n  public headless: boolean;\n\n  // If true, this track is to be used as a summary for its children. When the\n  // group is expanded the track will become sticky to the top of the viewport\n  // to provide context for the tracks within, and the content of this track\n  // shall be omitted. It will also be squashed down to a smaller height to save\n  // vertical space.\n  public isSummary: boolean;\n\n  // If true, this node will be removable by the user. It will show a little\n  // close button in the track shell which the user can press to remove the\n  // track from the workspace.\n  public removable: boolean;\n\n  protected _collapsed = true;\n  protected _children: Array<TrackNode> = [];\n  protected readonly tracksById = new Map<string, TrackNode>();\n  protected readonly tracksByUri = new Map<string, TrackNode>();\n  private _parent?: TrackNode;\n  public _workspace?: Workspace;\n\n  get parent(): TrackNode | undefined {\n    return this._parent;\n  }\n\n  constructor(args?: Partial<TrackNodeArgs>) {\n    const {\n      title = '',\n      id = createSessionUniqueId(),\n      uri,\n      headless = false,\n      sortOrder,\n      collapsed = true,\n      isSummary = false,\n      removable = false,\n    } = args ?? {};\n\n    this.id = id;\n    this.uri = uri;\n    this.headless = headless;\n    this.title = title;\n    this.sortOrder = sortOrder;\n    this.isSummary = isSummary;\n    this._collapsed = collapsed;\n    this.removable = removable;\n  }\n\n  /**\n   * Remove this track from it's parent & unpin from the workspace if pinned.\n   */\n  remove(): void {\n    this.workspace?.unpinTrack(this);\n    this.parent?.removeChild(this);\n  }\n\n  /**\n   * Add this track to the list of pinned tracks in its parent workspace.\n   *\n   * Has no effect if this track is not added to a workspace.\n   */\n  pin(): void {\n    this.workspace?.pinTrack(this);\n  }\n\n  /**\n   * Remove this track from the list of pinned tracks in its parent workspace.\n   *\n   * Has no effect if this track is not added to a workspace.\n   */\n  unpin(): void {\n    this.workspace?.unpinTrack(this);\n  }\n\n  /**\n   * Returns true if this node is added to a workspace as is in the pinned track\n   * list of that workspace.\n   */\n  get isPinned(): boolean {\n    return Boolean(this.workspace?.hasPinnedTrack(this));\n  }\n\n  /**\n   * Find the closest visible ancestor TrackNode.\n   *\n   * Given the path from the root workspace to this node, find the fist one,\n   * starting from the root, which is collapsed. This will be, from the user's\n   * point of view, the closest ancestor of this node.\n   *\n   * Returns undefined if this node is actually visible.\n   *\n   * TODO(stevegolton): Should it return itself in this case?\n   */\n  findClosestVisibleAncestor(): TrackNode {\n    // Build a path from the root workspace to this node\n    const path: TrackNode[] = [];\n    let node = this.parent;\n    while (node) {\n      path.unshift(node);\n      node = node.parent;\n    }\n\n    // Find the first collapsed track in the path starting from the root. This\n    // is effectively the closest we can get to this node without expanding any\n    // groups.\n    return path.find((node) => node.collapsed) ?? this;\n  }\n\n  /**\n   * Expand all ancestor nodes.\n   */\n  reveal(): void {\n    let parent = this.parent;\n    while (parent) {\n      parent.expand();\n      parent = parent.parent;\n    }\n  }\n\n  /**\n   * Find this node's root node - this may be a workspace or another node.\n   */\n  get rootNode(): TrackNode {\n    let node: TrackNode = this;\n    while (node.parent) {\n      node = node.parent;\n    }\n    return node;\n  }\n\n  /**\n   * Find this node's workspace if it is attached to one.\n   */\n  get workspace(): Workspace | undefined {\n    return this.rootNode._workspace;\n  }\n\n  /**\n   * Mark this node as un-collapsed, indicating its children should be rendered.\n   */\n  expand(): void {\n    this._collapsed = false;\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Mark this node as collapsed, indicating its children should not be\n   * rendered.\n   */\n  collapse(): void {\n    this._collapsed = true;\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Toggle the collapsed state.\n   */\n  toggleCollapsed(): void {\n    this._collapsed = !this._collapsed;\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Whether this node is collapsed, indicating its children should be rendered.\n   */\n  get collapsed(): boolean {\n    return this._collapsed;\n  }\n\n  /**\n   * Whether this node is expanded - i.e. not collapsed, indicating its children\n   * should be rendered.\n   */\n  get expanded(): boolean {\n    return !this._collapsed;\n  }\n\n  /**\n   * Returns the list of titles representing the full path from the root node to\n   * the current node. This path consists only of node titles, workspaces are\n   * omitted.\n   */\n  get fullPath(): ReadonlyArray<string> {\n    let fullPath = [this.title];\n    let parent = this.parent;\n    while (parent) {\n      // Ignore headless containers as they don't appear in the tree...\n      if (!parent.headless && parent.title !== '') {\n        fullPath = [parent.title, ...fullPath];\n      }\n      parent = parent.parent;\n    }\n    return fullPath;\n  }\n\n  protected fireOnChangeListener(): void {\n    this.workspace?.onchange(this.workspace);\n  }\n\n  /**\n   * True if this node has children, false otherwise.\n   */\n  get hasChildren(): boolean {\n    return this._children.length > 0;\n  }\n\n  /**\n   * The ordered list of children belonging to this node.\n   */\n  get children(): ReadonlyArray<TrackNode> {\n    return this._children;\n  }\n\n  /**\n   * Inserts a new child node considering it's sortOrder.\n   *\n   * The child will be added before the first child whose |sortOrder| is greater\n   * than the child node's sort order, or at the end if one does not exist. If\n   * |sortOrder| is omitted on either node in the comparison it is assumed to be\n   * 0.\n   *\n   * @param child - The child node to add.\n   */\n  addChildInOrder(child: TrackNode): void {\n    const insertPoint = this._children.find(\n      (n) => (n.sortOrder ?? 0) > (child.sortOrder ?? 0),\n    );\n    if (insertPoint) {\n      this.addChildBefore(child, insertPoint);\n    } else {\n      this.addChildLast(child);\n    }\n  }\n\n  /**\n   * Add a new child node at the start of the list of children.\n   *\n   * @param child The new child node to add.\n   */\n  addChildLast(child: TrackNode): void {\n    this.adopt(child);\n    this._children.push(child);\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Add a new child node at the end of the list of children.\n   *\n   * @param child The child node to add.\n   */\n  addChildFirst(child: TrackNode): void {\n    this.adopt(child);\n    this._children.unshift(child);\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Add a new child node before an existing child node.\n   *\n   * @param child The child node to add.\n   * @param referenceNode An existing child node. The new node will be added\n   * before this node.\n   */\n  addChildBefore(child: TrackNode, referenceNode: TrackNode): void {\n    if (child === referenceNode) return;\n\n    assertTrue(this.children.includes(referenceNode));\n\n    this.adopt(child);\n\n    const indexOfReference = this.children.indexOf(referenceNode);\n    this._children.splice(indexOfReference, 0, child);\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Add a new child node after an existing child node.\n   *\n   * @param child The child node to add.\n   * @param referenceNode An existing child node. The new node will be added\n   * after this node.\n   */\n  addChildAfter(child: TrackNode, referenceNode: TrackNode): void {\n    if (child === referenceNode) return;\n\n    assertTrue(this.children.includes(referenceNode));\n\n    this.adopt(child);\n\n    const indexOfReference = this.children.indexOf(referenceNode);\n    this._children.splice(indexOfReference + 1, 0, child);\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Remove a child node from this node.\n   *\n   * @param child The child node to remove.\n   */\n  removeChild(child: TrackNode): void {\n    this._children = this.children.filter((x) => child !== x);\n    child._parent = undefined;\n    this.removeFromIndex(child);\n    this.propagateRemoval(child);\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * The flattened list of all descendent nodes in depth first order.\n   *\n   * Use flatTracksUnordered if you don't care about track order, as it's more\n   * efficient.\n   */\n  get flatTracksOrdered(): ReadonlyArray<TrackNode> {\n    const tracks: TrackNode[] = [];\n    this.collectFlatTracks(tracks);\n    return tracks;\n  }\n\n  private collectFlatTracks(tracks: TrackNode[]): void {\n    for (let i = 0; i < this.children.length; ++i) {\n      tracks.push(this.children[i]); // Push the current node before its children\n      this.children[i].collectFlatTracks(tracks); // Recurse to collect child tracks\n    }\n  }\n\n  /**\n   * The flattened list of all descendent nodes in no particular order.\n   */\n  get flatTracks(): ReadonlyArray<TrackNode> {\n    return Array.from(this.tracksById.values());\n  }\n\n  /**\n   * Remove all children from this node.\n   */\n  clear(): void {\n    this._children = [];\n    this.tracksById.clear();\n    this.fireOnChangeListener();\n  }\n\n  /**\n   * Find a track node by its id.\n   *\n   * Node: This is an O(1) operation.\n   *\n   * @param id The id of the node we want to find.\n   * @returns The node or undefined if no such node exists.\n   */\n  getTrackById(id: string): TrackNode | undefined {\n    return this.tracksById.get(id);\n  }\n\n  /**\n   * Find a track node via its URI.\n   *\n   * Node: This is an O(1) operation.\n   *\n   * @param uri The uri of the track to find.\n   * @returns The node or undefined if no such node exists with this URI.\n   */\n  findTrackByUri(uri: string): TrackNode | undefined {\n    return this.tracksByUri.get(uri);\n  }\n\n  /**\n   * Creates a copy of this node with a new ID.\n   *\n   * @param deep - If true, children are copied too.\n   * @returns - A copy of this node.\n   */\n  clone(deep = false): TrackNode {\n    const cloned = new TrackNode({...this, id: undefined});\n    if (deep) {\n      this.children.forEach((c) => {\n        cloned.addChildLast(c.clone(deep));\n      });\n    }\n    return cloned;\n  }\n\n  private adopt(child: TrackNode): void {\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child._parent = this;\n    this.addToIndex(child);\n    this.propagateAddition(child);\n  }\n\n  private addToIndex(child: TrackNode) {\n    this.tracksById.set(child.id, child);\n    for (const [id, node] of child.tracksById) {\n      this.tracksById.set(id, node);\n    }\n\n    child.uri && this.tracksByUri.set(child.uri, child);\n    for (const [uri, node] of child.tracksByUri) {\n      this.tracksByUri.set(uri, node);\n    }\n  }\n\n  private removeFromIndex(child: TrackNode) {\n    this.tracksById.delete(child.id);\n    for (const [id] of child.tracksById) {\n      this.tracksById.delete(id);\n    }\n\n    child.uri && this.tracksByUri.delete(child.uri);\n    for (const [uri] of child.tracksByUri) {\n      this.tracksByUri.delete(uri);\n    }\n  }\n\n  private propagateAddition(node: TrackNode): void {\n    if (this.parent) {\n      this.parent.addToIndex(node);\n      this.parent.propagateAddition(node);\n    }\n  }\n\n  private propagateRemoval(node: TrackNode): void {\n    if (this.parent) {\n      this.parent.removeFromIndex(node);\n      this.parent.propagateRemoval(node);\n    }\n  }\n}\n\n/**\n * Defines a workspace containing a track tree and a pinned area.\n */\nexport class Workspace {\n  public title = '<untitled-workspace>';\n  public readonly id: string;\n  onchange: (w: Workspace) => void = () => {};\n\n  // Dummy node to contain the pinned tracks\n  public readonly pinnedTracksNode = new TrackNode();\n  public readonly tracks = new TrackNode();\n\n  get pinnedTracks(): ReadonlyArray<TrackNode> {\n    return this.pinnedTracksNode.children;\n  }\n\n  constructor() {\n    this.id = createSessionUniqueId();\n    this.pinnedTracksNode._workspace = this;\n    this.tracks._workspace = this;\n\n    // Expanding these nodes makes the logic work\n    this.pinnedTracksNode.expand();\n    this.tracks.expand();\n  }\n\n  /**\n   * Reset the entire workspace including the pinned tracks.\n   */\n  clear(): void {\n    this.pinnedTracksNode.clear();\n    this.tracks.clear();\n  }\n\n  /**\n   * Adds a track node to this workspace's pinned area.\n   */\n  pinTrack(track: TrackNode): void {\n    // Make a lightweight clone of this track - just the uri and the title.\n    const cloned = new TrackNode({\n      uri: track.uri,\n      title: track.title,\n      removable: track.removable,\n    });\n    this.pinnedTracksNode.addChildLast(cloned);\n  }\n\n  /**\n   * Removes a track node from this workspace's pinned area.\n   */\n  unpinTrack(track: TrackNode): void {\n    const foundNode = this.pinnedTracksNode.children.find(\n      (t) => t.uri === track.uri,\n    );\n    if (foundNode) {\n      this.pinnedTracksNode.removeChild(foundNode);\n    }\n  }\n\n  /**\n   * Check if this workspace has a pinned track with the same URI as |track|.\n   */\n  hasPinnedTrack(track: TrackNode): boolean {\n    return this.pinnedTracksNode.flatTracks.some((p) => p.uri === track.uri);\n  }\n\n  /**\n   * Find a track node via its URI.\n   *\n   * Note: This in an O(N) operation where N is the number of nodes in the\n   * workspace.\n   *\n   * @param uri The uri of the track to find.\n   * @returns A reference to the track node if it exists in this workspace,\n   * otherwise undefined.\n   */\n  findTrackByUri(uri: string): TrackNode | undefined {\n    return this.tracks.flatTracks.find((t) => t.uri === uri);\n  }\n\n  /**\n   * Find a track by ID, also searching pinned tracks.\n   */\n  getTrackById(id: string): TrackNode | undefined {\n    return (\n      this.tracks.getTrackById(id) || this.pinnedTracksNode.getTrackById(id)\n    );\n  }\n\n  /**\n   * The ordered list of children belonging to this node.\n   */\n  get children(): ReadonlyArray<TrackNode> {\n    return this.tracks.children;\n  }\n\n  /**\n   * Inserts a new child node considering it's sortOrder.\n   *\n   * The child will be added before the first child whose |sortOrder| is greater\n   * than the child node's sort order, or at the end if one does not exist. If\n   * |sortOrder| is omitted on either node in the comparison it is assumed to be\n   * 0.\n   *\n   * @param child - The child node to add.\n   */\n  addChildInOrder(child: TrackNode): void {\n    this.tracks.addChildInOrder(child);\n  }\n\n  /**\n   * Add a new child node at the start of the list of children.\n   *\n   * @param child The new child node to add.\n   */\n  addChildLast(child: TrackNode): void {\n    this.tracks.addChildLast(child);\n  }\n\n  /**\n   * Add a new child node at the end of the list of children.\n   *\n   * @param child The child node to add.\n   */\n  addChildFirst(child: TrackNode): void {\n    this.tracks.addChildFirst(child);\n  }\n\n  /**\n   * Add a new child node before an existing child node.\n   *\n   * @param child The child node to add.\n   * @param referenceNode An existing child node. The new node will be added\n   * before this node.\n   */\n  addChildBefore(child: TrackNode, referenceNode: TrackNode): void {\n    this.tracks.addChildBefore(child, referenceNode);\n  }\n\n  /**\n   * Add a new child node after an existing child node.\n   *\n   * @param child The child node to add.\n   * @param referenceNode An existing child node. The new node will be added\n   * after this node.\n   */\n  addChildAfter(child: TrackNode, referenceNode: TrackNode): void {\n    this.tracks.addChildAfter(child, referenceNode);\n  }\n\n  /**\n   * Remove a child node from this node.\n   *\n   * @param child The child node to remove.\n   */\n  removeChild(child: TrackNode): void {\n    this.tracks.removeChild(child);\n  }\n\n  /**\n   * The flattened list of all descendent nodes in depth first order.\n   *\n   * Use flatTracksUnordered if you don't care about track order, as it's more\n   * efficient.\n   */\n  get flatTracksOrdered() {\n    return this.tracks.flatTracksOrdered;\n  }\n\n  /**\n   * The flattened list of all descendent nodes in no particular order.\n   */\n  get flatTracks() {\n    return this.tracks.flatTracks;\n  }\n}\n"]}