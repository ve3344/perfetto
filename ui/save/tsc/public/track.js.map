{"version":3,"file":"track.js","sourceRoot":"","sources":["../../../src/public/track.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport m from 'mithril';\nimport {duration, time} from '../base/time';\nimport {Size2D, VerticalBounds} from '../base/geom';\nimport {TimeScale} from '../base/time_scale';\nimport {HighPrecisionTimeSpan} from '../base/high_precision_time_span';\nimport {ColorScheme} from './color_scheme';\nimport {TrackEventDetailsPanel} from './details_panel';\nimport {TrackEventDetails, TrackEventSelection} from './selection';\nimport {Dataset} from '../trace_processor/dataset';\n\nexport interface TrackManager {\n  /**\n   * Register a new track against a unique key known as a URI. The track is not\n   * shown by default and callers need to either manually add it to a\n   * Workspace or use registerTrackAndShowOnTraceLoad() below.\n   */\n  registerTrack(trackDesc: TrackDescriptor): void;\n\n  findTrack(\n    predicate: (desc: TrackDescriptor) => boolean | undefined,\n  ): TrackDescriptor | undefined;\n\n  getAllTracks(): TrackDescriptor[];\n\n  getTrack(uri: string): TrackDescriptor | undefined;\n}\n\nexport interface TrackContext {\n  // This track's URI, used for making selections et al.\n  readonly trackUri: string;\n}\n\n/**\n * Contextual information about the track passed to track lifecycle hooks &\n * render hooks with additional information about the timeline/canvas.\n */\nexport interface TrackRenderContext extends TrackContext {\n  /**\n   * The time span of the visible window.\n   */\n  readonly visibleWindow: HighPrecisionTimeSpan;\n\n  /**\n   * The dimensions of the track on the canvas in pixels.\n   */\n  readonly size: Size2D;\n\n  /**\n   * Suggested data resolution.\n   *\n   * This number is the number of time units that corresponds to 1 pixel on the\n   * screen, rounded down to the nearest power of 2. The minimum value is 1.\n   *\n   * It's up to the track whether it would like to use this resolution or\n   * calculate their own based on the timespan and the track dimensions.\n   */\n  readonly resolution: duration;\n\n  /**\n   * Canvas context used for rendering.\n   */\n  readonly ctx: CanvasRenderingContext2D;\n\n  /**\n   * A time scale used for translating between pixels and time.\n   */\n  readonly timescale: TimeScale;\n}\n\n// A definition of a track, including a renderer implementation and metadata.\nexport interface TrackDescriptor {\n  // A unique identifier for this track.\n  readonly uri: string;\n\n  // A factory function returning a new track instance.\n  readonly track: Track;\n\n  // Human readable title. Always displayed.\n  readonly title: string;\n\n  // Human readable subtitle. Sometimes displayed if there is room.\n  readonly subtitle?: string;\n\n  // Optional: A list of tags used for sorting, grouping and \"chips\".\n  readonly tags?: TrackTags;\n\n  readonly chips?: ReadonlyArray<string>;\n\n  readonly pluginId?: string;\n}\n\n/**\n * Contextual information passed to mouse events.\n */\nexport interface TrackMouseEvent {\n  /**\n   * X coordinate of the mouse event w.r.t. the top-left of the track.\n   */\n  readonly x: number;\n\n  /**\n   * Y coordinate of the mouse event w.r.t the top-left of the track.\n   */\n  readonly y: number;\n\n  /**\n   * A time scale used for translating between pixels and time.\n   */\n  readonly timescale: TimeScale;\n}\n\nexport interface Track {\n  /**\n   * Optional lifecycle hook called on the first render cycle. Should be used to\n   * create any required resources.\n   *\n   * These lifecycle hooks are asynchronous, but they are run synchronously,\n   * meaning that perfetto will wait for each one to complete before calling the\n   * next one, so the user doesn't have to serialize these calls manually.\n   *\n   * Exactly when this hook is called is left purposely undefined. The only\n   * guarantee is that it will be called exactly once before the first call to\n   * onUpdate().\n   *\n   * Note: On the first render cycle, both onCreate and onUpdate are called one\n   * after another.\n   */\n  onCreate?(ctx: TrackContext): Promise<void>;\n\n  /**\n   * Optional lifecycle hook called on every render cycle.\n   *\n   * The track should inspect things like the visible window, track size, and\n   * resolution to work out whether any data needs to be reloaded based on these\n   * properties and perform a reload.\n   */\n  onUpdate?(ctx: TrackRenderContext): Promise<void>;\n\n  /**\n   * Optional lifecycle hook called when the track is no longer visible. Should\n   * be used to clear up any resources.\n   */\n  onDestroy?(): Promise<void>;\n\n  /**\n   * Required method used to render the track's content to the canvas, called\n   * synchronously on every render cycle.\n   */\n  render(ctx: TrackRenderContext): void;\n  onFullRedraw?(): void;\n\n  /**\n   * Return the vertical bounds (top & bottom) of a slice were it to be rendered\n   * at a specific depth, given the slice height and padding/spacing that this\n   * track uses.\n   */\n  getSliceVerticalBounds?(depth: number): VerticalBounds | undefined;\n  getHeight(): number;\n  getTrackShellButtons?(): m.Children;\n  onMouseMove?(event: TrackMouseEvent): void;\n  onMouseClick?(event: TrackMouseEvent): boolean;\n  onMouseOut?(): void;\n\n  /**\n   * Optional: Returns a dataset that represents the events displayed on this\n   * track.\n   */\n  getDataset?(): Dataset | undefined;\n\n  /**\n   * Optional: Get details of a track event given by eventId on this track.\n   */\n  getSelectionDetails?(eventId: number): Promise<TrackEventDetails | undefined>;\n\n  // Optional: A factory that returns a details panel object for a given track\n  // event selection. This is called each time the selection is changed (and the\n  // selection is relevant to this track).\n  detailsPanel?(sel: TrackEventSelection): TrackEventDetailsPanel;\n}\n\n// An set of key/value pairs describing a given track. These are used for\n// selecting tracks to pin/unpin, diplsaying \"chips\" in the track shell, and\n// (in future) the sorting and grouping of tracks.\n// We define a handful of well known fields, and the rest are arbitrary key-\n// value pairs.\nexport type TrackTags = Partial<WellKnownTrackTags> & {\n  // There may be arbitrary other key/value pairs.\n  [key: string]:\n    | undefined\n    | string\n    | number\n    | boolean\n    | ReadonlyArray<string>\n    | ReadonlyArray<number>;\n};\n\ninterface WellKnownTrackTags {\n  // The track \"kind\", used by various subsystems e.g. aggregation controllers.\n  // This is where \"XXX_TRACK_KIND\" values should be placed.\n  // TODO(stevegolton): This will be deprecated once we handle group selections\n  // in a more generic way - i.e. EventSet.\n  kind: string;\n\n  // Optional: list of track IDs represented by this trace.\n  // This list is used for participation in track indexing by track ID.\n  // This index is used by various subsystems to find links between tracks based\n  // on the track IDs used by trace processor.\n  trackIds: ReadonlyArray<number>;\n\n  // Optional: The CPU number associated with this track.\n  cpu: number;\n\n  // Optional: The UTID associated with this track.\n  utid: number;\n\n  // Optional: The UPID associated with this track.\n  upid: number;\n\n  // Used for sorting and grouping\n  scope: string;\n\n  // Group name, used as a hint to ask track decider to put this in a group\n  groupName: string;\n}\n\nexport interface Slice {\n  // These properties are updated only once per query result when the Slice\n  // object is created and don't change afterwards.\n  readonly id: number;\n  readonly startNs: time;\n  readonly endNs: time;\n  readonly durNs: duration;\n  readonly ts: time;\n  readonly dur: duration;\n  readonly depth: number;\n  readonly flags: number;\n\n  // Each slice can represent some extra numerical information by rendering a\n  // portion of the slice with a lighter tint.\n  // |fillRatio\\ describes the ratio of the normal area to the tinted area\n  // width of the slice, normalized between 0.0 -> 1.0.\n  // 0.0 means the whole slice is tinted.\n  // 1.0 means none of the slice is tinted.\n  // E.g. If |fillRatio| = 0.65 the slice will be rendered like this:\n  // [############|*******]\n  // ^------------^-------^\n  //     Normal     Light\n  readonly fillRatio: number;\n\n  // These can be changed by the Impl.\n  title: string;\n  subTitle: string;\n  colorScheme: ColorScheme;\n  isHighlighted: boolean;\n}\n"]}