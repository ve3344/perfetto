{"version":3,"file":"selection.js","sourceRoot":"","sources":["../../../src/public/selection.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;;AA0JjC,kCAWC;AApBD,IAAY,WAOX;AAPD,WAAY,WAAW;IACrB,4CAA6B,CAAA;IAC7B,8EAA+D,CAAA;IAC/D,+DAAgD,CAAA;IAChD,iEAAkD,CAAA;IAClD,wCAAyB,CAAA;IACzB,mCAAoB,CAAA;AACtB,CAAC,EAPW,WAAW,2BAAX,WAAW,QAOtB;AAED,SAAgB,WAAW,CAAC,CAAS;IACnC,IAAI,CAAC,KAAK,0CAA0C,EAAE,CAAC;QACrD,CAAC,GAAG,0CAA0C,CAAC;IACjD,CAAC;IACD,IAAI,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAgB,CAAC,EAAE,CAAC;QAC1D,OAAO,CAAgB,CAAC;IAC1B,CAAC;IACD,IAAI,CAAC,CAAC,UAAU,CAAC,cAAc,CAAC,EAAE,CAAC;QACjC,OAAO,WAAW,CAAC,YAAY,CAAC;IAClC,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;AACvC,CAAC","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {time, duration, TimeSpan} from '../base/time';\nimport {Engine} from '../trace_processor/engine';\nimport {ColumnDef, Sorting, ThreadStateExtra} from './aggregation';\nimport {TrackDescriptor} from './track';\n\nexport interface SelectionManager {\n  readonly selection: Selection;\n\n  findTimeRangeOfSelection(): TimeSpan | undefined;\n  clear(): void;\n\n  /**\n   * Select a track event.\n   *\n   * @param trackUri - The URI of the track to select.\n   * @param eventId - The value of the events ID column.\n   * @param opts - Additional options.\n   */\n  selectTrackEvent(\n    trackUri: string,\n    eventId: number,\n    opts?: SelectionOpts,\n  ): void;\n\n  /**\n   * Select a track.\n   *\n   * @param trackUri - The URI for the track to select.\n   * @param opts - Additional options.\n   */\n  selectTrack(trackUri: string, opts?: SelectionOpts): void;\n\n  /**\n   * Select a track event via a sql table name + id.\n   *\n   * @param sqlTableName - The name of the SQL table to resolve.\n   * @param id - The ID of the event in that table.\n   * @param opts - Additional options.\n   */\n  selectSqlEvent(sqlTableName: string, id: number, opts?: SelectionOpts): void;\n\n  /**\n   * Create an area selection for the purposes of aggregation.\n   *\n   * @param args - The area to select.\n   * @param opts - Additional options.\n   */\n  selectArea(args: Area, opts?: SelectionOpts): void;\n\n  scrollToCurrentSelection(): void;\n  registerAreaSelectionAggregator(aggr: AreaSelectionAggregator): void;\n\n  /**\n   * Register a new SQL selection resolver.\n   *\n   * A resolver consists of a SQL table name and a callback. When someone\n   * expresses an interest in selecting a slice on a matching table, the\n   * callback is called which can return a selection object or undefined.\n   */\n  registerSqlSelectionResolver(resolver: SqlSelectionResolver): void;\n}\n\nexport interface AreaSelectionAggregator {\n  readonly id: string;\n  createAggregateView(engine: Engine, area: AreaSelection): Promise<boolean>;\n  getExtra(\n    engine: Engine,\n    area: AreaSelection,\n  ): Promise<ThreadStateExtra | void>;\n  getTabName(): string;\n  getDefaultSorting(): Sorting;\n  getColumnDefinitions(): ColumnDef[];\n}\n\nexport type Selection =\n  | TrackEventSelection\n  | TrackSelection\n  | AreaSelection\n  | NoteSelection\n  | EmptySelection;\n\n/** Defines how changes to selection affect the rest of the UI state */\nexport interface SelectionOpts {\n  clearSearch?: boolean; // Default: true.\n  switchToCurrentSelectionTab?: boolean; // Default: true.\n  scrollToSelection?: boolean; // Default: false.\n}\n\nexport interface TrackEventSelection extends TrackEventDetails {\n  readonly kind: 'track_event';\n  readonly trackUri: string;\n  readonly eventId: number;\n}\n\nexport interface TrackSelection {\n  readonly kind: 'track';\n  readonly trackUri: string;\n}\n\nexport interface TrackEventDetails {\n  // ts and dur are required by the core, and must be provided.\n  readonly ts: time;\n  // Note: dur can be -1 for instant events.\n  readonly dur: duration;\n\n  // Optional additional information.\n  // TODO(stevegolton): Find an elegant way of moving this information out of\n  // the core.\n  readonly wakeupTs?: time;\n  readonly wakerCpu?: number;\n  readonly upid?: number;\n  readonly utid?: number;\n  readonly tableName?: string;\n  readonly profileType?: ProfileType;\n  readonly interactionType?: string;\n}\n\nexport interface Area {\n  readonly start: time;\n  readonly end: time;\n  // TODO(primiano): this should be ReadonlyArray<> after the pivot table state\n  // doesn't use State/Immer anymore.\n  readonly trackUris: string[];\n}\n\nexport interface AreaSelection extends Area {\n  readonly kind: 'area';\n\n  // This array contains the resolved TrackDescriptor from Area.trackUris.\n  // The resolution is done by SelectionManager whenever a kind='area' selection\n  // is performed.\n  readonly tracks: ReadonlyArray<TrackDescriptor>;\n}\n\nexport interface NoteSelection {\n  readonly kind: 'note';\n  readonly id: string;\n}\n\nexport interface EmptySelection {\n  readonly kind: 'empty';\n}\n\nexport enum ProfileType {\n  HEAP_PROFILE = 'heap_profile',\n  MIXED_HEAP_PROFILE = 'heap_profile:com.android.art,libc.malloc',\n  NATIVE_HEAP_PROFILE = 'heap_profile:libc.malloc',\n  JAVA_HEAP_SAMPLES = 'heap_profile:com.android.art',\n  JAVA_HEAP_GRAPH = 'graph',\n  PERF_SAMPLE = 'perf',\n}\n\nexport function profileType(s: string): ProfileType {\n  if (s === 'heap_profile:libc.malloc,com.android.art') {\n    s = 'heap_profile:com.android.art,libc.malloc';\n  }\n  if (Object.values(ProfileType).includes(s as ProfileType)) {\n    return s as ProfileType;\n  }\n  if (s.startsWith('heap_profile')) {\n    return ProfileType.HEAP_PROFILE;\n  }\n  throw new Error('Unknown type ${s}');\n}\n\nexport interface SqlSelectionResolver {\n  readonly sqlTableName: string;\n  readonly callback: (\n    id: number,\n    sqlTable: string,\n  ) => Promise<{trackUri: string; eventId: number} | undefined>;\n}\n"]}