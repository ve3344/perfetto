{"version":3,"file":"slice_args_parser.js","sourceRoot":"","sources":["../../../../src/components/details/slice_args_parser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use size file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {isString} from '../../base/object_utils';\nimport {exists} from '../../base/utils';\n\nexport type Key = string | number;\n\nexport interface ArgNode<T> {\n  key: Key;\n  value?: T;\n  children?: ArgNode<T>[];\n}\n\n// Arranges a flat list of arg-like objects (objects with a string \"key\" value\n// indicating their path) into a nested tree.\n//\n// This process is relatively forgiving as it allows nodes with both values and\n// child nodes as well as children with mixed key types in the same node.\n//\n// When duplicate nodes exist, the latest one is picked.\n//\n// If you want to convert args to a POJO, try convertArgsToObject().\n//\n// Key should be a path seperated by periods (.) or indexes specified using a\n// number inside square brackets.\n// e.g. foo.bar[0].x\n//\n// See unit tests for examples.\nexport function convertArgsToTree<T extends {key: string}>(\n  input: T[],\n): ArgNode<T>[] {\n  const result: ArgNode<T>[] = [];\n  for (const arg of input) {\n    const {key} = arg;\n    const nestedKey = getNestedKey(key);\n    insert(result, nestedKey, key, arg);\n  }\n  return result;\n}\n\nfunction getNestedKey(key: string): Key[] {\n  const result: Key[] = [];\n  let match;\n  const re = /([^\\.\\[\\]]+)|\\[(\\d+)\\]/g;\n  while ((match = re.exec(key)) !== null) {\n    result.push(match[2] ? parseInt(match[2]) : match[1]);\n  }\n  return result;\n}\n\nfunction insert<T>(\n  args: ArgNode<T>[],\n  keys: Key[],\n  path: string,\n  value: T,\n): void {\n  const currentKey = keys.shift()!;\n  let node = args.find((x) => x.key === currentKey);\n  if (!node) {\n    node = {key: currentKey};\n    args.push(node);\n  }\n  if (keys.length > 0) {\n    if (node.children === undefined) {\n      node.children = [];\n    }\n    insert(node.children, keys, path, value);\n  } else {\n    node.value = value;\n  }\n}\n\ntype ArgLike<T> = {\n  key: string;\n  value: T;\n};\ntype ObjectType<T> = T | ObjectType<T>[] | {[key: string]: ObjectType<T>};\n\n// Converts a list of argument-like objects (i.e. objects with key and value\n// fields) to a POJO.\n//\n// This function cannot handle cases where nodes contain mixed node types (i.e.\n// both number and string types) as nodes cannot be both an object and an array,\n// and will throw when this situation arises.\n//\n// Key should be a path seperated by periods (.) or indexes specified using a\n// number inside square brackets.\n// e.g. foo.bar[0].x\n//\n// See unit tests for examples.\nexport function convertArgsToObject<A extends ArgLike<T>, T>(\n  input: A[],\n): ObjectType<T> {\n  const nested = convertArgsToTree(input);\n  return parseNodes(nested);\n}\n\nfunction parseNodes<A extends ArgLike<T>, T>(\n  nodes: ArgNode<A>[],\n): ObjectType<T> {\n  if (nodes.every(({key}) => isString(key))) {\n    const dict: ObjectType<T> = {};\n    for (const node of nodes) {\n      if (node.key in dict) {\n        throw new Error(`Duplicate key ${node.key}`);\n      }\n      dict[node.key] = parseNode(node);\n    }\n    return dict;\n  } else if (nodes.every(({key}) => typeof key === 'number')) {\n    const array: ObjectType<T>[] = [];\n    for (const node of nodes) {\n      const index = node.key as number;\n      if (index in array) {\n        throw new Error(`Duplicate array index ${index}`);\n      }\n      array[index] = parseNode(node);\n    }\n    return array;\n  } else {\n    throw new Error('Invalid mix of node key types');\n  }\n}\n\nfunction parseNode<A extends ArgLike<T>, T>({\n  value,\n  children,\n}: ArgNode<A>): ObjectType<T> {\n  if (exists(value) && !exists(children)) {\n    return value.value;\n  } else if (!exists(value) && exists(children)) {\n    return parseNodes(children);\n  } else {\n    throw new Error('Invalid node type');\n  }\n}\n"]}