{"version":3,"file":"base_slice_track.js","sourceRoot":"","sources":["../../../../src/components/tracks/base_slice_track.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2021 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assertExists} from '../../base/logging';\nimport {clamp, floatEqual} from '../../base/math_utils';\nimport {Duration, Time, time} from '../../base/time';\nimport {exists} from '../../base/utils';\nimport {\n  drawIncompleteSlice,\n  drawTrackHoverTooltip,\n} from '../../base/canvas_utils';\nimport {cropText} from '../../base/string_utils';\nimport {colorCompare} from '../../public/color';\nimport {UNEXPECTED_PINK} from '../colorizer';\nimport {TrackEventDetails} from '../../public/selection';\nimport {featureFlags} from '../../core/feature_flags';\nimport {raf} from '../../core/raf_scheduler';\nimport {Track} from '../../public/track';\nimport {Slice} from '../../public/track';\nimport {LONG, NUM} from '../../trace_processor/query_result';\nimport {checkerboardExcept} from '../checkerboard';\nimport {DEFAULT_SLICE_LAYOUT, SliceLayout} from './slice_layout';\nimport {BUCKETS_PER_PIXEL, CacheKey} from './timeline_cache';\nimport {uuidv4Sql} from '../../base/uuid';\nimport {AsyncDisposableStack} from '../../base/disposable_stack';\nimport {TrackMouseEvent, TrackRenderContext} from '../../public/track';\nimport {Point2D, VerticalBounds} from '../../base/geom';\nimport {Trace} from '../../public/trace';\nimport {SourceDataset, Dataset} from '../../trace_processor/dataset';\n\n// The common class that underpins all tracks drawing slices.\n\nexport const SLICE_FLAGS_INCOMPLETE = 1;\nexport const SLICE_FLAGS_INSTANT = 2;\n\n// Slices smaller than this don't get any text:\nconst SLICE_MIN_WIDTH_FOR_TEXT_PX = 5;\nconst SLICE_MIN_WIDTH_PX = 1 / BUCKETS_PER_PIXEL;\nconst SLICE_MIN_WIDTH_FADED_PX = 0.1;\n\nconst CHEVRON_WIDTH_PX = 10;\nconst DEFAULT_SLICE_COLOR = UNEXPECTED_PINK;\nconst INCOMPLETE_SLICE_WIDTH_PX = 20;\n\nexport const CROP_INCOMPLETE_SLICE_FLAG = featureFlags.register({\n  id: 'cropIncompleteSlice',\n  name: 'Crop incomplete slices',\n  description: 'Display incomplete slices in short form',\n  defaultValue: false,\n});\n\nexport const FADE_THIN_SLICES_FLAG = featureFlags.register({\n  id: 'fadeThinSlices',\n  name: 'Fade thin slices',\n  description: 'Display sub-pixel slices in a faded way',\n  defaultValue: false,\n});\n\n// Exposed and standalone to allow for testing without making this\n// visible to subclasses.\nfunction filterVisibleSlices<S extends Slice>(\n  slices: S[],\n  start: time,\n  end: time,\n): S[] {\n  // Here we aim to reduce the number of slices we have to draw\n  // by ignoring those that are not visible. A slice is visible iff:\n  //   slice.endNsQ >= start && slice.startNsQ <= end\n  // It's allowable to include slices which aren't visible but we\n  // must not exclude visible slices.\n  // We could filter this.slices using this condition but since most\n  // often we should have the case where there are:\n  // - First a bunch of non-visible slices to the left of the viewport\n  // - Then a bunch of visible slices within the viewport\n  // - Finally a second bunch of non-visible slices to the right of the\n  //   viewport.\n  // It seems more sensible to identify the left-most and right-most\n  // visible slices then 'slice' to select these slices and everything\n  // between.\n\n  // We do not need to handle non-ending slices (where dur = -1\n  // but the slice is drawn as 'infinite' length) as this is handled\n  // by a special code path. See 'incomplete' in maybeRequestData.\n\n  // While the slices are guaranteed to be ordered by timestamp we must\n  // consider async slices (which are not perfectly nested). This is to\n  // say if we see slice A then B it is guaranteed the A.start <= B.start\n  // but there is no guarantee that (A.end < B.start XOR A.end >= B.end).\n  // Due to this is not possible to use binary search to find the first\n  // visible slice. Consider the following situation:\n  //         start V            V end\n  //     AAA  CCC       DDD   EEEEEEE\n  //      BBBBBBBBBBBB            GGG\n  //                           FFFFFFF\n  // B is visible but A and C are not. In general there could be\n  // arbitrarily many slices between B and D which are not visible.\n\n  // You could binary search to find D (i.e. the first slice which\n  // starts after |start|) then work backwards to find B.\n  // The last visible slice is simpler, since the slices are sorted\n  // by timestamp you can binary search for the last slice such\n  // that slice.start <= end.\n\n  // One specific edge case that will come up often is when:\n  // For all slice in slices: slice.startNsQ > end (e.g. all slices are\n  // to the right).\n  // Since the slices are sorted by startS we can check this easily:\n  const maybeFirstSlice: S | undefined = slices[0];\n  if (exists(maybeFirstSlice) && maybeFirstSlice.startNs > end) {\n    return [];\n  }\n\n  return slices.filter((slice) => slice.startNs <= end && slice.endNs >= start);\n}\n\nexport const filterVisibleSlicesForTesting = filterVisibleSlices;\n\n// The minimal set of columns that any table/view must expose to render tracks.\n// Note: this class assumes that, at the SQL level, slices are:\n// - Not temporally overlapping (unless they are nested at inner depth).\n// - Strictly stacked (i.e. a slice at depth N+1 cannot be larger than any\n//   slices at depth 0..N.\n// If you need temporally overlapping slices, look at AsyncSliceTrack, which\n// merges several tracks into one visual track.\nexport const BASE_ROW = {\n  id: NUM, // The slice ID, for selection / lookups.\n  ts: LONG, // True ts in nanoseconds.\n  dur: LONG, // True duration in nanoseconds. -1 = incomplete, 0 = instant.\n  tsQ: LONG, // Quantized start time in nanoseconds.\n  durQ: LONG, // Quantized duration in nanoseconds.\n  depth: NUM, // Vertical depth.\n};\n\nexport type BaseRow = typeof BASE_ROW;\n\n// These properties change @ 60FPS and shouldn't be touched by the subclass.\n// since the Impl doesn't see every frame attempting to reason on them in a\n// subclass will run in to issues.\ninterface SliceInternal {\n  x: number;\n  w: number;\n}\n\n// We use this to avoid exposing subclasses to the properties that live on\n// SliceInternal. Within BaseSliceTrack the underlying storage and private\n// methods use CastInternal<S> (i.e. whatever the subclass requests\n// plus our implementation fields) but when we call 'virtual' methods that\n// the subclass should implement we use just S hiding x & w.\ntype CastInternal<S extends Slice> = S & SliceInternal;\n\nexport abstract class BaseSliceTrack<\n  SliceT extends Slice = Slice,\n  RowT extends BaseRow = BaseRow,\n> implements Track\n{\n  protected sliceLayout: SliceLayout = {...DEFAULT_SLICE_LAYOUT};\n  protected trackUuid = uuidv4Sql();\n\n  // This is the over-skirted cached bounds:\n  private slicesKey: CacheKey = CacheKey.zero();\n\n  // This is the currently 'cached' slices:\n  private slices = new Array<CastInternal<SliceT>>();\n\n  // Incomplete slices (dur = -1). Rather than adding a lot of logic to\n  // the SQL queries to handle this case we materialise them one off\n  // then unconditionally render them. This should be efficient since\n  // there are at most |depth| slices.\n  private incomplete = new Array<CastInternal<SliceT>>();\n\n  // The currently selected slice.\n  // TODO(hjd): We should fetch this from the underlying data rather\n  // than just remembering it when we see it.\n  private selectedSlice?: CastInternal<SliceT>;\n\n  private extraSqlColumns: string[];\n\n  private charWidth = -1;\n  private hoverPos?: Point2D;\n  protected hoveredSlice?: SliceT;\n  private hoverTooltip: string[] = [];\n  private maxDataDepth = 0;\n\n  // Computed layout.\n  private computedTrackHeight = 0;\n  private computedSliceHeight = 0;\n  private computedRowSpacing = 0;\n\n  private readonly trash: AsyncDisposableStack;\n\n  // Extension points.\n  // Each extension point should take a dedicated argument type (e.g.,\n  // OnSliceOverArgs {slice?: S}) so it makes future extensions\n  // non-API-breaking (e.g. if we want to add the X position).\n\n  // onInit hook lets you do asynchronous set up e.g. creating a table\n  // etc. We guarantee that this will be resolved before doing any\n  // queries using the result of getSqlSource(). All persistent\n  // state in trace_processor should be cleaned up when dispose is\n  // called on the returned hook. In the common case of where\n  // the data for this track is a SQL fragment this does nothing.\n  async onInit(): Promise<AsyncDisposable | void> {}\n\n  // This should be an SQL expression returning all the columns listed\n  // mentioned by getRowSpec() excluding tsq and tsqEnd.\n  // For example you might return an SQL expression of the form:\n  // `select id, ts, dur, 0 as depth from foo where bar = 'baz'`\n  abstract getSqlSource(): string;\n\n  protected abstract getRowSpec(): RowT;\n  onSliceOver(_args: OnSliceOverArgs<SliceT>): void {}\n  onSliceOut(_args: OnSliceOutArgs<SliceT>): void {}\n\n  // By default, clicked slices create track selections\n  onSliceClick({slice}: OnSliceClickArgs<Slice>): void {\n    this.trace.selection.selectTrackEvent(this.uri, slice.id);\n  }\n\n  // The API contract of onUpdatedSlices() is:\n  //  - I am going to draw these slices in the near future.\n  //  - I am not going to draw any slice that I haven't passed here first.\n  //  - This is guaranteed to be called at least once on every global\n  //    state update.\n  //  - This is NOT guaranteed to be called on every frame. For instance you\n  //    cannot use this to do some colour-based animation.\n  onUpdatedSlices(slices: Array<SliceT>): void {\n    this.highlightHoveredAndSameTitle(slices);\n  }\n\n  // TODO(hjd): Remove.\n  drawSchedLatencyArrow(\n    _: CanvasRenderingContext2D,\n    _selectedSlice?: SliceT,\n  ): void {}\n\n  constructor(\n    protected readonly trace: Trace,\n    protected readonly uri: string,\n  ) {\n    // Work out the extra columns.\n    // This is the union of the embedder-defined columns and the base columns\n    // we know about (ts, dur, ...).\n    const allCols = Object.keys(this.getRowSpec());\n    const baseCols = Object.keys(BASE_ROW);\n    this.extraSqlColumns = allCols.filter((key) => !baseCols.includes(key));\n\n    this.trash = new AsyncDisposableStack();\n  }\n\n  setSliceLayout(sliceLayout: SliceLayout) {\n    if (\n      sliceLayout.isFlat &&\n      sliceLayout.depthGuess !== undefined &&\n      sliceLayout.depthGuess !== 0\n    ) {\n      const {isFlat, depthGuess} = sliceLayout;\n      throw new Error(\n        `if isFlat (${isFlat}) then depthGuess (${depthGuess}) must be 0 if defined`,\n      );\n    }\n    this.sliceLayout = sliceLayout;\n  }\n\n  onFullRedraw(): void {\n    // Give a chance to the embedder to change colors and other stuff.\n    this.onUpdatedSlices(this.slices);\n    this.onUpdatedSlices(this.incomplete);\n    if (this.selectedSlice !== undefined) {\n      this.onUpdatedSlices([this.selectedSlice]);\n    }\n  }\n\n  private getTitleFont(): string {\n    const size = this.sliceLayout.titleSizePx ?? 12;\n    return `${size}px Roboto Condensed`;\n  }\n\n  private getSubtitleFont(): string {\n    const size = this.sliceLayout.subtitleSizePx ?? 8;\n    return `${size}px Roboto Condensed`;\n  }\n\n  private getTableName(): string {\n    return `slice_${this.trackUuid}`;\n  }\n\n  async onCreate(): Promise<void> {\n    const result = await this.onInit();\n    result && this.trash.use(result);\n\n    // TODO(hjd): Consider case below:\n    // raw:\n    // 0123456789\n    //   [A     did not end)\n    //     [B ]\n    //\n    //\n    // quantised:\n    // 0123456789\n    //   [A     did not end)\n    // [     B  ]\n    // Does it lead to odd results?\n    const extraCols = this.extraSqlColumns.join(',');\n    let queryRes;\n    if (CROP_INCOMPLETE_SLICE_FLAG.get()) {\n      queryRes = await this.engine.query(`\n          select\n            ${this.depthColumn()},\n            ts as tsQ,\n            ts,\n            -1 as durQ,\n            -1 as dur,\n            id\n            ${extraCols ? ',' + extraCols : ''}\n          from (${this.getSqlSource()})\n          where dur = -1;\n        `);\n    } else {\n      queryRes = await this.engine.query(`\n        select\n          ${this.depthColumn()},\n          max(ts) as tsQ,\n          ts,\n          -1 as durQ,\n          -1 as dur,\n          id\n          ${extraCols ? ',' + extraCols : ''}\n        from (${this.getSqlSource()})\n        group by 1\n        having dur = -1\n      `);\n    }\n    const incomplete = new Array<CastInternal<SliceT>>(queryRes.numRows());\n    const it = queryRes.iter(this.getRowSpec());\n    for (let i = 0; it.valid(); it.next(), ++i) {\n      incomplete[i] = this.rowToSliceInternal(it);\n    }\n    this.onUpdatedSlices(incomplete);\n    this.incomplete = incomplete;\n\n    await this.engine.query(`\n      create virtual table ${this.getTableName()}\n      using __intrinsic_slice_mipmap((\n        select id, ts, dur, ${this.depthColumn()}\n        from (${this.getSqlSource()})\n        where dur != -1\n      ));\n    `);\n\n    this.trash.defer(async () => {\n      await this.engine.tryQuery(`drop table ${this.getTableName()}`);\n    });\n  }\n\n  async onUpdate({visibleWindow, size}: TrackRenderContext): Promise<void> {\n    const windowSizePx = Math.max(1, size.width);\n    const timespan = visibleWindow.toTimeSpan();\n    const rawSlicesKey = CacheKey.create(\n      timespan.start,\n      timespan.end,\n      windowSizePx,\n    );\n\n    // If the visible time range is outside the cached area, requests\n    // asynchronously new data from the SQL engine.\n    await this.maybeRequestData(rawSlicesKey);\n  }\n\n  render({ctx, size, visibleWindow, timescale}: TrackRenderContext): void {\n    // TODO(hjd): fonts and colors should come from the CSS and not hardcoded\n    // here.\n\n    // In any case, draw whatever we have (which might be stale/incomplete).\n    let charWidth = this.charWidth;\n    if (charWidth < 0) {\n      // TODO(hjd): Centralize font measurement/invalidation.\n      ctx.font = this.getTitleFont();\n      charWidth = this.charWidth = ctx.measureText('dbpqaouk').width / 8;\n    }\n\n    // Filter only the visible slices. |this.slices| will have more slices than\n    // needed because maybeRequestData() over-fetches to handle small pan/zooms.\n    // We don't want to waste time drawing slices that are off screen.\n    const vizSlices = this.getVisibleSlicesInternal(\n      visibleWindow.start.toTime('floor'),\n      visibleWindow.end.toTime('ceil'),\n    );\n\n    const selection = this.trace.selection.selection;\n    const selectedId =\n      selection.kind === 'track_event' && selection.trackUri === this.uri\n        ? selection.eventId\n        : undefined;\n\n    if (selectedId === undefined) {\n      this.selectedSlice = undefined;\n    }\n    let discoveredSelection: CastInternal<SliceT> | undefined;\n\n    // Believe it or not, doing 4xO(N) passes is ~2x faster than trying to draw\n    // everything in one go. The key is that state changes operations on the\n    // canvas (e.g., color, fonts) dominate any number crunching we do in JS.\n\n    const sliceHeight = this.computedSliceHeight;\n    const padding = this.sliceLayout.padding;\n    const rowSpacing = this.computedRowSpacing;\n\n    // First pass: compute geometry of slices.\n\n    // pxEnd is the last visible pixel in the visible viewport. Drawing\n    // anything < 0 or > pxEnd doesn't produce any visible effect as it goes\n    // beyond the visible portion of the canvas.\n    const pxEnd = size.width;\n\n    for (const slice of vizSlices) {\n      // Compute the basic geometry for any visible slice, even if only\n      // partially visible. This might end up with a negative x if the\n      // slice starts before the visible time or with a width that overflows\n      // pxEnd.\n      slice.x = timescale.timeToPx(slice.startNs);\n      slice.w = timescale.durationToPx(slice.durNs);\n\n      if (slice.flags & SLICE_FLAGS_INSTANT) {\n        // In the case of an instant slice, set the slice geometry on the\n        // bounding box that will contain the chevron.\n        slice.x -= CHEVRON_WIDTH_PX / 2;\n        slice.w = CHEVRON_WIDTH_PX;\n      } else if (slice.flags & SLICE_FLAGS_INCOMPLETE) {\n        let widthPx;\n        if (CROP_INCOMPLETE_SLICE_FLAG.get()) {\n          widthPx =\n            slice.x > 0\n              ? Math.min(pxEnd, INCOMPLETE_SLICE_WIDTH_PX)\n              : Math.max(0, INCOMPLETE_SLICE_WIDTH_PX + slice.x);\n          slice.x = Math.max(slice.x, 0);\n        } else {\n          slice.x = Math.max(slice.x, 0);\n          widthPx = pxEnd - slice.x;\n        }\n        slice.w = widthPx;\n      } else {\n        // If the slice is an actual slice, intersect the slice geometry with\n        // the visible viewport (this affects only the first and last slice).\n        // This is so that text is always centered even if we are zoomed in.\n        // Visually if we have\n        //                   [    visible viewport   ]\n        //  [         slice         ]\n        // The resulting geometry will be:\n        //                   [slice]\n        // So that the slice title stays within the visible region.\n        const sliceVizLimit = Math.min(slice.x + slice.w, pxEnd);\n        slice.x = Math.max(slice.x, 0);\n        slice.w = sliceVizLimit - slice.x;\n      }\n\n      if (selectedId === slice.id) {\n        discoveredSelection = slice;\n      }\n    }\n\n    // Second pass: fill slices by color.\n    const vizSlicesByColor = vizSlices.slice();\n    vizSlicesByColor.sort((a, b) =>\n      colorCompare(a.colorScheme.base, b.colorScheme.base),\n    );\n    let lastColor = undefined;\n    for (const slice of vizSlicesByColor) {\n      const color = slice.isHighlighted\n        ? slice.colorScheme.variant.cssString\n        : slice.colorScheme.base.cssString;\n      if (color !== lastColor) {\n        lastColor = color;\n        ctx.fillStyle = color;\n      }\n      const y = padding + slice.depth * (sliceHeight + rowSpacing);\n      if (slice.flags & SLICE_FLAGS_INSTANT) {\n        this.drawChevron(ctx, slice.x, y, sliceHeight);\n      } else if (slice.flags & SLICE_FLAGS_INCOMPLETE) {\n        const w = CROP_INCOMPLETE_SLICE_FLAG.get()\n          ? slice.w\n          : Math.max(slice.w - 2, 2);\n        drawIncompleteSlice(\n          ctx,\n          slice.x,\n          y,\n          w,\n          sliceHeight,\n          !CROP_INCOMPLETE_SLICE_FLAG.get(),\n        );\n      } else {\n        const w = Math.max(\n          slice.w,\n          FADE_THIN_SLICES_FLAG.get()\n            ? SLICE_MIN_WIDTH_FADED_PX\n            : SLICE_MIN_WIDTH_PX,\n        );\n        ctx.fillRect(slice.x, y, w, sliceHeight);\n      }\n    }\n\n    // Pass 2.5: Draw fillRatio light section.\n    ctx.fillStyle = `#FFFFFF50`;\n    for (const slice of vizSlicesByColor) {\n      // Can't draw fill ratio on incomplete or instant slices.\n      if (slice.flags & (SLICE_FLAGS_INCOMPLETE | SLICE_FLAGS_INSTANT)) {\n        continue;\n      }\n\n      // Clamp fillRatio between 0.0 -> 1.0\n      const fillRatio = clamp(slice.fillRatio, 0, 1);\n\n      // Don't draw anything if the fill ratio is 1.0ish\n      if (floatEqual(fillRatio, 1)) {\n        continue;\n      }\n\n      // Work out the width of the light section\n      const sliceDrawWidth = Math.max(slice.w, SLICE_MIN_WIDTH_PX);\n      const lightSectionDrawWidth = sliceDrawWidth * (1 - fillRatio);\n\n      // Don't draw anything if the light section is smaller than 1 px\n      if (lightSectionDrawWidth < 1) {\n        continue;\n      }\n\n      const y = padding + slice.depth * (sliceHeight + rowSpacing);\n      const x = slice.x + (sliceDrawWidth - lightSectionDrawWidth);\n      ctx.fillRect(x, y, lightSectionDrawWidth, sliceHeight);\n    }\n\n    // Third pass, draw the titles (e.g., process name for sched slices).\n    ctx.textAlign = 'center';\n    ctx.font = this.getTitleFont();\n    ctx.textBaseline = 'middle';\n    for (const slice of vizSlices) {\n      if (\n        slice.flags & SLICE_FLAGS_INSTANT ||\n        !slice.title ||\n        slice.w < SLICE_MIN_WIDTH_FOR_TEXT_PX\n      ) {\n        continue;\n      }\n\n      // Change the title color dynamically depending on contrast.\n      const textColor = slice.isHighlighted\n        ? slice.colorScheme.textVariant\n        : slice.colorScheme.textBase;\n      ctx.fillStyle = textColor.cssString;\n      const title = cropText(slice.title, charWidth, slice.w);\n      const rectXCenter = slice.x + slice.w / 2;\n      const y = padding + slice.depth * (sliceHeight + rowSpacing);\n      const yDiv = slice.subTitle ? 3 : 2;\n      const yMidPoint = Math.floor(y + sliceHeight / yDiv) + 0.5;\n      ctx.fillText(title, rectXCenter, yMidPoint);\n    }\n\n    // Fourth pass, draw the subtitles (e.g., thread name for sched slices).\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';\n    ctx.font = this.getSubtitleFont();\n    for (const slice of vizSlices) {\n      if (\n        slice.w < SLICE_MIN_WIDTH_FOR_TEXT_PX ||\n        !slice.subTitle ||\n        slice.flags & SLICE_FLAGS_INSTANT\n      ) {\n        continue;\n      }\n      const rectXCenter = slice.x + slice.w / 2;\n      const subTitle = cropText(slice.subTitle, charWidth, slice.w);\n      const y = padding + slice.depth * (sliceHeight + rowSpacing);\n      const yMidPoint = Math.ceil(y + (sliceHeight * 2) / 3) + 1.5;\n      ctx.fillText(subTitle, rectXCenter, yMidPoint);\n    }\n\n    // Here we need to ensure we never draw a slice that hasn't been\n    // updated via the math above so we don't use this.selectedSlice\n    // directly.\n    if (discoveredSelection !== undefined) {\n      this.selectedSlice = discoveredSelection;\n\n      // Draw a thicker border around the selected slice (or chevron).\n      const slice = discoveredSelection;\n      const color = slice.colorScheme;\n      const y = padding + slice.depth * (sliceHeight + rowSpacing);\n      ctx.strokeStyle = color.base.setHSL({s: 100, l: 10}).cssString;\n      ctx.beginPath();\n      const THICKNESS = 3;\n      ctx.lineWidth = THICKNESS;\n      ctx.strokeRect(\n        slice.x,\n        y - THICKNESS / 2,\n        slice.w,\n        sliceHeight + THICKNESS,\n      );\n      ctx.closePath();\n    }\n\n    // If the cached trace slices don't fully cover the visible time range,\n    // show a gray rectangle with a \"Loading...\" label.\n    checkerboardExcept(\n      ctx,\n      this.getHeight(),\n      0,\n      size.width,\n      timescale.timeToPx(this.slicesKey.start),\n      timescale.timeToPx(this.slicesKey.end),\n    );\n\n    // TODO(hjd): Remove this.\n    // The only thing this does is drawing the sched latency arrow. We should\n    // have some abstraction for that arrow (ideally the same we'd use for\n    // flows).\n    this.drawSchedLatencyArrow(ctx, this.selectedSlice);\n\n    // If a slice is hovered, draw the tooltip.\n    const tooltip = this.hoverTooltip;\n    if (\n      this.hoveredSlice !== undefined &&\n      tooltip.length > 0 &&\n      this.hoverPos !== undefined\n    ) {\n      if (tooltip.length === 1) {\n        drawTrackHoverTooltip(ctx, this.hoverPos, size, tooltip[0]);\n      } else {\n        drawTrackHoverTooltip(ctx, this.hoverPos, size, tooltip[0], tooltip[1]);\n      }\n    } // if (hoveredSlice)\n  }\n\n  async onDestroy(): Promise<void> {\n    await this.trash.asyncDispose();\n  }\n\n  // This method figures out if the visible window is outside the bounds of\n  // the cached data and if so issues new queries (i.e. sorta subsumes the\n  // onBoundsChange).\n  private async maybeRequestData(rawSlicesKey: CacheKey) {\n    if (rawSlicesKey.isCoveredBy(this.slicesKey)) {\n      return; // We have the data already, no need to re-query\n    }\n\n    // Determine the cache key:\n    const slicesKey = rawSlicesKey.normalize();\n    if (!rawSlicesKey.isCoveredBy(slicesKey)) {\n      throw new Error(\n        `Normalization error ${slicesKey.toString()} ${rawSlicesKey.toString()}`,\n      );\n    }\n\n    const resolution = slicesKey.bucketSize;\n    const extraCols = this.extraSqlColumns.join(',');\n    const queryRes = await this.engine.query(`\n      SELECT\n        (z.ts / ${resolution}) * ${resolution} as tsQ,\n        ((z.dur + ${resolution - 1n}) / ${resolution}) * ${resolution} as durQ,\n        s.ts as ts,\n        s.dur as dur,\n        s.id,\n        z.depth\n        ${extraCols ? ',' + extraCols : ''}\n      FROM ${this.getTableName()}(\n        ${slicesKey.start},\n        ${slicesKey.end},\n        ${resolution}\n      ) z\n      CROSS JOIN (${this.getSqlSource()}) s using (id)\n    `);\n\n    // Here convert each row to a Slice. We do what we can do\n    // generically in the base class, and delegate the rest to the impl\n    // via that rowToSlice() abstract call.\n    const slices = new Array<CastInternal<SliceT>>();\n    const it = queryRes.iter(this.getRowSpec());\n\n    let maxDataDepth = this.maxDataDepth;\n    this.slicesKey = slicesKey;\n    for (let i = 0; it.valid(); it.next(), ++i) {\n      if (it.dur === -1n) {\n        continue;\n      }\n\n      maxDataDepth = Math.max(maxDataDepth, it.depth);\n      // Construct the base slice. The Impl will construct and return\n      // the full derived T[\"slice\"] (e.g. CpuSlice) in the\n      // rowToSlice() method.\n      slices.push(this.rowToSliceInternal(it));\n    }\n    this.maxDataDepth = maxDataDepth;\n    this.onUpdatedSlices(slices);\n    this.slices = slices;\n\n    raf.scheduleCanvasRedraw();\n  }\n\n  private rowToSliceInternal(row: RowT): CastInternal<SliceT> {\n    const slice = this.rowToSlice(row);\n\n    // If this is a more updated version of the selected slice throw\n    // away the old one.\n    if (this.selectedSlice?.id === slice.id) {\n      this.selectedSlice = undefined;\n    }\n\n    return {\n      ...slice,\n      x: -1,\n      w: -1,\n    };\n  }\n\n  protected abstract rowToSlice(row: RowT): SliceT;\n\n  protected rowToSliceBase(row: RowT): Slice {\n    let flags = 0;\n    if (row.dur === -1n) {\n      flags |= SLICE_FLAGS_INCOMPLETE;\n    } else if (row.dur === 0n) {\n      flags |= SLICE_FLAGS_INSTANT;\n    }\n\n    return {\n      id: row.id,\n      startNs: Time.fromRaw(row.tsQ),\n      endNs: Time.fromRaw(row.tsQ + row.durQ),\n      durNs: row.durQ,\n      ts: Time.fromRaw(row.ts),\n      dur: row.dur,\n      flags,\n      depth: row.depth,\n      title: '',\n      subTitle: '',\n      fillRatio: 1,\n\n      // The derived class doesn't need to initialize these. They are\n      // rewritten on every renderCanvas() call. We just need to initialize\n      // them to something.\n      colorScheme: DEFAULT_SLICE_COLOR,\n      isHighlighted: false,\n    };\n  }\n\n  private findSlice({x, y, timescale}: TrackMouseEvent): undefined | SliceT {\n    const trackHeight = this.computedTrackHeight;\n    const sliceHeight = this.computedSliceHeight;\n    const padding = this.sliceLayout.padding;\n    const rowSpacing = this.computedRowSpacing;\n\n    // Need at least a draw pass to resolve the slice layout.\n    if (sliceHeight === 0) {\n      return undefined;\n    }\n\n    const depth = Math.floor((y - padding) / (sliceHeight + rowSpacing));\n\n    if (y >= padding && y <= trackHeight - padding) {\n      for (const slice of this.slices) {\n        if (slice.depth === depth && slice.x <= x && x <= slice.x + slice.w) {\n          return slice;\n        }\n      }\n    }\n\n    for (const slice of this.incomplete) {\n      const startPx = CROP_INCOMPLETE_SLICE_FLAG.get()\n        ? timescale.timeToPx(slice.startNs)\n        : slice.x;\n      const cropUnfinishedSlicesCondition = CROP_INCOMPLETE_SLICE_FLAG.get()\n        ? startPx + INCOMPLETE_SLICE_WIDTH_PX >= x\n        : true;\n\n      if (\n        slice.depth === depth &&\n        startPx <= x &&\n        cropUnfinishedSlicesCondition\n      ) {\n        return slice;\n      }\n    }\n\n    return undefined;\n  }\n\n  private isFlat(): boolean {\n    return this.sliceLayout.isFlat ?? false;\n  }\n\n  private depthColumn(): string {\n    return this.isFlat() ? '0 as depth' : 'depth';\n  }\n\n  onMouseMove(event: TrackMouseEvent): void {\n    const {x, y} = event;\n    this.hoverPos = {x, y};\n    this.updateHoveredSlice(this.findSlice(event));\n  }\n\n  onMouseOut(): void {\n    this.updateHoveredSlice(undefined);\n  }\n\n  private updateHoveredSlice(slice?: SliceT): void {\n    const lastHoveredSlice = this.hoveredSlice;\n    this.hoveredSlice = slice;\n\n    // Only notify the Impl if the hovered slice changes:\n    if (slice === lastHoveredSlice) return;\n\n    if (this.hoveredSlice === undefined) {\n      this.trace.timeline.highlightedSliceId = undefined;\n      this.onSliceOut({slice: assertExists(lastHoveredSlice)});\n      this.hoverTooltip = [];\n      this.hoverPos = undefined;\n    } else {\n      const args: OnSliceOverArgs<SliceT> = {slice: this.hoveredSlice};\n      this.trace.timeline.highlightedSliceId = this.hoveredSlice.id;\n      this.onSliceOver(args);\n      this.hoverTooltip = args.tooltip || [];\n    }\n  }\n\n  onMouseClick(event: TrackMouseEvent): boolean {\n    const slice = this.findSlice(event);\n    if (slice === undefined) {\n      return false;\n    }\n    const args: OnSliceClickArgs<SliceT> = {slice};\n    this.onSliceClick(args);\n    return true;\n  }\n\n  private getVisibleSlicesInternal(\n    start: time,\n    end: time,\n  ): Array<CastInternal<SliceT>> {\n    // Slice visibility is computed using tsq / endTsq. The means an\n    // event at ts=100n can end up with tsq=90n depending on the bucket\n    // calculation. start and end here are the direct unquantised\n    // boundaries so when start=100n we should see the event at tsq=90n\n    // Ideally we would quantize start and end via the same calculation\n    // we used for slices but since that calculation happens in SQL\n    // this is hard. Instead we increase the range by +1 bucket in each\n    // direction. It's fine to overestimate since false positives\n    // (incorrectly marking a slice as visible) are not a problem it's\n    // only false negatives we have to avoid.\n    start = Time.sub(start, this.slicesKey.bucketSize);\n    end = Time.add(end, this.slicesKey.bucketSize);\n\n    let slices = filterVisibleSlices<CastInternal<SliceT>>(\n      this.slices,\n      start,\n      end,\n    );\n    slices = slices.concat(this.incomplete);\n    // The selected slice is always visible:\n    if (this.selectedSlice && !this.slices.includes(this.selectedSlice)) {\n      slices.push(this.selectedSlice);\n    }\n    return slices;\n  }\n\n  private updateSliceAndTrackHeight() {\n    const lay = this.sliceLayout;\n    const rows = Math.max(this.maxDataDepth, lay.depthGuess ?? 0) + 1;\n\n    // Compute the track height.\n    let trackHeight;\n    if (lay.heightMode === 'FIXED') {\n      trackHeight = lay.fixedHeight;\n    } else {\n      trackHeight = 2 * lay.padding + rows * (lay.sliceHeight + lay.rowSpacing);\n    }\n\n    // Compute the slice height.\n    let sliceHeight: number;\n    let rowSpacing: number = lay.rowSpacing;\n    if (lay.heightMode === 'FIXED') {\n      const rowHeight = (trackHeight - 2 * lay.padding) / rows;\n      sliceHeight = Math.floor(Math.max(rowHeight - lay.rowSpacing, 0.5));\n      rowSpacing = Math.max(lay.rowSpacing, rowHeight - sliceHeight);\n      rowSpacing = Math.floor(rowSpacing * 2) / 2;\n    } else {\n      sliceHeight = lay.sliceHeight;\n    }\n    this.computedSliceHeight = sliceHeight;\n    this.computedTrackHeight = trackHeight;\n    this.computedRowSpacing = rowSpacing;\n  }\n\n  private drawChevron(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    h: number,\n  ) {\n    // Draw an upward facing chevrons, in order: A, B, C, D, and back to A.\n    // . (x, y)\n    //      A\n    //     ###\n    //    ##C##\n    //   ##   ##\n    //  D       B\n    //            . (x + CHEVRON_WIDTH_PX, y + h)\n    const HALF_CHEVRON_WIDTH_PX = CHEVRON_WIDTH_PX / 2;\n    const midX = x + HALF_CHEVRON_WIDTH_PX;\n    ctx.beginPath();\n    ctx.moveTo(midX, y); // A.\n    ctx.lineTo(x + CHEVRON_WIDTH_PX, y + h); // B.\n    ctx.lineTo(midX, y + h - HALF_CHEVRON_WIDTH_PX); // C.\n    ctx.lineTo(x, y + h); // D.\n    ctx.lineTo(midX, y); // Back to A.\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // This is a good default implementation for highlighting slices. By default\n  // onUpdatedSlices() calls this. However, if the XxxSliceTrack impl overrides\n  // onUpdatedSlices() this gives them a chance to call the highlighting without\n  // having to reimplement it.\n  protected highlightHoveredAndSameTitle(slices: Slice[]) {\n    for (const slice of slices) {\n      const isHovering =\n        this.trace.timeline.highlightedSliceId === slice.id ||\n        (this.hoveredSlice && this.hoveredSlice.title === slice.title);\n      slice.isHighlighted = !!isHovering;\n    }\n  }\n\n  getHeight(): number {\n    this.updateSliceAndTrackHeight();\n    return this.computedTrackHeight;\n  }\n\n  getSliceVerticalBounds(depth: number): VerticalBounds | undefined {\n    this.updateSliceAndTrackHeight();\n\n    const totalSliceHeight = this.computedRowSpacing + this.computedSliceHeight;\n    const top = this.sliceLayout.padding + depth * totalSliceHeight;\n\n    return {\n      top,\n      bottom: top + this.computedSliceHeight,\n    };\n  }\n\n  protected get engine() {\n    return this.trace.engine;\n  }\n\n  async getSelectionDetails(\n    id: number,\n  ): Promise<TrackEventDetails | undefined> {\n    const query = `\n      SELECT\n        ts,\n        dur\n      FROM (${this.getSqlSource()})\n      WHERE id = ${id}\n    `;\n\n    const result = await this.engine.query(query);\n    if (result.numRows() === 0) {\n      return undefined;\n    }\n    const row = result.iter({\n      ts: LONG,\n      dur: LONG,\n    });\n    return {ts: Time.fromRaw(row.ts), dur: Duration.fromRaw(row.dur)};\n  }\n\n  getDataset(): Dataset | undefined {\n    return new SourceDataset({\n      src: this.getSqlSource(),\n      schema: {\n        id: NUM,\n        ts: LONG,\n        dur: LONG,\n      },\n    });\n  }\n}\n\n// This is the argument passed to onSliceOver(args).\n// This is really a workaround for the fact that TypeScript doesn't allow\n// inner types within a class (whether the class is templated or not).\nexport interface OnSliceOverArgs<S extends Slice> {\n  // Input args (BaseSliceTrack -> Impl):\n  slice: S; // The slice being hovered.\n\n  // Output args (Impl -> BaseSliceTrack):\n  tooltip?: string[]; // One entry per row, up to a max of 2.\n}\n\nexport interface OnSliceOutArgs<S extends Slice> {\n  // Input args (BaseSliceTrack -> Impl):\n  slice: S; // The slice which is not hovered anymore.\n}\n\nexport interface OnSliceClickArgs<S extends Slice> {\n  // Input args (BaseSliceTrack -> Impl):\n  slice: S; // The slice which is clicked.\n}\n"]}