{"version":3,"file":"query_counter_track.js","sourceRoot":"","sources":["../../../../src/components/tracks/query_counter_track.ts"],"names":[],"mappings":";AAAA,qDAAqD;AACrD,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;;AAoDjC,0DAcC;AAhED,+DAAoE;AAEpE,0DAAoD;AACpD,6DAAsE;AAqCtE;;;;;;;;;GASG;AACI,KAAK,UAAU,uBAAuB,CAAC,IAA2B;IACvE,MAAM,SAAS,GAAG,yBAAyB,IAAA,0BAAW,EAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;IACnE,MAAM,2BAA2B,CAC/B,IAAI,CAAC,KAAK,CAAC,MAAM,EACjB,SAAS,EACT,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,OAAO,CACb,CAAC;IACF,OAAO,IAAI,oBAAoB,CAC7B,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,GAAG,EACR,SAAS,EACT,IAAI,CAAC,OAAO,CACb,CAAC;AACJ,CAAC;AAED,KAAK,UAAU,2BAA2B,CACxC,MAAc,EACd,SAAiB,EACjB,IAAmB,EACnB,gBAA+C,EAAE;IAEjD,MAAM,EAAC,EAAE,GAAG,IAAI,EAAE,KAAK,GAAG,OAAO,EAAC,GAAG,aAAa,CAAC;IACnD,MAAM,KAAK,GAAG;;QAER,IAAI,CAAC,SAAS;;;QAGd,EAAE;QACF,KAAK;;;GAGV,CAAC;IAEF,OAAO,MAAM,IAAA,+BAAmB,EAAC,MAAM,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;AAC7D,CAAC;AAED,MAAM,oBAAqB,SAAQ,qCAAgB;IAI9B;IAHnB,YACE,KAAY,EACZ,GAAW,EACM,YAAoB,EACrC,OAAiC;QAEjC,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;QAHV,iBAAY,GAAZ,YAAY,CAAQ;IAIvC,CAAC;IAED,YAAY;QACV,OAAO,iBAAiB,IAAI,CAAC,YAAY,EAAE,CAAC;IAC9C,CAAC;CACF","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {createPerfettoTable} from '../../trace_processor/sql_utils';\nimport {Trace} from '../../public/trace';\nimport {sqlNameSafe} from '../../base/string_utils';\nimport {BaseCounterTrack, CounterOptions} from './base_counter_track';\nimport {Engine} from '../../trace_processor/engine';\n\nexport interface QueryCounterTrackArgs {\n  // The trace object used to run queries.\n  readonly trace: Trace;\n\n  // A unique, reproducible ID for this track.\n  readonly uri: string;\n\n  // The query and optional column remapping.\n  readonly data: SqlDataSource;\n\n  // Optional: Which columns should be used for ts, and value. If omitted,\n  // the defaults 'ts', and 'value' will be used.\n  readonly columns?: Partial<CounterColumnMapping>;\n\n  // Optional: Display options for the counter track.\n  readonly options?: Partial<CounterOptions>;\n}\n\nexport interface SqlDataSource {\n  // SQL source selecting the necessary data.\n  readonly sqlSource: string;\n\n  // Optional: Rename columns from the query result.\n  // If omitted, original column names from the query are used instead.\n  // The caller is responsible for ensuring that the number of items in this\n  // list matches the number of columns returned by sqlSource.\n  readonly columns?: string[];\n}\n\nexport interface CounterColumnMapping {\n  readonly ts: string;\n  readonly value: string;\n}\n\n/**\n * Creates a counter track based on a query.\n *\n * The query must provide the following columns:\n * - ts: INTEGER - The timestamp of each sample.\n * - value: REAL | INTEGER - The value of each sample.\n *\n * The column names don't have to be 'ts' and 'value', and can be remapped if\n * convenient using the config.columns parameter.\n */\nexport async function createQueryCounterTrack(args: QueryCounterTrackArgs) {\n  const tableName = `__query_counter_track_${sqlNameSafe(args.uri)}`;\n  await createPerfettoTableForTrack(\n    args.trace.engine,\n    tableName,\n    args.data,\n    args.columns,\n  );\n  return new SqlTableCounterTrack(\n    args.trace,\n    args.uri,\n    tableName,\n    args.options,\n  );\n}\n\nasync function createPerfettoTableForTrack(\n  engine: Engine,\n  tableName: string,\n  data: SqlDataSource,\n  columnMapping: Partial<CounterColumnMapping> = {},\n) {\n  const {ts = 'ts', value = 'value'} = columnMapping;\n  const query = `\n    with data as (\n      ${data.sqlSource}\n    )\n    select\n      ${ts} as ts,\n      ${value} as value\n    from data\n    order by ts\n  `;\n\n  return await createPerfettoTable(engine, tableName, query);\n}\n\nclass SqlTableCounterTrack extends BaseCounterTrack {\n  constructor(\n    trace: Trace,\n    uri: string,\n    private readonly sqlTableName: string,\n    options?: Partial<CounterOptions>,\n  ) {\n    super(trace, uri, options);\n  }\n\n  getSqlSource(): string {\n    return `select * from ${this.sqlTableName}`;\n  }\n}\n"]}