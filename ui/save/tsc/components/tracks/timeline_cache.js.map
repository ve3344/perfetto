{"version":3,"file":"timeline_cache.js","sourceRoot":"","sources":["../../../../src/components/tracks/timeline_cache.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2023 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {BigintMath} from '../../base/bigint_math';\nimport {duration, time, Time} from '../../base/time';\n\nexport const BUCKETS_PER_PIXEL = 2;\n\n// CacheKey is a specific region of the timeline defined by the\n// following four properties:\n// - startNs\n// - endNs\n// - bucketNs\n// - windowSizePx\n// startNs is the beginning of the region in ns\n// endNs is the end of the region in ns\n// bucketNs is the size of a single bucket within the region which is\n//          used for quantizing the timeline.\n// windowSizePx is the size of the whole window in pixels.\n//\n// In the nominal case bucketNs is\n// set so that 1px of the screen corresponds to N bucketNs worth of\n// time where 1 < N < 10. This ensures that we show the maximum\n// amount of data given the available screen real estate.\n// We shouldn't rely on this property when rendering however since in\n// some situations (i.e. after zooming before new data has loaded) it\n// may not be the case.\n//\n// CacheKey's can be 'normalized' - rounding the interval up and the\n// bucket size down. For a given CacheKey key ('foo') the normalized\n// version ('normal') has the properties:\n//   normal.startNs <= foo.startNs\n//   normal.endNs => foo.endNs\n//   normal.bucketNs <= foo.bucketNs\n//   normal.windowSizePx ~= windowSizePx (we round to the nearest 100px)\n//   foo.isCoveredBy(foo) == true\n//   foo.isCoveredBy(normal) == true\n//   normal.isCoveredBy(normal) == true\n//   normal.isCoveredBy(foo) == false unless normal == foo\n//   normalize(normal) == normal\n//\n// In other words the normal window is a superset of the data of the\n// non-normal window at a higher resolution. Normalization is used to\n// avoid re-fetching data on tiny zooms/moves/resizes.\nexport class CacheKey {\n  readonly start: time;\n  readonly end: time;\n  readonly bucketSize: duration;\n  readonly windowSizePx: number;\n\n  static create(startNs: time, endNs: time, windowSizePx: number): CacheKey {\n    const bucketNs =\n      (endNs - startNs) / BigInt(Math.round(windowSizePx * BUCKETS_PER_PIXEL));\n    return new CacheKey(\n      startNs,\n      endNs,\n      BigintMath.max(1n, bucketNs),\n      windowSizePx,\n    );\n  }\n\n  private constructor(\n    startNs: time,\n    endNs: time,\n    bucketNs: duration,\n    windowSizePx: number,\n  ) {\n    this.start = startNs;\n    this.end = endNs;\n    this.bucketSize = bucketNs;\n    this.windowSizePx = windowSizePx;\n  }\n\n  static zero(): CacheKey {\n    return new CacheKey(Time.ZERO, Time.ZERO, 0n, 100);\n  }\n\n  get normalizedBucketNs(): bigint {\n    // Round bucketNs down to the nearest smaller power of 2 (minimum 1):\n    return BigintMath.max(1n, BigintMath.bitFloor(this.bucketSize));\n  }\n\n  get normalizedWindowSizePx(): number {\n    return Math.max(100, Math.round(this.windowSizePx / 100) * 100);\n  }\n\n  normalize(): CacheKey {\n    const windowSizePx = this.normalizedWindowSizePx;\n    const bucketNs = this.normalizedBucketNs;\n    const windowNs = BigInt(windowSizePx * BUCKETS_PER_PIXEL) * bucketNs;\n    const startNs = Time.quantFloor(this.start, windowNs);\n    const endNs = Time.quantCeil(this.end, windowNs);\n    return new CacheKey(startNs, endNs, bucketNs, windowSizePx);\n  }\n\n  isNormalized(): boolean {\n    return this.toString() === this.normalize().toString();\n  }\n\n  isCoveredBy(other: CacheKey): boolean {\n    let r = true;\n    r = r && other.start <= this.start;\n    r = r && other.end >= this.end;\n    r = r && other.normalizedBucketNs === this.normalizedBucketNs;\n    r = r && other.normalizedWindowSizePx === this.normalizedWindowSizePx;\n    return r;\n  }\n\n  // toString is 'load bearing' in that it's used to key e.g. caches\n  // with CacheKey's.\n  toString() {\n    const start = this.start;\n    const end = this.end;\n    const bucket = this.bucketSize;\n    const size = this.windowSizePx;\n    return `CacheKey<${start}, ${end}, ${bucket}, ${size}>`;\n  }\n}\n"]}