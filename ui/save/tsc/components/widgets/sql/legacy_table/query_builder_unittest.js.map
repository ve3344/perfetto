{"version":3,"file":"query_builder_unittest.js","sourceRoot":"","sources":["../../../../../../src/components/widgets/sql/legacy_table/query_builder_unittest.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2024 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {sqliteString} from '../../../../base/string_utils';\nimport {SourceTable} from './column';\nimport {buildSqlQuery} from './query_builder';\n\nfunction normalise(str: string): string {\n  return str.replace(/\\s+/g, ' ').trim();\n}\n\ntest('query_builder.basic_select', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n        },\n      }),\n    ),\n  ).toBe('SELECT slice_0.id AS id FROM slice AS slice_0');\n});\n\ntest('query_builder.basic_filter', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n        },\n        filters: [\n          {\n            op: (cols) => `${cols[0]} != -1`,\n            columns: ['ts'],\n          },\n        ],\n      }),\n    ),\n  ).toBe(\n    'SELECT slice_0.id AS id FROM slice AS slice_0 WHERE slice_0.ts != -1',\n  );\n});\n\ntest('query_builder.basic_order_by', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n        },\n        orderBy: [\n          {\n            column: 'ts',\n            direction: 'ASC',\n          },\n        ],\n      }),\n    ),\n  ).toBe(\n    'SELECT slice_0.id AS id FROM slice AS slice_0 ORDER BY slice_0.ts ASC',\n  );\n});\n\ntest('query_builder.simple_join', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n          name: 'name',\n          parent_name: {\n            column: 'name',\n            source: {\n              table: 'slice',\n              joinOn: {\n                id: 'parent_id',\n              },\n            },\n          },\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      slice_0.id AS id,\n      slice_0.name AS name,\n      slice_1.name AS parent_name\n    FROM slice AS slice_0\n    LEFT JOIN slice AS slice_1 ON slice_1.id = slice_0.parent_id\n  `),\n  );\n});\n\n// Check a query with INNER JOIN instead of LEFT JOIN.\ntest('query_builder.left_join', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'foo',\n        columns: {\n          foo_id: 'id',\n          slice_name: {\n            column: 'name',\n            source: {\n              table: 'slice',\n              innerJoin: true,\n              joinOn: {\n                id: 'slice_id',\n              },\n            },\n          },\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      foo_0.id AS foo_id,\n      slice_1.name AS slice_name\n    FROM foo AS foo_0\n    JOIN slice AS slice_1 ON slice_1.id = foo_0.slice_id\n  `),\n  );\n});\n\n// Check a query which has both INNER JOIN and LEFT JOIN on the same table.\n// The correct behaviour here is debatable (probably we can upgrade INNER JOIN to LEFT JOIN),\n// but for now we just generate the query with two separate joins.\ntest('query_builder.left_join_and_inner_join', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'foo',\n        columns: {\n          foo_id: 'id',\n          slice_name: {\n            column: 'name',\n            source: {\n              table: 'slice',\n              innerJoin: true,\n              joinOn: {\n                id: 'slice_id',\n              },\n            },\n          },\n          slice_depth: {\n            column: 'depth',\n            source: {\n              table: 'slice',\n              joinOn: {\n                id: 'slice_id',\n              },\n            },\n          },\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      foo_0.id AS foo_id,\n      slice_1.name AS slice_name,\n      slice_2.depth AS slice_depth\n    FROM foo AS foo_0\n    JOIN slice AS slice_1 ON slice_1.id = foo_0.slice_id\n    LEFT JOIN slice AS slice_2 ON slice_2.id = foo_0.slice_id\n  `),\n  );\n});\n\ntest('query_builder.join_with_multiple_columns', () => {\n  // This test checks that the query builder can correctly deduplicate joins when we request multiple columns from the joined table.\n  const parent: SourceTable = {\n    table: 'slice',\n    joinOn: {\n      id: 'parent_id',\n    },\n  };\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n          name: 'name',\n          parent_name: {\n            column: 'name',\n            source: parent,\n          },\n          parent_dur: {\n            column: 'dur',\n            source: parent,\n          },\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      slice_0.id AS id,\n      slice_0.name AS name,\n      slice_1.name AS parent_name,\n      slice_1.dur AS parent_dur\n    FROM slice AS slice_0\n    LEFT JOIN slice AS slice_1 ON slice_1.id = slice_0.parent_id\n  `),\n  );\n});\n\ntest('query_builder.filter_on_joined_column', () => {\n  // This test checks that the query builder can correctly deduplicate joins when we request multiple columns from the joined table.\n  const parent: SourceTable = {\n    table: 'slice',\n    joinOn: {\n      id: 'parent_id',\n    },\n  };\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n          name: 'name',\n          parent_name: {\n            column: 'name',\n            source: parent,\n          },\n        },\n        filters: [\n          {\n            op: (cols) => `${cols[0]} != -1`,\n            columns: [\n              {\n                column: 'dur',\n                source: parent,\n              },\n            ],\n          },\n        ],\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      slice_0.id AS id,\n      slice_0.name AS name,\n      slice_1.name AS parent_name\n    FROM slice AS slice_0\n    LEFT JOIN slice AS slice_1 ON slice_1.id = slice_0.parent_id\n    WHERE slice_1.dur != -1\n  `),\n  );\n});\n\ntest('query_builder.complex_join', () => {\n  const threadTrack: SourceTable = {\n    table: 'thread_track',\n    joinOn: {\n      id: 'track_id',\n    },\n  };\n\n  const thread: SourceTable = {\n    table: 'thread',\n    joinOn: {\n      utid: {\n        column: 'utid',\n        source: threadTrack,\n      },\n    },\n  };\n\n  const process: SourceTable = {\n    table: 'process',\n    joinOn: {\n      upid: {\n        column: 'upid',\n        source: thread,\n      },\n    },\n  };\n\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          id: 'id',\n          name: 'name',\n          tid: {\n            column: 'tid',\n            source: thread,\n          },\n          thread_name: {\n            column: 'name',\n            source: thread,\n          },\n          pid: {\n            column: 'pid',\n            source: process,\n          },\n          process_name: {\n            column: 'name',\n            source: process,\n          },\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      slice_0.id AS id,\n      slice_0.name AS name,\n      thread_2.tid AS tid,\n      thread_2.name AS thread_name,\n      process_3.pid AS pid,\n      process_3.name AS process_name\n    FROM slice AS slice_0\n    LEFT JOIN thread_track AS thread_track_1 ON thread_track_1.id = slice_0.track_id\n    LEFT JOIN thread AS thread_2 ON thread_2.utid = thread_track_1.utid\n    LEFT JOIN process AS process_3 ON process_3.upid = thread_2.upid\n  `),\n  );\n});\n\ntest('query_builder.multiple_args', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          count: 'count()',\n          arg1: {\n            column: 'display_value',\n            source: {\n              table: 'args',\n              joinOn: {\n                arg_set_id: 'arg_set_id',\n                key: sqliteString('arg1'),\n              },\n            },\n          },\n          arg2: {\n            column: 'display_value',\n            source: {\n              table: 'args',\n              joinOn: {\n                arg_set_id: 'arg_set_id',\n                key: sqliteString('arg2'),\n              },\n            },\n          },\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      count() AS count,\n      args_1.display_value AS arg1,\n      args_2.display_value AS arg2\n    FROM slice AS slice_0\n    LEFT JOIN args AS args_1 ON args_1.arg_set_id = slice_0.arg_set_id AND args_1.key = 'arg1'\n    LEFT JOIN args AS args_2 ON args_2.arg_set_id = slice_0.arg_set_id AND args_2.key = 'arg2'\n  `),\n  );\n});\n\ntest('query_builder.expression', () => {\n  expect(\n    normalise(\n      buildSqlQuery({\n        table: 'slice',\n        columns: {\n          count: 'count()',\n        },\n      }),\n    ),\n  ).toBe(\n    normalise(`\n    SELECT\n      count() AS count\n    FROM slice AS slice_0\n  `),\n  );\n});\n"]}